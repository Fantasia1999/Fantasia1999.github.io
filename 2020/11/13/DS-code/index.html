<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/Fantasia1999/Fantasia1999.github.io/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="https://cdn.jsdelivr.net/gh/Fantasia1999/Fantasia1999.github.io/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="https://cdn.jsdelivr.net/gh/Fantasia1999/Fantasia1999.github.io/favicon.ico">
  <link rel="mask-icon" href="https://cdn.jsdelivr.net/gh/Fantasia1999/Fantasia1999.github.io/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=LatoEB Garamond:300,300italic,400,400italic,700,700italic|JetBrains Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://blog.zhuomu.xyz').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"buttons","active":null,"storage":true,"lazyload":true,"nav":{"disqus":{"text":"Load Disqus","order":-1}}},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":false,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="数据结构代码线性表——顺序表逆转顺序表中的所有元素void Reverse(int A[], int n)&amp;#123;    int i, t;    for(i&#x3D;0;i&lt;n&#x2F;2;i++)&amp;#123;        t &#x3D; A[i];        A[i] &#x3D; A[n-i-1];        A[n-i-1] &#x3D; t;    &amp;#125;&amp;#125;  线性表——链表删除线性链表中数据域">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构代码题汇总">
<meta property="og:url" content="https://blog.zhuomu.xyz/2020/11/13/DS-code/index.html">
<meta property="og:site_name" content="卓木&#39;s Blog">
<meta property="og:description" content="数据结构代码线性表——顺序表逆转顺序表中的所有元素void Reverse(int A[], int n)&amp;#123;    int i, t;    for(i&#x3D;0;i&lt;n&#x2F;2;i++)&amp;#123;        t &#x3D; A[i];        A[i] &#x3D; A[n-i-1];        A[n-i-1] &#x3D; t;    &amp;#125;&amp;#125;  线性表——链表删除线性链表中数据域">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-11-13T20:21:00.000Z">
<meta property="article:modified_time" content="2020-11-13T20:22:15.000Z">
<meta property="article:author" content="卓木">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blog.zhuomu.xyz/2020/11/13/DS-code/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;500;700&display=swap" rel="stylesheet">
  <title>数据结构代码题汇总 | 卓木's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/rss2.xml" title="卓木's Blog" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">卓木's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-desktop"></i>Home</a>

  </li>
        <li class="menu-item menu-item-kindle">

    <a href="/Kindle" rel="section"><i class="fa fa-fw fa-book"></i>Kindle</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user-circle-o"></i>About</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.zhuomu.xyz/2020/11/13/DS-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/Fantasia1999/Fantasia1999.github.io/medias/avatar.jpg">
      <meta itemprop="name" content="卓木">
      <meta itemprop="description" content="学习 分享 开源">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="卓木's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构代码题汇总
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-11-14 04:21:00 / 修改时间：04:22:15" itemprop="dateCreated datePublished" datetime="2020-11-14T04:21:00+08:00">2020-11-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0%E6%9C%AC/" itemprop="url" rel="index">
                    <span itemprop="name">笔记本</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/11/13/DS-code/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/11/13/DS-code/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="数据结构代码"><a href="#数据结构代码" class="headerlink" title="数据结构代码"></a>数据结构代码</h1><h2 id="线性表——顺序表"><a href="#线性表——顺序表" class="headerlink" title="线性表——顺序表"></a>线性表——顺序表</h2><h3 id="逆转顺序表中的所有元素"><a href="#逆转顺序表中的所有元素" class="headerlink" title="逆转顺序表中的所有元素"></a>逆转顺序表中的所有元素</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, t;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        t = A[i];</span><br><span class="line">        A[i] = A[n-i<span class="number">-1</span>];</span><br><span class="line">        A[n-i<span class="number">-1</span>] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线性表——链表"><a href="#线性表——链表" class="headerlink" title="线性表——链表"></a>线性表——链表</h2><h3 id="删除线性链表中数据域为item的所有结点"><a href="#删除线性链表中数据域为item的所有结点" class="headerlink" title="删除线性链表中数据域为item的所有结点"></a>删除线性链表中数据域为item的所有结点</h3><blockquote>
<p>算法思想：从第二个结点开始，从前往后一次判断链表中的结点是否满足要求。</p>
<p>再回过头来看链表第一个结点是否满足要求。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PurgeItem</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    LinkList p, q = L;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data==item)&#123;</span><br><span class="line">            q-&gt;next = p-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            p = q-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            q = p;</span><br><span class="line">            p = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;data==item)&#123;</span><br><span class="line">        q = L;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="逆转线性链表"><a href="#逆转线性链表" class="headerlink" title="逆转线性链表"></a>逆转线性链表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    LinkList p, q, r;</span><br><span class="line">    p = L;</span><br><span class="line">    q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        r = q;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        q-&gt;next = r;</span><br><span class="line">    &#125;</span><br><span class="line">    L = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复制线性链表（递归）"><a href="#复制线性链表（递归）" class="headerlink" title="复制线性链表（递归）"></a>复制线性链表（递归）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Copy</span><span class="params">(LinkList La)</span></span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    <span class="keyword">if</span>(La==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        L-&gt;data = La-&gt;data;</span><br><span class="line">        L-&gt;next = <span class="built_in">Copy</span>(La-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将两个按值有序排列的非空线性链表合并为一个按值有序的线性链表"><a href="#将两个按值有序排列的非空线性链表合并为一个按值有序的线性链表" class="headerlink" title="将两个按值有序排列的非空线性链表合并为一个按值有序的线性链表"></a>将两个按值有序排列的非空线性链表合并为一个按值有序的线性链表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">MergeList</span><span class="params">(LinkList La, LinkList Lb)</span></span>&#123;</span><br><span class="line">    LinkList Lc, p = La, q = Lb, r;</span><br><span class="line">    <span class="comment">//Lc 指向 La 和 Lb 所指结点中较小者</span></span><br><span class="line">    <span class="keyword">if</span>(La-&gt;data &lt;= Lb-&gt;data)&#123;</span><br><span class="line">        Lc = La;</span><br><span class="line">        r = La;</span><br><span class="line">        p = La-&gt;next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Lc = Lb;</span><br><span class="line">        r = Lb;</span><br><span class="line">        q = Lb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data&lt;=q-&gt;data)&#123;</span><br><span class="line">            r-&gt;next = p;</span><br><span class="line">            r = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r-&gt;next = q;</span><br><span class="line">            r = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将剩余结点（即未参加比较的且已按升序排列的结点）链接到整个链表后面</span></span><br><span class="line">	r-&gt;next = (p != <span class="literal">NULL</span>) ? p : q;</span><br><span class="line">    <span class="keyword">return</span> Lc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><h3 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild, *rchild;</span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树先序、中序、后序（递归版本）"><a href="#二叉树先序、中序、后序（递归版本）" class="headerlink" title="二叉树先序、中序、后序（递归版本）"></a>二叉树先序、中序、后序（递归版本）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">visit</span>(T);</span><br><span class="line">    <span class="built_in">PreOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">    <span class="built_in">PreOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">InOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">    <span class="built_in">visit</span>(T);</span><br><span class="line">    <span class="built_in">InOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">PostOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">    <span class="built_in">PostOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    <span class="built_in">visit</span>(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的先序遍历（非递归算法）"><a href="#二叉树的先序遍历（非递归算法）" class="headerlink" title="二叉树的先序遍历（非递归算法）"></a>二叉树的先序遍历（非递归算法）</h3><blockquote>
<p>算法思想：若 p 所指结点不为空，则访问该结点，然后将该结点的地址入栈，然后再将 p 指向其左孩 子结点；若 p 所指向的结点为空，则从堆栈中退出栈顶元素（某个结点的地址），将 p 指向其右孩子 结点。重复上述过程，直到 p &#x3D; NULL 且堆栈为空，遍历结束。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_STACK 50</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BTree T)</span></span>&#123;</span><br><span class="line">    BTree STACK[MAX_STACK], p = T;</span><br><span class="line">    <span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> || top != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(P != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">Visit</span>(p);</span><br><span class="line">            STACK[++top] = p;</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p = STACK[top--];</span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的中序遍历（非递归算法）"><a href="#二叉树的中序遍历（非递归算法）" class="headerlink" title="二叉树的中序遍历（非递归算法）"></a>二叉树的中序遍历（非递归算法）</h3><blockquote>
<p>算法思想：若 p 所指结点不为空，则将该结点的地址 p 入栈，然后再将 p 指向其左孩子结点；若 p 所 指向的结点为空，则从堆栈中退出栈顶元素（某个结点的地址）送 p，并访问该结点，然后再将 p 指 向该结点的右孩子结点。重复上述过程，直到 p &#x3D; NULL 且堆栈为空，遍历结束。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_STACK 50</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderTraverse</span><span class="params">(BTree T)</span></span>&#123;</span><br><span class="line">	BTree STACK[MAX_STACK], p = T;</span><br><span class="line">	<span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> || top != <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			STACK[++top] = p;</span><br><span class="line">			p = p-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		p = STACK[top--];</span><br><span class="line">		<span class="built_in">Visit</span>(p);</span><br><span class="line">		p = p-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的后序遍历（非递归算法）"><a href="#二叉树的后序遍历（非递归算法）" class="headerlink" title="二叉树的后序遍历（非递归算法）"></a>二叉树的后序遍历（非递归算法）</h3><blockquote>
<p>算法思想：当 p 指向某一结点时，不能马上对它进行访问，而要先访问它的左子树，因而要将此结点 的地址入栈；当其左子树访问完毕后，再次搜索到该结点时（该结点地址通过退栈得到），还不能对 它进行访问，还需要先访问它的右子树，所以，再一次将该结点的地址入栈。只有当该结点的右子 树访问完毕后回到该结点时，才能访问该结点。为了标明某结点是否可以访问，引入一个标志变量 flag，当 flag &#x3D; 0 时表示该结点暂不访问，flag &#x3D; 1 时表示该结点可以访问。flag 的值随同该结点的地 址一起入栈和出栈。因此，算法中设置了两个堆栈，其中 STACK1 存放结点的地址，STACK2 存放 标志变量 flag，两个堆栈使用同一栈顶指针 top，且 top 的初始值为 −1。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_STACK 50</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BTree T)</span> </span>&#123;</span><br><span class="line">    BTree STACK1[MAX_STACK], p = T;</span><br><span class="line">    <span class="type">int</span> STACK2[MAX_STACK], flag, top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> || top != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            STACK1[++top] = p;</span><br><span class="line">            STACK2[top] = <span class="number">0</span>;</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p = STACK1[top];</span><br><span class="line">        flag = STACK2[top--];</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            STACK1[++top] = p;</span><br><span class="line">            STACK2[top] = <span class="number">1</span>;</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">VISIT</span>(p);</span><br><span class="line">            p = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的按层次遍历"><a href="#二叉树的按层次遍历" class="headerlink" title="二叉树的按层次遍历"></a>二叉树的按层次遍历</h3><blockquote>
<p>算法思想：设置一个队列，首先将根结点（的地址）入队列，然后依次从队列中退出一个元素，每 退出一个元素，先访问该元素所指的结点，然后依次将该结点的左孩子结点（若存在的话）和右孩 子结点（若存在的话）入队列。如此重复下去，直到队列为空。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_QUEUE 50</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LayeredOrderTraverse</span><span class="params">(BTree T)</span> </span>&#123;</span><br><span class="line">    BTree QUEUE[MAX_QUEUE], p;</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        QUEUE[<span class="number">0</span>] = T;</span><br><span class="line">        front = <span class="number">-1</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (front &lt; rear) &#123;</span><br><span class="line">            p = QUEUE[++front];</span><br><span class="line">            <span class="built_in">VISIT</span>(P);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">                QUEUE[++rear] = p-&gt;lchild;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">                QUEUE[++rear] = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="建立二叉树（从键盘输入数据，先序遍历递归算法）"><a href="#建立二叉树（从键盘输入数据，先序遍历递归算法）" class="headerlink" title="建立二叉树（从键盘输入数据，先序遍历递归算法）"></a>建立二叉树（从键盘输入数据，先序遍历递归算法）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BTree <span class="title">CreateBT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    BTree T;</span><br><span class="line">    <span class="built_in">sacnf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        T = (BTree) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BTNode));</span><br><span class="line">        T-&gt;data = ch;</span><br><span class="line">        T-&gt;lchild = <span class="built_in">CreateBT</span>();</span><br><span class="line">        T-&gt;rchild = <span class="built_in">CreateBT</span>();</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="建立二叉树（从数组获取数据）"><a href="#建立二叉树（从数组获取数据）" class="headerlink" title="建立二叉树（从数组获取数据）"></a>建立二叉树（从数组获取数据）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function">BTree <span class="title">CreateBT</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> i, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    BTree p;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; n)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p = (BTree) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BTNode));</span><br><span class="line">        p-&gt;data = A[i];</span><br><span class="line">        p-&gt;lchild = <span class="built_in">CreateBT</span>(A, <span class="number">2</span> * i, n);</span><br><span class="line">        p-&gt;rchild = <span class="built_in">CreateBT</span>(A, <span class="number">2</span> * i + <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">T = <span class="built_in">CreateBT</span>(A, <span class="number">1</span>, n);</span><br><span class="line"><span class="comment">// 递归（从键盘输入数据）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree *T)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *T = (BiTree) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        <span class="keyword">if</span> (!(*T))</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        (*T)-&gt;data = ch;</span><br><span class="line">        <span class="built_in">CreateBiTree</span>(&amp;(*T)-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreateBiTree</span>(&amp;(*T)-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*--------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function">BTree <span class="title">CreateBT</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    BTree *pT;</span><br><span class="line">    <span class="comment">// 对应 n 个结点申请可容纳 n 个指针变量的内存空间</span></span><br><span class="line">    pT = (BTree *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BTree) * n);</span><br><span class="line">    <span class="comment">// 若数组中的某个元素不等于零，则申请相应的结点空间并进行赋值</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            pT[i] = (BTree) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BTNode));</span><br><span class="line">            pT[i]-&gt;data = A[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pT[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改结点的指针域的内容，使父结点指向左、右孩子结点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pT[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pT[i]-&gt;lchild = pT[<span class="number">2</span> * i];</span><br><span class="line">            pT[i]-&gt;rchild = pT[<span class="number">2</span> * i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求二叉树的深度（递归算法）"><a href="#求二叉树的深度（递归算法）" class="headerlink" title="求二叉树的深度（递归算法）"></a>求二叉树的深度（递归算法）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Depth</span><span class="params">(BTree T)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ldepth, rdepth;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ldepth = <span class="built_in">Depth</span>(T-&gt;lchild);</span><br><span class="line">        rdepth = <span class="built_in">Depth</span>(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">if</span> (ldepth &gt; rdepth)</span><br><span class="line">            <span class="keyword">return</span> ldepth + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> rdepth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求二叉树的深度（非递归算法）"><a href="#求二叉树的深度（非递归算法）" class="headerlink" title="求二叉树的深度（非递归算法）"></a>求二叉树的深度（非递归算法）</h3><blockquote>
<p>算法思想：对二叉树进行遍历，遍历过程中依次记录各个结点所处的层次数以及当前已经访问过的结点所处的最大层次数。每当访问到某个叶子结点时，将该叶子结点所处的层次数与最大层次数进行比较，若前者大于后者，则修改最大层次数为该叶子结点的层次数，否则不作修改。遍历结束时，所记录的最大层次数即为该二叉树的深度。本算法使用的是非递归的中序遍历算法（其它遍历顺序 也可以）。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_STACK 50</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Depth</span><span class="params">(BTree T)</span> </span>&#123;</span><br><span class="line">    BTree STACK1[MAX_STACK], p = T;</span><br><span class="line">    <span class="type">int</span> STACK2[MAX_STACK];</span><br><span class="line">    <span class="type">int</span> curdepth, maxdepth = <span class="number">0</span>, top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        curdepth = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span> || top != -) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                STACK1[++top] = p;</span><br><span class="line">                STACK2[top] = curdepth;</span><br><span class="line">                p = p-&gt;lchild;</span><br><span class="line">                curdepth++;</span><br><span class="line">            &#125;</span><br><span class="line">            p = STACK1[top];</span><br><span class="line">            curdepth = STACK2[top--];</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">if</span> (curdepth &gt; maxdepth)</span><br><span class="line">                    maxdepth = curdepth;</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">            curdepth++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxdepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求结点所在层次"><a href="#求结点所在层次" class="headerlink" title="求结点所在层次"></a>求结点所在层次</h3><blockquote>
<p>算法思想：采用后序遍历的非递归算法对二叉树进行遍历，遍历过程中对每一个结点判断其是否为满足条件的结点，若是满足条件的结点，则此时堆栈中保存的元素个数再加 1 即为该结点所在的层次。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_STACK 50</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LayerNode</span><span class="params">(BTree T, <span class="type">int</span> item)</span> </span>&#123;</span><br><span class="line">    BTree STACK1[MAX_STACK], p = T;</span><br><span class="line">    <span class="type">int</span> STACK2[MAX_STACK], flag, top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> || top != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            STACK1[++top] = p;</span><br><span class="line">            STACK2[top] = <span class="number">0</span>;</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p = STACK1[top];</span><br><span class="line">        flag = STACK2[top--];</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            STACK1[++top] = p;</span><br><span class="line">            STACK2[top] = <span class="number">1</span>;</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;data == item)</span><br><span class="line">                <span class="keyword">return</span> top + <span class="number">2</span>;</span><br><span class="line">            p = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="交换二叉树中所有结点的左右子树的位置"><a href="#交换二叉树中所有结点的左右子树的位置" class="headerlink" title="交换二叉树中所有结点的左右子树的位置"></a>交换二叉树中所有结点的左右子树的位置</h3><blockquote>
<p>算法思想：按层次遍历二叉树，遍历过程中每当访问一个结点时，就将该结点的左右子树的位置对调。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_QUEUE 50</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExchangeBT</span><span class="params">(BTree T)</span> </span>&#123;</span><br><span class="line">    BTree QUEUE[MAX_QUEUE], temp, p = T;</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        QUEUE[<span class="number">0</span>] = T;</span><br><span class="line">        front = <span class="number">-1</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (front &lt; rear) &#123;</span><br><span class="line">            p = QUEUE[++front];</span><br><span class="line">            temp = p-&gt;lchild;</span><br><span class="line">            p-&gt;lchild = p-&gt;rchild;</span><br><span class="line">            p-&gt;rchild = temp;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">                QUEUE[++rear] = p-&gt;lchild;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">                QUEUE[++rear] = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除二叉树中以某个结点为根结点的子树</p>
<blockquote>
<p>算法思想：先序遍历找到符合条件的结点（其它遍历方法亦可），然后删除以该结点为根结点的子树。 最后把该结点的父结点的相应的指针域置为 NULL。为此，需在算法中设置一个指针变量用以指示当 前结点的父结点。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_STACK 50</span></span><br><span class="line"><span class="function">BTree <span class="title">DeleteSubtree</span><span class="params">(BTree &amp;T, <span class="type">int</span> item)</span> </span>&#123;</span><br><span class="line">    BTree STACK[MAX_STACK], q, p = T;</span><br><span class="line">    <span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;data == item) &#123;</span><br><span class="line">        <span class="built_in">DestroyBT</span>(T);</span><br><span class="line">        T = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span> || top != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;data == item) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (q-&gt;lchild == p)</span><br><span class="line">                        q-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        q-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">                    <span class="built_in">DestroyBT</span>(p);</span><br><span class="line">                    <span class="keyword">return</span> T;</span><br><span class="line">                &#125;</span><br><span class="line">                STACK[++top] = p;</span><br><span class="line">                q = p;</span><br><span class="line">                p = p-&gt;lchild;</span><br><span class="line">            &#125;</span><br><span class="line">            q = STACK[top--];</span><br><span class="line">            p = q-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>顺序查找的递归算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">RecurSeqSearch</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> key, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (A[i] == key)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">RecurSeqSearch</span>(A, n, key, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pos = <span class="built_in">RecurSeqSearch</span>(A, n, key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinSearch</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, high = n - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (key == A[mid])</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (key &gt; A[mid])</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            high = mid – <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="折半查找的递归算法"><a href="#折半查找的递归算法" class="headerlink" title="折半查找的递归算法"></a>折半查找的递归算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">RecurBinSearch</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (key == A[mid])</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (key &gt; A[mid])</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">RecurBinSearch</span>(A, mid + <span class="number">1</span>, high, key);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">RecurBinSearch</span>(A, low, mid - <span class="number">1</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pos = <span class="built_in">RecurBinSearch</span>(A, <span class="number">0</span>, n - <span class="number">1</span>, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在按值递增排列且长度为-n-的线性表中折半查找并插入一元素"><a href="#在按值递增排列且长度为-n-的线性表中折半查找并插入一元素" class="headerlink" title="在按值递增排列且长度为 n 的线性表中折半查找并插入一元素"></a>在按值递增排列且长度为 n 的线性表中折半查找并插入一元素</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinInsert</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> &amp;n, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j, low = <span class="number">0</span>, high = n - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &gt; A[mid])</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            high = mid – <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = n; j &gt; low; j--)</span><br><span class="line">        A[j] = A[j - <span class="number">1</span>];</span><br><span class="line">    A[low] = key;</span><br><span class="line">    n++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在按值递增排列且长度为-n-的线性表中折半查找值不小于-key-的最小元素"><a href="#在按值递增排列且长度为-n-的线性表中折半查找值不小于-key-的最小元素" class="headerlink" title="在按值递增排列且长度为 n 的线性表中折半查找值不小于 key 的最小元素"></a>在按值递增排列且长度为 n 的线性表中折半查找值不小于 key 的最小元素</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinSearch</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, high = n - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (key == A[mid])</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (key &gt; A[mid])</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            high = mid – <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (low &lt;= n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><blockquote>
<p>算法思想：第 i 趟插入排序为：在含有 i − 1 个元素的有序子序列中插入一个元素，使之成为含有 i 个元素的有序子序列。在查找插入位置的过程中，可以同时后移元素。整个过程为进行 n − 1 趟插入， 即先将整个序列的第 1 个元素看成是有序的，然后从第 2 个元素起逐个进行插入，直到整个序列有序 为止。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt; A[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            j = i - <span class="number">1</span>;</span><br><span class="line">            temp = A[i];</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; A[j]) &#123;</span><br><span class="line">                A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            A[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><blockquote>
<p>算法思想：算法同直接插入排序，只不过使用折半查找的方法来寻找插入位置。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinInsertSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, low, high, mid, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        temp = A[i];</span><br><span class="line">        low = <span class="number">0</span>;</span><br><span class="line">        high = i – <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; A[mid])</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = mid – <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; low; j--)</span><br><span class="line">            A[j] = A[j - <span class="number">1</span>];</span><br><span class="line">        A[low] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><blockquote>
<p>算法思想：首先将第 1 个元素和第 2 个元素进行比较，若前者大于后者，则两者交换位置，然后比较 第 2 个元素和第 3 个元素。依此类推，直到第 n − 1 个元素和第 n 个元素进行过比较或交换为止。上 述过程称为一趟冒泡排序，其结果是使得 n 个元素中值最大的那个元素被安排在最后一个元素的位置 上。然后进行第二趟排序，即对前 n − 1 个元素进行同样的操作，使得前 n − 1 个元素中值最大的那 个元素被安排在第 n − 1 个位置上。一般地，第 i 趟冒泡排序是从前 n − i + 1 个元素中的第 1 个元素 开始，两两比较，若前者大于后者，则交换，结果使得前 n − i + 1 个元素中最大的元素被安排在第 n − i + 1 个位置上。显然，判断冒泡排序结束的条件是“在一趟排序中没有进行过交换元素的操作”， 为此，设立一个标志变量 flag，flag &#x3D; 1 表示有过交换元素的操作，flag &#x3D; 0 表示没有过交换元素的操 作，在每一趟排序开始前，将 flag 置为 0，在排序过程中，只要有交换元素的操作，就及时将 flag 置 为 1。因为至少要执行一趟排序操作，故第一趟排序时，flag &#x3D; 1。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp, flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span> &amp;&amp; flag == <span class="number">1</span>; i--) &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j] &gt; A[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = A[j];</span><br><span class="line">                A[j] = A[j + <span class="number">1</span>];</span><br><span class="line">                A[j + <span class="number">1</span>] = temp;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><blockquote>
<p>算法思想：第 i 趟排序从序列的后 n − i + 1（i &#x3D; 1, 2, …, n − 1）个元素中选择一个值最小的元素与该 个元素的第 1 个元素交换位置，即与整个序列的第 i 个元素交换。依此类推，直到 i &#x3D; n − 1 为止。也 就是说，每一趟排序从从未排好序的那些元素中选择一个值最小的元素，然后将其与这些未排好序 的元素中的第 1 个元素交换位置。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, min, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[min] &gt; A[j])</span><br><span class="line">                min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">            temp = A[min];</span><br><span class="line">            A[min] = A[i];</span><br><span class="line">            A[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><blockquote>
<p>算法思想：在参加排序的序列中任意选择一个元素（通常称为分界元素或基准元素），把小于或等于 分界元素的所有元素都移到分界元素的前面，把大于分界元素的所有元素都移到分界元素的后面， 这样，当前参加排序的序列就被划分成前后两个子序列，其中前一个子序列中的所有元素都小于后 一个子序列的所有元素，并且分界元素正好处于排序的最终位置上。然后分别对这两个子序列递归 地进行上述排序过程，直到所有元素都处于排序的最终位置上，排序结束。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">QSort</span>(A, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivotloc;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        pivot = <span class="built_in">Partition</span>(A, low, high);</span><br><span class="line">        <span class="built_in">QSort</span>(A, low, pivotloc - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">QSort</span>(A, pivotloc + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot;</span><br><span class="line">    pivot = A[low];</span><br><span class="line">    <span class="comment">// 从线性表的两端交替地向中间扫描</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot)</span><br><span class="line">            high--;</span><br><span class="line">        A[low] = A[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot)</span><br><span class="line">            low++;</span><br><span class="line">        A[high] = A[low];</span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, temp;</span><br><span class="line">    <span class="comment">// 建立大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> (i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(A, i, n);</span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        temp = A[<span class="number">1</span>];</span><br><span class="line">        A[<span class="number">1</span>] = A[i + <span class="number">1</span>];</span><br><span class="line">        A[i + <span class="number">1</span>] = temp;</span><br><span class="line">        <span class="comment">// 将 A[1..i] 重新调整为大顶堆</span></span><br><span class="line">        <span class="built_in">HeapAdjust</span>(A, <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, temp;</span><br><span class="line">    temp = A[low];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span> * low; i &lt;= high; i = i * <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 令 i 为关键字较大的记录的下标</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; high &amp;&amp; A[i] &lt; A[i + <span class="number">1</span>])</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= A[i])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            A[low] = A[i];</span><br><span class="line">            low = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = temp;<span class="comment">// 插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/26/cmd-Git-bash-proxy/" rel="prev" title="cmd/Git/Git bash/Linux命令行使用代理">
      <i class="fa fa-chevron-left"></i> cmd/Git/Git bash/Linux命令行使用代理
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/23/ubuntu-cst-utc-8/" rel="next" title="更改Ubuntu的时间为北京时间（东八区）">
      更改Ubuntu的时间为北京时间（东八区） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81"><span class="nav-number">1.</span> <span class="nav-text">数据结构代码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="nav-number">1.1.</span> <span class="nav-text">线性表——顺序表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%86%E8%BD%AC%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0"><span class="nav-number">1.1.1.</span> <span class="nav-text">逆转顺序表中的所有元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8"><span class="nav-number">1.2.</span> <span class="nav-text">线性表——链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%BA%BF%E6%80%A7%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%9F%9F%E4%B8%BAitem%E7%9A%84%E6%89%80%E6%9C%89%E7%BB%93%E7%82%B9"><span class="nav-number">1.2.1.</span> <span class="nav-text">删除线性链表中数据域为item的所有结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%86%E8%BD%AC%E7%BA%BF%E6%80%A7%E9%93%BE%E8%A1%A8"><span class="nav-number">1.2.2.</span> <span class="nav-text">逆转线性链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E7%BA%BF%E6%80%A7%E9%93%BE%E8%A1%A8%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89"><span class="nav-number">1.2.3.</span> <span class="nav-text">复制线性链表（递归）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E4%B8%A4%E4%B8%AA%E6%8C%89%E5%80%BC%E6%9C%89%E5%BA%8F%E6%8E%92%E5%88%97%E7%9A%84%E9%9D%9E%E7%A9%BA%E7%BA%BF%E6%80%A7%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%8C%89%E5%80%BC%E6%9C%89%E5%BA%8F%E7%9A%84%E7%BA%BF%E6%80%A7%E9%93%BE%E8%A1%A8"><span class="nav-number">1.2.4.</span> <span class="nav-text">将两个按值有序排列的非空线性链表合并为一个按值有序的线性链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">1.3.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">1.4.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.5.</span> <span class="nav-text">树与二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.5.1.</span> <span class="nav-text">结构定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%88%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%EF%BC%88%E9%80%92%E5%BD%92%E7%89%88%E6%9C%AC%EF%BC%89"><span class="nav-number">1.5.2.</span> <span class="nav-text">二叉树先序、中序、后序（递归版本）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">1.5.3.</span> <span class="nav-text">二叉树的先序遍历（非递归算法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">1.5.4.</span> <span class="nav-text">二叉树的中序遍历（非递归算法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">1.5.5.</span> <span class="nav-text">二叉树的后序遍历（非递归算法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8C%89%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="nav-number">1.5.6.</span> <span class="nav-text">二叉树的按层次遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%BB%8E%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">1.5.7.</span> <span class="nav-text">建立二叉树（从键盘输入数据，先序遍历递归算法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%BB%8E%E6%95%B0%E7%BB%84%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%89"><span class="nav-number">1.5.8.</span> <span class="nav-text">建立二叉树（从数组获取数据）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%EF%BC%88%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">1.5.9.</span> <span class="nav-text">求二叉树的深度（递归算法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%EF%BC%88%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">1.5.10.</span> <span class="nav-text">求二叉树的深度（非递归算法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%82%E7%BB%93%E7%82%B9%E6%89%80%E5%9C%A8%E5%B1%82%E6%AC%A1"><span class="nav-number">1.5.11.</span> <span class="nav-text">求结点所在层次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%80%E6%9C%89%E7%BB%93%E7%82%B9%E7%9A%84%E5%B7%A6%E5%8F%B3%E5%AD%90%E6%A0%91%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-number">1.5.12.</span> <span class="nav-text">交换二叉树中所有结点的左右子树的位置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number">1.6.</span> <span class="nav-text">图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE"><span class="nav-number">1.7.</span> <span class="nav-text">查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="nav-number">1.7.1.</span> <span class="nav-text">折半查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E7%9A%84%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95"><span class="nav-number">1.7.2.</span> <span class="nav-text">折半查找的递归算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%8C%89%E5%80%BC%E9%80%92%E5%A2%9E%E6%8E%92%E5%88%97%E4%B8%94%E9%95%BF%E5%BA%A6%E4%B8%BA-n-%E7%9A%84%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B8%AD%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E5%B9%B6%E6%8F%92%E5%85%A5%E4%B8%80%E5%85%83%E7%B4%A0"><span class="nav-number">1.7.3.</span> <span class="nav-text">在按值递增排列且长度为 n 的线性表中折半查找并插入一元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%8C%89%E5%80%BC%E9%80%92%E5%A2%9E%E6%8E%92%E5%88%97%E4%B8%94%E9%95%BF%E5%BA%A6%E4%B8%BA-n-%E7%9A%84%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B8%AD%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E5%80%BC%E4%B8%8D%E5%B0%8F%E4%BA%8E-key-%E7%9A%84%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0"><span class="nav-number">1.7.4.</span> <span class="nav-text">在按值递增排列且长度为 n 的线性表中折半查找值不小于 key 的最小元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.1.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.2.</span> <span class="nav-text">折半插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.3.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.4.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.5.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.6.</span> <span class="nav-text">堆排序</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="卓木"
      src="https://cdn.jsdelivr.net/gh/Fantasia1999/Fantasia1999.github.io/medias/avatar.jpg">
  <p class="site-author-name" itemprop="name">卓木</p>
  <div class="site-description" itemprop="description">学习 分享 开源</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Fantasia1999" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Fantasia1999" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:i@zhuomu.xyz" title="E-Mail → mailto:i@zhuomu.xyz" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/Kindle" title="Kindle → &#x2F;Kindle"><i class="fa fa-fw fa-book"></i>Kindle</a>
      </span>
      <span class="links-of-author-item">
        <a href="/rss2.xml" title="RSS → &#x2F;rss2.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">卓木</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://blog-zhuomu.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: {page: {
            url: "https://blog.zhuomu.xyz/2020/11/13/DS-code/",
            identifier: "2020/11/13/DS-code/",
            title: "数据结构代码题汇总"
          }
        }
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://blog-zhuomu.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
