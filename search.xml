<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CenOS 7 桥接网络配置</title>
      <link href="2021/04/29/centos-7-minimal-bridging/"/>
      <url>2021/04/29/centos-7-minimal-bridging/</url>
      
        <content type="html"><![CDATA[<p>最近在部署一个远程开发环境，为了稳定，就不再安装GUI界面了，直接ssh远程过去开发，所以选择了Minimal安装，Linux发行版选择的是CentOS 7 2009。</p><p>系统安装过程很简单，去tuna下载镜像，用VMware安装即可。</p><p>centos的镜像在<code>centos/7.9.2009/isos/x86_64/</code>路径下，选择<code>CentOS-7-x86_64-Minimal-2009.iso</code></p><p>为了能够让虚拟机能从校园网直接连接，在网络的配置上，选择了桥接模式，可以让主机获取一个独立的ip，而非192这种NAT后的内网ip。</p><p>也正是因为选择了桥接，导致服务器出现了一些配置的小问题。</p><p>如图，在进行yum安装软件的时候，出现了这样的错误<code>Could not resolve host: mirrorlist.centos.org; Unknowm error&quot; </code></p><p><img src="http://img.zhuomu.xyz/view/img/2021/04/29/image-20210429-bab035b.png"></p><p>当我想看一下ip的时候，发现没有安装net-tools，陷入了死循环。</p><p>其实根据上边的错误提示，大概是没有网络，由于我选的是桥接，可能需要自己手动配置。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>以下是配置方法：</p><ul><li><p>输入以下命令，找到网卡名称</p><ul><li><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nmcli d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我这里是<code>ens33</code></p></li></ul></li><li><p>编辑该网卡的配置</p><ul><li><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="http://img.zhuomu.xyz/view/img/2021/04/29/image-20210429-b8a4fe9.png" alt="ifcfg-ens33"></p><p>这里我们将<code>BOTPROTO</code>设为<code>dhcp</code>，<code>ONBOOT</code>设为<code>yes</code></p><p>按<code>Esc</code>，输入<code>:wq</code>进行保存</p></li></ul></li><li><p>重启网卡</p><ul><li><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart network.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>再次执行命令，发现可以正常安装了</li></ul></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo yum install update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果是要配置静态IP的话，还需要在后边附上配置，追加以下即可。</p><pre class="line-numbers language-none"><code class="language-none">IPADDR&#x3D;192.168.123.100NETMASK&#x3D;255.255.255.0GATEWAY&#x3D;192.168.123.1DNS1&#x3D;192.168.123.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>修改<code>BOOTPROTO</code>参数：<br><code>BOOTPROTO=static</code></p><blockquote><p>参考链接</p><p><a href="https://blog.csdn.net/Goldsea_/article/details/100628457">Centos7-Minimal版本使用yum报错–Could not resolve host</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术博文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置PicGo上传图片到Github图床</title>
      <link href="2021/04/28/upload-image-by-picgo/"/>
      <url>2021/04/28/upload-image-by-picgo/</url>
      
        <content type="html"><![CDATA[<h1 id="配置PicGo上传图片到Github图床"><a href="#配置PicGo上传图片到Github图床" class="headerlink" title="配置PicGo上传图片到Github图床"></a>配置PicGo上传图片到Github图床</h1><h2 id="什么是PicGo"><a href="#什么是PicGo" class="headerlink" title="什么是PicGo"></a>什么是PicGo</h2><p>Github开源项目：<a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p><blockquote><p>2021年4月28日</p></blockquote><p><strong>PicGo: 一个用于快速上传图片并获取图片 URL 链接的工具</strong></p><p>PicGo 本体支持如下图床：</p><ul><li><code>七牛图床</code> v1.0</li><li><code>腾讯云 COS v4\v5 版本</code> v1.1 &amp; v1.5.0</li><li><code>又拍云</code> v1.2.0</li><li><code>GitHub</code> v1.5.0</li><li><code>SM.MS V2</code> v2.3.0-beta.0</li><li><code>阿里云 OSS</code> v1.6.0</li><li><code>Imgur</code> v1.6.0</li></ul><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>前往Release页面下载最新版</p><p><a href="https://github.com/Molunerfinn/PicGo/releases/">https://github.com/Molunerfinn/PicGo/releases/</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="PicGo设置"><a href="#PicGo设置" class="headerlink" title="PicGo设置"></a>PicGo设置</h3><ul><li>开机自启</li><li>上传后自动复制URL</li><li>GitHub图床</li></ul><h3 id="图床设置"><a href="#图床设置" class="headerlink" title="图床设置"></a>图床设置</h3><ul><li>仓库名：<code>username/img</code>，格式为用户名+你的仓库名</li><li>分支：<code>main</code>，一般为main</li><li>Token：<code>xxxxxxxxxx</code></li><li>域名：<code>http://example.com/img</code></li></ul><h4 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h4><p>需要在github进行生成。</p><p><a href="https://github.com/settings/tokens">Personal Access Tokens (github.com)</a></p><p><img src="http://img.zhuomu.xyz/view/img/2021/04/28/image-20210428-4821e56.png" alt="Generate new token"></p><p>只给<code>repo, write:packages</code>权限即可。</p><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>这里强烈建议使用固定的域名，这样方便以后迁移图床，因为我们的链接都是写在博客里边，如果以后换图床的话，更改图片链接是一件很麻烦的事<del>（也可以写个脚本批量更改）</del>，这里定义后，以后如果换图床，只需要在服务器端更改一个301跳转就可以了，非常方便。</p><p>关于服务端如何配置，可以参考我<a href="https://blog.zhuomu.xyz/2021/03/05/move-OLAINDEX-to-PicGo/">上一篇博客</a>。</p><p>如果没有域名，就输入jsDeliver的默认链接<code>https://cdn.jsdelivr.net/gh/username/img</code>，img是你的仓库名，结尾不用加斜杠。</p><p>这就配置完成了。</p><blockquote><ul><li><p>建议新建一个Github小号来进行操作，因为如果频繁上传图片，github的绿点会比较密集。<del>造成非常努力的假象</del></p></li><li><p>在测试仓库的时候，也可以新建一个test仓库来进行上传测试，等到符合预期要求的时候，再新建一个仓库来作为正式图床。</p></li></ul></blockquote><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p><strong>rename-file</strong></p><p>这个插件是开源的，在<a href="https://github.com/liuwave/picgo-plugin-rename-file">这里</a>可以找到。</p><p>安装插件的方式很简答，直接在<code>插件设置</code>里搜索插件名就可以了。</p><p>命名规则：</p><ul><li>{y} 年，4位</li><li>{m} 月，2位</li><li>{d} 日期，2位</li><li>{h} 小时，2位</li><li>{i} 分钟，2位</li><li>{s} 秒，2位</li><li>{ms} 毫秒，3位(<strong>v1.0.4</strong>)</li><li>{timestamp} 时间戳(秒)，10位(<strong>v1.0.4</strong>)</li><li>{hash}，文件的md5值，32位</li><li>{origin}，文件原名（会去掉后缀）</li><li>{rand:<count>}, 随机数，<count>表示个数，默认为6个，示例：{rand：32}、{rand}</li><li>{localFolder:<count>}, <count>表示层级 ，默认为1，示例：{localFolder:6}、{localFolder}</li></ul><p>我的规则是</p><p><code>&#123;y&#125;/&#123;m&#125;/&#123;d&#125;/image-&#123;y&#125;&#123;m&#125;&#123;d&#125;-&#123;rand:7&#125;</code></p><p>解释一下：</p><p>比如上边我自定义的域名是<code>http://example.com/img</code>，那么我通过插件重命名后的链接就变成了</p><p><code>http://example.com/img/2021/04/28/image-20210428-c290202.png</code></p><p>斜杠之前可以看做<code>路径</code>，后边部分是<code>文件名</code></p><p>总体体验还是很流畅的，截图后，直接打开软件，粘贴一下，就自动得到了一个markdown链接，粘贴进Typora就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 技术博文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> 图床 </tag>
            
            <tag> PicGO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次博客图床迁移</title>
      <link href="2021/03/05/move-OLAINDEX-to-PicGo/"/>
      <url>2021/03/05/move-OLAINDEX-to-PicGo/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前博客的图片是使用的又拍云作为主图床，但是经常性看到有人CDN被刷，损失惨重，所以转念想使用GitHub托管图床+jsDelivr作为免费CDN加速访问。</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>最开始的图床是在服务器上部署了OLAINDEX索引OneDrive，使用非常方便，所有图片均在本地有备份，<del>数据在自己手里的感觉还是很安全的</del>，当时的版本号是4.0，上传图片后，链接格式为<code>https://img.example.com/view/xxxx/head.jpg</code>，这种格式也非常整齐，所有博客图片也采用这种格式书写，同时使用OLAINDEX的话，图床的速度很不理想，所以将OLAINDEX作为备份图床，采用又拍云作为图床首选方案，所以在又拍云上传时，为了避免大批量的修改博客中的图床链接，沿用了这种格式。</p><p>当时采取的方案是先上传到OLAINDEX，然后使用又拍云的CLI工具<code>upx.exe</code>，使用如下脚本批量上传到又拍云。</p><pre class="line-numbers language-bat" data-language="bat"><code class="language-bat">.\upx.exe img-zhuomu user password.\upx.exe sync E:&#x2F;OneDrive&#x2F;OLAINDEX&#x2F;img &#x2F;view&#x2F;img&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>后来升级5.0后，OLAINDEX开始支持多账号登录，于是图片链接格式变为了<code>https://img.example.com/hashid/view/xxxx/head.jpg</code>，多加了一级用以区别账号，给我造成了很大的困扰，每次写插入图片链接时都需要删除一级目录。遂逐渐弃用。</p><p>首先需要明白jsDelivr是如何给GitHub做CDN的。</p><p>比如一个repository:<code>https://github.com/test/img</code>，只需要按照如下规则修改前缀即可。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; load any GitHub release, commit, or branch&#x2F;&#x2F; note: we recommend using npm for projects that support ithttps:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;user&#x2F;repo@version&#x2F;file&#x2F;&#x2F; load jQuery v3.2.1https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jquery&#x2F;jquery@3.2.1&#x2F;dist&#x2F;jquery.min.js&#x2F;&#x2F; use a version range instead of a specific versionhttps:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jquery&#x2F;jquery@3.2&#x2F;dist&#x2F;jquery.min.jshttps:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jquery&#x2F;jquery@3&#x2F;dist&#x2F;jquery.min.js&#x2F;&#x2F; omit the version completely to get the latest one&#x2F;&#x2F; you should NOT use this in productionhttps:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jquery&#x2F;jquery&#x2F;dist&#x2F;jquery.min.js&#x2F;&#x2F; add &quot;.min&quot; to any JS&#x2F;CSS file to get a minified version&#x2F;&#x2F; if one doesn&#39;t exist, we&#39;ll generate it for youhttps:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jquery&#x2F;jquery@3.2.1&#x2F;src&#x2F;core.min.js&#x2F;&#x2F; add &#x2F; at the end to get a directory listinghttps:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jquery&#x2F;jquery&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问这个<code>https://cdn.jsdelivr.net/gh/test/img/</code>路径，可以直接获得目录的列表。</p><p>所以我的url中，<code>/view</code>部分是多余的，我最终要实现的效果是<code>https://img.example.com/hashid/view/xxxx/head.jpg</code>-&gt;<code>https://cdn.jsdelivr.net/gh/test/img/xxxx/head.jpg</code>，通过查阅资料，发现使用显性URL跳转就可以实现这样的操作。</p><h3 id="何为显性转发，何为隐性转发"><a href="#何为显性转发，何为隐性转发" class="headerlink" title="何为显性转发，何为隐性转发"></a>何为显性转发，何为隐性转发</h3><p><strong>隐性转发：</strong>用的是 iframe 框架技术、非重定向技术，效果为浏览器地址栏输入 <code>http://a.com</code> 回车，打开网站内容是目标地址 <code>http://cloud.tencent.com/</code> 的网站内容，但地址栏显示当前地址 <code>http://a.com</code> 。</p><p><strong>显性转发：</strong>用的是301重定向技术，效果为浏览器地址栏输入 <code>http://a.com</code> 回车，打开网站内容是目标地址 <code>http://cloud.tencent.com/</code> 的网站内容，且地址栏显示目标地址 <code>http://cloud.tencent.com/</code>。</p><p>转发可以使用DNS进行解析，但是需要域名备案，也可以使用nginx做重定向，本文使用nginx作重定向。</p><h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><p>由于需要对nginx操作，使用宝塔面板较为简单方便。</p><h3 id="宝塔准备"><a href="#宝塔准备" class="headerlink" title="宝塔准备"></a>宝塔准备</h3><p><code>网站</code>-&gt;<code>添加站点</code>-&gt;<code>输入域名img.example.com:8899</code></p><p>由于我在服务器上部署了多个web页面，就不使用80端口，采用非80端口 Nginx URL重定向。</p><p>下边保持默认，PHP版本选择<code>纯静态</code></p><p>站点添加成功后，选择<code>配置文件</code></p><p>写入下列配置文件</p><pre class="line-numbers language-ini" data-language="ini"><code class="language-ini"> server &#123;        listen       80;        server_name  img.example.com;        location &#x2F; &#123;            fastcgi_pass 127.0.0.1:8899; #此处为端口转发            # 下边两行为两种正则匹配策略            rewrite &#x2F;view&#x2F;(.*)$ https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;test&#x2F;$1 break;            rewrite &#x2F;(.*)$ https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;test&#x2F;$1 permanent;        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的正则匹配我写了两个，因为历史原因，需要规避<code>/view</code>这样的目录链接，所以写了两种。</p><p>rewrite有三个参数：</p><ul><li>&lt;regex&gt;，用于匹配URI的正则表达式</li><li>&lt;replacement&gt;，将regex正则匹配到的内容替换成 replacement</li><li>[flag]，flag标记</li></ul><p>flag标记说明：</p><ul><li>last  //本条规则匹配完成后，继续向下匹配新的location URI规则</li><li>break  //本条规则匹配完成即终止，不再匹配后面的任何规则</li><li>redirect  //返回302临时重定向，浏览器地址会显示跳转后的URL地址</li><li>permanent  //返回301永久重定向，浏览器地址栏会显示跳转后的URL地址</li></ul><p>其中redirect和permanent的区别好像是会影响SEO，具体可以自行查阅相关资料。</p><p>另外，SSL可以不配置，这里仅仅做跳转，真正访问数据还是要请求到jsDelivr的CDN上去。</p><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>DNS解析到服务器，届时，访问自己的域名即可。</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>以后可以直接使用PicGo来进行上传，更加方便。关于PicGo的配置，可以参考PicGo的<a href="https://molunerfinn.com/PicGo/">官方文档</a></p><h3 id="我为什么要使用自己的域名？"><a href="#我为什么要使用自己的域名？" class="headerlink" title="我为什么要使用自己的域名？"></a>我为什么要使用自己的域名？</h3><p>当然是害怕某天jsDelivr不让白嫖啦，到时候自己直接搭一个图床就可以马上图片访问。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://cloud.tencent.com/document/product/302/12649?from=information.detail.%E5%9F%9F%E5%90%8Durl%E8%B7%B3%E8%BD%AC%20%E6%98%BE%E6%80%A7">隐、显性 URL 记录</a></p><p><a href="http://blog.kwin.wang/website/nginx-rewrite-realize-domain-forward.html">利用Nginx rewrite规则实现域名显性转发</a></p><p>正则部分参考链接：</p><p><a href="https://blog.csdn.net/leshami/article/details/78429250">Nginx rewrite正则匹配重写</a></p><p><a href="https://www.jianshu.com/p/3b2345f7347d">第七章：nginx的rewrite规则详解</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jsDelivr </tag>
            
            <tag> 图床 </tag>
            
            <tag> Nginx </tag>
            
            <tag> CDN </tag>
            
            <tag> PicGo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更改Ubuntu的时间为北京时间（东八区）</title>
      <link href="2021/01/23/ubuntu-cst-utc-8/"/>
      <url>2021/01/23/ubuntu-cst-utc-8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一条命令即可。</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo cp &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai  &#x2F;etc&#x2F;localtime<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>reboot</code>之后，用<code>date</code>命令查看当前时间。</p><pre class="line-numbers language-none"><code class="language-none">root@ubuntu20:~$ dateSat Jan 23 11:33:58 PM CST 2021<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h2><blockquote><p><a href="https://developer.aliyun.com/article/359597">https://developer.aliyun.com/article/359597</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> linux </tag>
            
            <tag> date </tag>
            
            <tag> cst </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构代码题汇总</title>
      <link href="2020/11/14/DS-code/"/>
      <url>2020/11/14/DS-code/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构代码"><a href="#数据结构代码" class="headerlink" title="数据结构代码"></a>数据结构代码</h1><h2 id="线性表——顺序表"><a href="#线性表——顺序表" class="headerlink" title="线性表——顺序表"></a>线性表——顺序表</h2><h3 id="逆转顺序表中的所有元素"><a href="#逆转顺序表中的所有元素" class="headerlink" title="逆转顺序表中的所有元素"></a>逆转顺序表中的所有元素</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void Reverse(int A[], int n)&#123;    int i, t;    for(i&#x3D;0;i&lt;n&#x2F;2;i++)&#123;        t &#x3D; A[i];        A[i] &#x3D; A[n-i-1];        A[n-i-1] &#x3D; t;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线性表——链表"><a href="#线性表——链表" class="headerlink" title="线性表——链表"></a>线性表——链表</h2><h3 id="删除线性链表中数据域为item的所有结点"><a href="#删除线性链表中数据域为item的所有结点" class="headerlink" title="删除线性链表中数据域为item的所有结点"></a>删除线性链表中数据域为item的所有结点</h3><blockquote><p>算法思想：从第二个结点开始，从前往后一次判断链表中的结点是否满足要求。</p><p>再回过头来看链表第一个结点是否满足要求。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void PurgeItem(LinkList &amp;L)&#123;    LinkList p, q &#x3D; L;    p &#x3D; L-&gt;next;    while(p!&#x3D;NULL)&#123;        if(p-&gt;data&#x3D;&#x3D;item)&#123;            q-&gt;next &#x3D; p-&gt;next;            free(p);            p &#x3D; q-&gt;next;        &#125;else&#123;            q &#x3D; p;            p &#x3D; q-&gt;next;        &#125;    &#125;    if(L-&gt;data&#x3D;&#x3D;item)&#123;        q &#x3D; L;        L &#x3D; L-&gt;next;        free(q);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="逆转线性链表"><a href="#逆转线性链表" class="headerlink" title="逆转线性链表"></a>逆转线性链表</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void Reverse(LinkList &amp;L)&#123;    LinkList p, q, r;    p &#x3D; L;    q &#x3D; NULL;    while(p!&#x3D;NULL)&#123;        r &#x3D; q;        q &#x3D; p;        p &#x3D; p-&gt;next;        q-&gt;next &#x3D; r;    &#125;    L &#x3D; q;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复制线性链表（递归）"><a href="#复制线性链表（递归）" class="headerlink" title="复制线性链表（递归）"></a>复制线性链表（递归）</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">LinkList Copy(LinkList La)&#123;    LinkList L;    if(La&#x3D;&#x3D;NULL)        return NULL;    else&#123;        L &#x3D; (LinkList)malloc(sizeof(LNode));        L-&gt;data &#x3D; La-&gt;data;        L-&gt;next &#x3D; Copy(La-&gt;next);        return L;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="将两个按值有序排列的非空线性链表合并为一个按值有序的线性链表"><a href="#将两个按值有序排列的非空线性链表合并为一个按值有序的线性链表" class="headerlink" title="将两个按值有序排列的非空线性链表合并为一个按值有序的线性链表"></a>将两个按值有序排列的非空线性链表合并为一个按值有序的线性链表</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">LinkList MergeList(LinkList La, LinkList Lb)&#123;    LinkList Lc, p &#x3D; La, q &#x3D; Lb, r;    &#x2F;&#x2F;Lc 指向 La 和 Lb 所指结点中较小者    if(La-&gt;data &lt;&#x3D; Lb-&gt;data)&#123;        Lc &#x3D; La;        r &#x3D; La;        p &#x3D; La-&gt;next;    &#125;else&#123;        Lc &#x3D; Lb;        r &#x3D; Lb;        q &#x3D; Lb-&gt;next;    &#125;        while(p!&#x3D;NULL &amp;&amp; q!&#x3D;NULL)&#123;        if(p-&gt;data&lt;&#x3D;q-&gt;data)&#123;            r-&gt;next &#x3D; p;            r &#x3D; p;            p &#x3D; p-&gt;next;        &#125;else&#123;            r-&gt;next &#x3D; q;            r &#x3D; q;            q &#x3D; q-&gt;next;        &#125;    &#125;        &#x2F;&#x2F;将剩余结点（即未参加比较的且已按升序排列的结点）链接到整个链表后面r-&gt;next &#x3D; (p !&#x3D; NULL) ? p : q;    return Lc;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><h3 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">typedef struct BiTNode&#123;    int data;    struct BiTNode *lchild, *rchild;&#125;BiTNode, *BiTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉树先序、中序、后序（递归版本）"><a href="#二叉树先序、中序、后序（递归版本）" class="headerlink" title="二叉树先序、中序、后序（递归版本）"></a>二叉树先序、中序、后序（递归版本）</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 先序void PreOrderTraverse(BiTree T) &#123;    if (T &#x3D;&#x3D; NULL)        return;    visit(T);    PreOrderTraverse(T-&gt;lchild);    PreOrderTraverse(T-&gt;rchild);&#125;&#x2F;&#x2F;中序void InOrderTraverse(BiTree T) &#123;    if (T &#x3D;&#x3D; NULL)        return;    InOrderTraverse(T-&gt;lchild);    visit(T);    InOrderTraverse(T-&gt;rchild);&#125;&#x2F;&#x2F;后序void PostOrderTraverse(BiTree T) &#123;    if (T &#x3D;&#x3D; NULL)        return;    PostOrderTraverse(T-&gt;lchild);    PostOrderTraverse(T-&gt;rchild);    visit(T);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉树的先序遍历（非递归算法）"><a href="#二叉树的先序遍历（非递归算法）" class="headerlink" title="二叉树的先序遍历（非递归算法）"></a>二叉树的先序遍历（非递归算法）</h3><blockquote><p>算法思想：若 p 所指结点不为空，则访问该结点，然后将该结点的地址入栈，然后再将 p 指向其左孩 子结点；若 p 所指向的结点为空，则从堆栈中退出栈顶元素（某个结点的地址），将 p 指向其右孩子 结点。重复上述过程，直到 p = NULL 且堆栈为空，遍历结束。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#define MAX_STACK 50void PreOrderTraverse(BTree T)&#123;    BTree STACK[MAX_STACK], p &#x3D; T;    int top &#x3D; -1;    while(p!&#x3D;NULL || top !&#x3D; -1)&#123;        while(P !&#x3D; NULL)&#123;            Visit(p);            STACK[++top] &#x3D; p;            p &#x3D; p-&gt;lchild;        &#125;        p &#x3D; STACK[top--];        p &#x3D; p-&gt;rchild;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉树的中序遍历（非递归算法）"><a href="#二叉树的中序遍历（非递归算法）" class="headerlink" title="二叉树的中序遍历（非递归算法）"></a>二叉树的中序遍历（非递归算法）</h3><blockquote><p>算法思想：若 p 所指结点不为空，则将该结点的地址 p 入栈，然后再将 p 指向其左孩子结点；若 p 所 指向的结点为空，则从堆栈中退出栈顶元素（某个结点的地址）送 p，并访问该结点，然后再将 p 指 向该结点的右孩子结点。重复上述过程，直到 p = NULL 且堆栈为空，遍历结束。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#define MAX_STACK 50void InOrderTraverse(BTree T)&#123;BTree STACK[MAX_STACK], p &#x3D; T;int top &#x3D; -1;    while (p !&#x3D; NULL || top !&#x3D; -1)&#123;while (p !&#x3D; NULL)&#123;STACK[++top] &#x3D; p;p &#x3D; p-&gt;lchild;&#125;p &#x3D; STACK[top--];Visit(p);p &#x3D; p-&gt;rchild;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉树的后序遍历（非递归算法）"><a href="#二叉树的后序遍历（非递归算法）" class="headerlink" title="二叉树的后序遍历（非递归算法）"></a>二叉树的后序遍历（非递归算法）</h3><blockquote><p>算法思想：当 p 指向某一结点时，不能马上对它进行访问，而要先访问它的左子树，因而要将此结点 的地址入栈；当其左子树访问完毕后，再次搜索到该结点时（该结点地址通过退栈得到），还不能对 它进行访问，还需要先访问它的右子树，所以，再一次将该结点的地址入栈。只有当该结点的右子 树访问完毕后回到该结点时，才能访问该结点。为了标明某结点是否可以访问，引入一个标志变量 flag，当 flag = 0 时表示该结点暂不访问，flag = 1 时表示该结点可以访问。flag 的值随同该结点的地 址一起入栈和出栈。因此，算法中设置了两个堆栈，其中 STACK1 存放结点的地址，STACK2 存放 标志变量 flag，两个堆栈使用同一栈顶指针 top，且 top 的初始值为 −1。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#define MAX_STACK 50void PostOrderTraverse(BTree T) &#123;    BTree STACK1[MAX_STACK], p &#x3D; T;    int STACK2[MAX_STACK], flag, top &#x3D; -1;    while (p !&#x3D; NULL || top !&#x3D; -1) &#123;        while (p !&#x3D; NULL) &#123;            STACK1[++top] &#x3D; p;            STACK2[top] &#x3D; 0;            p &#x3D; p-&gt;lchild;        &#125;        p &#x3D; STACK1[top];        flag &#x3D; STACK2[top--];        if (flag &#x3D;&#x3D; 0) &#123;            STACK1[++top] &#x3D; p;            STACK2[top] &#x3D; 1;            p &#x3D; p-&gt;rchild;        &#125; else &#123;            VISIT(p);            p &#x3D; NULL;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉树的按层次遍历"><a href="#二叉树的按层次遍历" class="headerlink" title="二叉树的按层次遍历"></a>二叉树的按层次遍历</h3><blockquote><p>算法思想：设置一个队列，首先将根结点（的地址）入队列，然后依次从队列中退出一个元素，每 退出一个元素，先访问该元素所指的结点，然后依次将该结点的左孩子结点（若存在的话）和右孩 子结点（若存在的话）入队列。如此重复下去，直到队列为空。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#define MAX_QUEUE 50void LayeredOrderTraverse(BTree T) &#123;    BTree QUEUE[MAX_QUEUE], p;    int front, rear;    if (T !&#x3D; NULL) &#123;        QUEUE[0] &#x3D; T;        front &#x3D; -1;        rear &#x3D; 0;        while (front &lt; rear) &#123;            p &#x3D; QUEUE[++front];            VISIT(P);            if (p-&gt;lchild !&#x3D; NULL)                QUEUE[++rear] &#x3D; p-&gt;lchild;            if (p-&gt;rchild !&#x3D; NULL)                QUEUE[++rear] &#x3D; p-&gt;rchild;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="建立二叉树（从键盘输入数据，先序遍历递归算法）"><a href="#建立二叉树（从键盘输入数据，先序遍历递归算法）" class="headerlink" title="建立二叉树（从键盘输入数据，先序遍历递归算法）"></a>建立二叉树（从键盘输入数据，先序遍历递归算法）</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BTree CreateBT() &#123;    char ch;    BTree T;    sacnf(&quot;%c&quot;, &amp;ch);    if (ch &#x3D;&#x3D; &#39; &#39;)        return NULL;    else &#123;        T &#x3D; (BTree) malloc(sizeof(BTNode));        T-&gt;data &#x3D; ch;        T-&gt;lchild &#x3D; CreateBT();        T-&gt;rchild &#x3D; CreateBT();        return T;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="建立二叉树（从数组获取数据）"><a href="#建立二叉树（从数组获取数据）" class="headerlink" title="建立二叉树（从数组获取数据）"></a>建立二叉树（从数组获取数据）</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 递归BTree CreateBT(int A[], int i, int n) &#123;    BTree p;    if (i &gt; n)        return NULL;    else &#123;        p &#x3D; (BTree) malloc(sizeof(BTNode));        p-&gt;data &#x3D; A[i];        p-&gt;lchild &#x3D; CreateBT(A, 2 * i, n);        p-&gt;rchild &#x3D; CreateBT(A, 2 * i + 1, n);        return p;    &#125;&#125;T &#x3D; CreateBT(A, 1, n);&#x2F;&#x2F; 递归（从键盘输入数据）void CreateBiTree(BiTree *T) &#123;    char ch;    scanf(&quot;%c&quot;, &amp;ch);    if (ch &#x3D;&#x3D; &#39;#&#39;) &#123;        *T &#x3D; NULL;    &#125; else &#123;        *T &#x3D; (BiTree) malloc(sizeof(BiTNode));        if (!(*T))            exit(OVERFLOW);        (*T)-&gt;data &#x3D; ch;        CreateBiTree(&amp;(*T)-&gt;lchild);        CreateBiTree(&amp;(*T)-&gt;rchild);    &#125;&#125;&#x2F;*--------------------------------------------------------*&#x2F;&#x2F;&#x2F; 迭代BTree CreateBT(int A[], int n) &#123;    int i;    BTree *pT;    &#x2F;&#x2F; 对应 n 个结点申请可容纳 n 个指针变量的内存空间    pT &#x3D; (BTree *) malloc(sizeof(BTree) * n);    &#x2F;&#x2F; 若数组中的某个元素不等于零，则申请相应的结点空间并进行赋值    for (i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;        if (A[i] !&#x3D; 0) &#123;            pT[i] &#x3D; (BTree) malloc(sizeof(BTNode));            pT[i]-&gt;data &#x3D; A[i];        &#125; else &#123;            pT[i] &#x3D; NULL;        &#125;    &#125;    &#x2F;&#x2F; 修改结点的指针域的内容，使父结点指向左、右孩子结点    for (i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;        if (pT[i] !&#x3D; NULL) &#123;            pT[i]-&gt;lchild &#x3D; pT[2 * i];            pT[i]-&gt;rchild &#x3D; pT[2 * i + 1];        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="求二叉树的深度（递归算法）"><a href="#求二叉树的深度（递归算法）" class="headerlink" title="求二叉树的深度（递归算法）"></a>求二叉树的深度（递归算法）</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int Depth(BTree T) &#123;    int ldepth, rdepth;    if (T &#x3D;&#x3D; NULL)        return 0;    else &#123;        ldepth &#x3D; Depth(T-&gt;lchild);        rdepth &#x3D; Depth(T-&gt;rchild);        if (ldepth &gt; rdepth)            return ldepth + 1;        else            return rdepth + 1;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="求二叉树的深度（非递归算法）"><a href="#求二叉树的深度（非递归算法）" class="headerlink" title="求二叉树的深度（非递归算法）"></a>求二叉树的深度（非递归算法）</h3><blockquote><p>算法思想：对二叉树进行遍历，遍历过程中依次记录各个结点所处的层次数以及当前已经访问过的结点所处的最大层次数。每当访问到某个叶子结点时，将该叶子结点所处的层次数与最大层次数进行比较，若前者大于后者，则修改最大层次数为该叶子结点的层次数，否则不作修改。遍历结束时，所记录的最大层次数即为该二叉树的深度。本算法使用的是非递归的中序遍历算法（其它遍历顺序 也可以）。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#define MAX_STACK 50int Depth(BTree T) &#123;    BTree STACK1[MAX_STACK], p &#x3D; T;    int STACK2[MAX_STACK];    int curdepth, maxdepth &#x3D; 0, top &#x3D; -1;    if (T !&#x3D; NULL) &#123;        curdepth &#x3D; 1;        while (p !&#x3D; NULL || top !&#x3D; -) &#123;            while (p !&#x3D; NULL) &#123;                STACK1[++top] &#x3D; p;                STACK2[top] &#x3D; curdepth;                p &#x3D; p-&gt;lchild;                curdepth++;            &#125;            p &#x3D; STACK1[top];            curdepth &#x3D; STACK2[top--];            if (p-&gt;lchild &#x3D;&#x3D; NULL &amp;&amp; p-&gt;rchild &#x3D;&#x3D; NULL)                if (curdepth &gt; maxdepth)                    maxdepth &#x3D; curdepth;            p &#x3D; p-&gt;rchild;            curdepth++;        &#125;    &#125;    return maxdepth;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="求结点所在层次"><a href="#求结点所在层次" class="headerlink" title="求结点所在层次"></a>求结点所在层次</h3><blockquote><p>算法思想：采用后序遍历的非递归算法对二叉树进行遍历，遍历过程中对每一个结点判断其是否为满足条件的结点，若是满足条件的结点，则此时堆栈中保存的元素个数再加 1 即为该结点所在的层次。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#define MAX_STACK 50int LayerNode(BTree T, int item) &#123;    BTree STACK1[MAX_STACK], p &#x3D; T;    int STACK2[MAX_STACK], flag, top &#x3D; -1;    while (p !&#x3D; NULL || top !&#x3D; -1) &#123;        while (p !&#x3D; NULL) &#123;            STACK1[++top] &#x3D; p;            STACK2[top] &#x3D; 0;            p &#x3D; p-&gt;lchild;        &#125;        p &#x3D; STACK1[top];        flag &#x3D; STACK2[top--];        if (flag &#x3D;&#x3D; 0) &#123;            STACK1[++top] &#x3D; p;            STACK2[top] &#x3D; 1;            p &#x3D; p-&gt;rchild;        &#125; else &#123;            if (p-&gt;data &#x3D;&#x3D; item)                return top + 2;            p &#x3D; NULL;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="交换二叉树中所有结点的左右子树的位置"><a href="#交换二叉树中所有结点的左右子树的位置" class="headerlink" title="交换二叉树中所有结点的左右子树的位置"></a>交换二叉树中所有结点的左右子树的位置</h3><p>算法思想：按层次遍历二叉树，遍历过程中每当访问一个结点时，就将该结点的左右子树的位置对调。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#define MAX_QUEUE 50void ExchangeBT(BTree T) &#123;    BTree QUEUE[MAX_QUEUE], temp, p &#x3D; T;    int front, rear;    if (T !&#x3D; NULL) &#123;        QUEUE[0] &#x3D; T;        front &#x3D; -1;        rear &#x3D; 0;        while (front &lt; rear) &#123;            p &#x3D; QUEUE[++front];            temp &#x3D; p-&gt;lchild;            p-&gt;lchild &#x3D; p-&gt;rchild;            p-&gt;rchild &#x3D; temp;            if (p-&gt;lchild !&#x3D; NULL)                QUEUE[++rear] &#x3D; p-&gt;lchild;            if (p-&gt;rchild !&#x3D; NULL)                QUEUE[++rear] &#x3D; p-&gt;rchild;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除二叉树中以某个结点为根结点的子树</p><p>算法思想：先序遍历找到符合条件的结点（其它遍历方法亦可），然后删除以该结点为根结点的子树。 最后把该结点的父结点的相应的指针域置为 NULL。为此，需在算法中设置一个指针变量用以指示当 前结点的父结点。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#define MAX_STACK 50BTree DeleteSubtree(BTree &amp;T, int item) &#123;    BTree STACK[MAX_STACK], q, p &#x3D; T;    int top &#x3D; -1;    if (T-&gt;data &#x3D;&#x3D; item) &#123;        DestroyBT(T);        T &#x3D; NULL;        return NULL;    &#125; else &#123;        while (p !&#x3D; NULL || top !&#x3D; -1) &#123;            while (p !&#x3D; NULL) &#123;                if (p-&gt;data &#x3D;&#x3D; item) &#123;                    if (q-&gt;lchild &#x3D;&#x3D; p)                        q-&gt;lchild &#x3D; NULL;                    else                        q-&gt;rchild &#x3D; NULL;                    DestroyBT(p);                    return T;                &#125;                STACK[++top] &#x3D; p;                q &#x3D; p;                p &#x3D; p-&gt;lchild;            &#125;            q &#x3D; STACK[top--];            p &#x3D; q-&gt;rchild;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>顺序查找的递归算法</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int RecurSeqSearch(int A[], int n, int key, int i) &#123;    if (i &gt;&#x3D; n)        return -1;    if (A[i] &#x3D;&#x3D; key)        return i;    else        return RecurSeqSearch(A, n, key, i + 1);&#125;void solve() &#123;    pos &#x3D; RecurSeqSearch(A, n, key, 0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int BinSearch(int A[], int n, int key) &#123;    int low &#x3D; 0, high &#x3D; n - 1, mid;    while (low &lt;&#x3D; high) &#123;        mid &#x3D; (low + high) &#x2F; 2;        if (key &#x3D;&#x3D; A[mid])            return mid;        if (key &gt; A[mid])            low &#x3D; mid + 1;        else            high &#x3D; mid – 1;    &#125;    return -1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="折半查找的递归算法"><a href="#折半查找的递归算法" class="headerlink" title="折半查找的递归算法"></a>折半查找的递归算法</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int RecurBinSearch(int A[], int low, int high, int key) &#123;    int mid;    if (low &gt; high)        return -1;    else &#123;        mid &#x3D; (low + high) &#x2F; 2;        if (key &#x3D;&#x3D; A[mid])            return mid;        if (key &gt; A[mid])            return RecurBinSearch(A, mid + 1, high, key);        else            return RecurBinSearch(A, low, mid - 1, key);    &#125;&#125;void solve() &#123;    pos &#x3D; RecurBinSearch(A, 0, n - 1, key);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在按值递增排列且长度为-n-的线性表中折半查找并插入一元素"><a href="#在按值递增排列且长度为-n-的线性表中折半查找并插入一元素" class="headerlink" title="在按值递增排列且长度为 n 的线性表中折半查找并插入一元素"></a>在按值递增排列且长度为 n 的线性表中折半查找并插入一元素</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void BinInsert(int A[], int &amp;n, int key) &#123;    int j, low &#x3D; 0, high &#x3D; n - 1, mid;    while (low &lt;&#x3D; high) &#123;        mid &#x3D; (low + high) &#x2F; 2;        if (key &gt; A[mid])            low &#x3D; mid + 1;        else            high &#x3D; mid – 1;    &#125;    for (j &#x3D; n; j &gt; low; j--)        A[j] &#x3D; A[j - 1];    A[low] &#x3D; key;    n++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在按值递增排列且长度为-n-的线性表中折半查找值不小于-key-的最小元素"><a href="#在按值递增排列且长度为-n-的线性表中折半查找值不小于-key-的最小元素" class="headerlink" title="在按值递增排列且长度为 n 的线性表中折半查找值不小于 key 的最小元素"></a>在按值递增排列且长度为 n 的线性表中折半查找值不小于 key 的最小元素</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void BinSearch(int A[], int n, int key) &#123;    int low &#x3D; 0, high &#x3D; n - 1, mid;    while (low &lt;&#x3D; high) &#123;        mid &#x3D; (low + high) &#x2F; 2;        if (key &#x3D;&#x3D; A[mid])            return mid;        if (key &gt; A[mid])            low &#x3D; mid + 1;        else            high &#x3D; mid – 1;    &#125;    if (low &lt;&#x3D; n - 1)        return low;    else        return -1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><blockquote><p>算法思想：第 i 趟插入排序为：在含有 i − 1 个元素的有序子序列中插入一个元素，使之成为含有 i 个元素的有序子序列。在查找插入位置的过程中，可以同时后移元素。整个过程为进行 n − 1 趟插入， 即先将整个序列的第 1 个元素看成是有序的，然后从第 2 个元素起逐个进行插入，直到整个序列有序 为止。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void InsertSort(int A[], int n) &#123;    int i, j, temp;    for (i &#x3D; 1; i &lt;&#x3D; n - 1; i++) &#123;        if (A[i] &lt; A[i - 1]) &#123;            j &#x3D; i - 1;            temp &#x3D; A[i];            while (j &gt;&#x3D; 0 &amp;&amp; temp &lt; A[j]) &#123;                A[j + 1] &#x3D; A[j];                j--;            &#125;            A[j + 1] &#x3D; temp;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><blockquote><p>算法思想：算法同直接插入排序，只不过使用折半查找的方法来寻找插入位置。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void BinInsertSort(int A[], int n) &#123;    int i, j, low, high, mid, temp;    for (i &#x3D; 1; i &lt;&#x3D; n - 1; i++) &#123;        temp &#x3D; A[i];        low &#x3D; 0;        high &#x3D; i – 1;        while (low &lt;&#x3D; high) &#123;            mid &#x3D; (low + high) &#x2F; 2;            if (temp &gt; A[mid])                low &#x3D; mid + 1;            else                high &#x3D; mid – 1;        &#125;        for (j &#x3D; i; j &gt; low; j--)            A[j] &#x3D; A[j - 1];        A[low] &#x3D; temp;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><blockquote><p>算法思想：首先将第 1 个元素和第 2 个元素进行比较，若前者大于后者，则两者交换位置，然后比较 第 2 个元素和第 3 个元素。依此类推，直到第 n − 1 个元素和第 n 个元素进行过比较或交换为止。上 述过程称为一趟冒泡排序，其结果是使得 n 个元素中值最大的那个元素被安排在最后一个元素的位置 上。然后进行第二趟排序，即对前 n − 1 个元素进行同样的操作，使得前 n − 1 个元素中值最大的那 个元素被安排在第 n − 1 个位置上。一般地，第 i 趟冒泡排序是从前 n − i + 1 个元素中的第 1 个元素 开始，两两比较，若前者大于后者，则交换，结果使得前 n − i + 1 个元素中最大的元素被安排在第 n − i + 1 个位置上。显然，判断冒泡排序结束的条件是“在一趟排序中没有进行过交换元素的操作”， 为此，设立一个标志变量 flag，flag = 1 表示有过交换元素的操作，flag = 0 表示没有过交换元素的操 作，在每一趟排序开始前，将 flag 置为 0，在排序过程中，只要有交换元素的操作，就及时将 flag 置 为 1。因为至少要执行一趟排序操作，故第一趟排序时，flag = 1。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void BubbleSort(int A[], int n) &#123;    int i, j, temp, flag &#x3D; 1;    for (i &#x3D; n - 1; i &gt;&#x3D; 1 &amp;&amp; flag &#x3D;&#x3D; 1; i--) &#123;        flag &#x3D; 0;        for (j &#x3D; 0; j &lt; i; j++) &#123;            if (A[j] &gt; A[j + 1]) &#123;                temp &#x3D; A[j];                A[j] &#x3D; A[j + 1];                A[j + 1] &#x3D; temp;                flag &#x3D; 1;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><blockquote><p>算法思想：第 i 趟排序从序列的后 n − i + 1（i = 1, 2, …, n − 1）个元素中选择一个值最小的元素与该 个元素的第 1 个元素交换位置，即与整个序列的第 i 个元素交换。依此类推，直到 i = n − 1 为止。也 就是说，每一趟排序从从未排好序的那些元素中选择一个值最小的元素，然后将其与这些未排好序 的元素中的第 1 个元素交换位置。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void SelectSort(int A[], int n) &#123;    int i, j, min, temp;    for (i &#x3D; 0; i &lt; n; i++) &#123;        min &#x3D; i;        for (j &#x3D; i + 1; j &lt; n; j++) &#123;            if (A[min] &gt; A[j])                min &#x3D; j;        &#125;        if (min !&#x3D; i) &#123;            temp &#x3D; A[min];            A[min] &#x3D; A[i];            A[i] &#x3D; temp;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><blockquote><p>算法思想：在参加排序的序列中任意选择一个元素（通常称为分界元素或基准元素），把小于或等于 分界元素的所有元素都移到分界元素的前面，把大于分界元素的所有元素都移到分界元素的后面， 这样，当前参加排序的序列就被划分成前后两个子序列，其中前一个子序列中的所有元素都小于后 一个子序列的所有元素，并且分界元素正好处于排序的最终位置上。然后分别对这两个子序列递归 地进行上述排序过程，直到所有元素都处于排序的最终位置上，排序结束。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void QuickSort(int A[], int n) &#123;    QSort(A, 0, n - 1);&#125;void QSort(int A[], int low, int high) &#123;    int pivotloc;    if (low &lt; high) &#123;        pivot &#x3D; Partition(A, low, high);        QSort(A, low, pivotloc - 1);        QSort(A, pivotloc + 1, high);    &#125;&#125;int Partition(int A[], int low, int high) &#123;    int pivot;    pivot &#x3D; A[low];    &#x2F;&#x2F; 从线性表的两端交替地向中间扫描    while (low &lt; high) &#123;        while (low &lt; high &amp;&amp; A[high] &gt;&#x3D; pivot)            high--;        A[low] &#x3D; A[high];        while (low &lt; high &amp;&amp; A[low] &lt;&#x3D; pivot)            low++;        A[high] &#x3D; A[low];    &#125;    A[low] &#x3D; pivot;    return low;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void HeapSort(int A[], int n) &#123;    int i, temp;    &#x2F;&#x2F; 建立大顶堆    for (i &#x3D; n &#x2F; 2; i &gt;&#x3D; 1; i--)        HeapAdjust(A, i, n);    for (i &#x3D; n - 1; i &gt;&#x3D; 1; i--) &#123;        temp &#x3D; A[1];        A[1] &#x3D; A[i + 1];        A[i + 1] &#x3D; temp;        &#x2F;&#x2F; 将 A[1..i] 重新调整为大顶堆        HeapAdjust(A, 1, i);    &#125;&#125;void HeapAdjust(int A[], int low, int high) &#123;    int i, temp;    temp &#x3D; A[low];    for (i &#x3D; 2 * low; i &lt;&#x3D; high; i &#x3D; i * 2) &#123;        &#x2F;&#x2F; 令 i 为关键字较大的记录的下标        if (i &lt; high &amp;&amp; A[i] &lt; A[i + 1])            i++;        if (temp &gt;&#x3D; A[i])            break;        else &#123;            A[low] &#x3D; A[i];            low &#x3D; i;        &#125;    &#125;    A[low] &#x3D; temp;&#x2F;&#x2F; 插入&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cmd/Git/Git bash/Linux命令行使用代理</title>
      <link href="2020/08/26/cmd-Git-bash-proxy/"/>
      <url>2020/08/26/cmd-Git-bash-proxy/</url>
      
        <content type="html"><![CDATA[<p>V2ray下命令行使用代理</p><h2 id="验证方式"><a href="#验证方式" class="headerlink" title="验证方式"></a>验证方式</h2><h3 id="ping可以验证吗"><a href="#ping可以验证吗" class="headerlink" title="ping可以验证吗"></a>ping可以验证吗</h3><p>ping的协议不是https，也不是https，是ICMP协议，所以，不能单纯用ping通来判断可以进行http访问。</p><h3 id="curl验证"><a href="#curl验证" class="headerlink" title="curl验证"></a>curl验证</h3><p><code>curl -vv http://www.google.com</code>，用这条命令来验证，如果返回如下结果表示代理设置成功。</p><blockquote><p>powershell下好像无法使用这个命令，可以直接尝试<code>curl www.google.com</code></p></blockquote><p><img src="https://img.zhuomu.xyz/view/img/2020/08/26/DPTRzWWg/image-20200826185355205.png" alt="image-20200826185355205"></p><h2 id="各类终端具体设置方法"><a href="#各类终端具体设置方法" class="headerlink" title="各类终端具体设置方法"></a>各类终端具体设置方法</h2><p>具体是<code>socks</code>还是<code>http</code>要看你的代理客户端</p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># httpgit config --global http.proxy &#39;http:&#x2F;&#x2F;127.0.0.1:10808&#39;git config --global https.proxy &#39;http:&#x2F;&#x2F;127.0.0.1:10808&#39;#socksgit config --global http.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:10808&#39;git config --global https.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:10808&#39;#取消设置git config --global --unset http.proxygit config --global --unset https.proxy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># httpset http_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:10808set https_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:10808#socksset http_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:10808set https_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:10808# 恢复set http_proxy&#x3D;set https_proxy&#x3D;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Linux-Terminal或Git-bash"><a href="#Linux-Terminal或Git-bash" class="headerlink" title="Linux Terminal或Git bash"></a>Linux Terminal或Git bash</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#Linux下命令为export# httpexport http_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:10808export https_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:10808#socksexport http_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:10808export https_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:10808# 恢复export http_proxy&#x3D;export https_proxy&#x3D;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h3><p>我在Windows上使用的一个客户端，这个好像不需要设置。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"># 验证curl google.com# 显示200的话，基本上是可的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>并不推荐这个时候使用powershell，其他情况下powershell表现还是很不错的。</p></blockquote><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>修改 <code>~/.ssh/config</code> 文件（不存在则新建）：</p><pre class="line-numbers language-none"><code class="language-none"># 必须是 github.comHost github.com   HostName github.com   User git   # 走 HTTP 代理   # ProxyCommand socat - PROXY:127.0.0.1:%h:%p,proxyport&#x3D;8080   # 走 socks5 代理（如 Shadowsocks）   # ProxyCommand nc -v -x 127.0.0.1:1080 %h %p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于Windows用户，要使用socks5代理却没有 nc 的，可以将<br><code>ProxyCommand nc -v -x 127.0.0.1:1080 %h %p</code><br>换成<br><code>ProxyCommand connect -S 127.0.0.1:1080 %h %p</code></p><p>参考链接：</p><blockquote><p><a href="https://gist.github.com/chuyik/02d0d37a49edc162546441092efae6a1">macOS 给 Git(Github) 设置代理（HTTP/SSH）</a></p><p><a href="https://zcdll.github.io/2018/01/27/proxy-on-windows-terminal/">给 Windows 的终端配置代理</a></p><p><a href="http://nstool.netease.com/">网易DNS检测工具</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Git </tag>
            
            <tag> cmd </tag>
            
            <tag> bash </tag>
            
            <tag> 代理 </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows黑屏蓝屏白屏查错方法</title>
      <link href="2020/08/09/Windows-black-blue-screen/"/>
      <url>2020/08/09/Windows-black-blue-screen/</url>
      
        <content type="html"><![CDATA[<p><a href="https://support.microsoft.com/zh-cn/help/14106/windows-10-troubleshoot-black-screen-or-blank-screen-errors">黑屏或空白屏幕错误疑难解答</a></p><p><a href="https://support.microsoft.com/zh-cn/help/14238/windows-10-troubleshoot-blue-screen-errors">蓝屏错误疑难解答</a></p><p><a href="https://support.microsoft.com/zh-cn/help/929135/how-to-perform-a-clean-boot-in-windows">如何在 Windows 中执行干净启动</a></p><p><a href="http://iknow.lenovo.com.cn/detail/dc_032103.html">Windows蓝屏分析工具BlueScreenView使用方法介绍</a></p><p><a href="https://answers.microsoft.com/zh-hans">终极解决办法，去Microsoft Community提问</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> 蓝屏 </tag>
            
            <tag> 黑屏 </tag>
            
            <tag> 白屏 </tag>
            
            <tag> BlueScreenView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次博客大锅</title>
      <link href="2020/07/23/a-big-error/"/>
      <url>2020/07/23/a-big-error/</url>
      
        <content type="html"><![CDATA[<h2 id="事故原因："><a href="#事故原因：" class="headerlink" title="事故原因："></a>事故原因：</h2><ul><li>修改数据库中不确定的数据之前没对数据库进行备份。</li><li>修改后也没有进行备份。</li><li>又蜜汁自信升级了Handsome的7.0版本，又是没备份。</li><li>升级后发现好像有bug，打算回滚，但是想到我忘记备份配置文件了，于是配置文件丢失。</li><li>该数据库的时候登错数据库，锅++</li></ul><p>为了恢复数据，开始了一波的学习。</p><p>经过一番抢救，终于复活了。</p><p>!&gt; 不要忘记，sql命令要加分号！</p><h2 id="具体过程如下："><a href="#具体过程如下：" class="headerlink" title="具体过程如下："></a>具体过程如下：</h2><h3 id="找到出错位置"><a href="#找到出错位置" class="headerlink" title="找到出错位置"></a>找到出错位置</h3><p>登入数据库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ mysql -u root -p databaseA<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看一下bin log是否打开</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql &gt; SHOW VARIABLES LIKE &#39;log_bin&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示如下结果，就可以开始操作了。</p><pre class="line-numbers language-none"><code class="language-none">+---------------+-------+| Variable_name | Value |+---------------+-------+| log_bin       | ON    |+---------------+-------+1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看日志列表</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql &gt; show master logs;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示如下信息，不同的人可能显示的结果不一样，我们找最大的那个<code>mysql-bin.000008</code>。</p><pre class="line-numbers language-none"><code class="language-none">+------------------+-----------+| Log_name         | File_size |+------------------+-----------+| mysql-bin.000007 |   7680053 || mysql-bin.000008 |  11156528 |+------------------+-----------+2 rows in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来使用mysqlbinlog</p><p>如果可以正常使用mysqlbinlog命令请忽略这部分。</p><p>需要确定mysqlbinlog的位置，使用find命令查找</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ find &#x2F; -name mysqlbinlog -print<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>找到如下路径</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;usr&#x2F;bin&#x2F;mysqlbinlog&#x2F;yoursql&#x2F;mysql&#x2F;bin&#x2F;mysqlbinlog<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>根据自己的情况确定你的位置。然后软链接</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ ln -fs &#x2F;www&#x2F;server&#x2F;mysql&#x2F;bin&#x2F;mysqlbinlog &#x2F;usr&#x2F;bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来就可以使用mysqlbinlog命令了。</p><p>由于我们并不清楚出错的时间范围，只能输入一个大致的起始时间，如果确定的话，可以在<code>start-datetime</code>后边跟上相同参数的<code>stop-datetime</code>。跟上<code>result-file</code>导出文件便于我们分析错误位置。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ mysqlbinlog --start-datetime&#x3D;&#39;2020-07-09 19:00:00&#39; &#x2F;www&#x2F;server&#x2F;data&#x2F;mysql-bin.000008 --result-file&#x3D;extra.sql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在一波分析后，发现最后一次（这个根据自身情况，不一定是最后一次）配置正确的position 39876作为stop，然后再向前找比较早的的一个position 2000作为start。</p><p>比如我找到我的position分别是start 2000 stop39876</p><p>执行下列命令，重新执行这部分sql操作，使数据库恢复。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ mysqlbinlog --start-position&#x3D;&quot;2000&quot; --stop-position&#x3D;&quot;39876&quot; mysql-bin.000008 &gt; &#x2F;yourpath&#x2F;backup.sql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="开始恢复"><a href="#开始恢复" class="headerlink" title="开始恢复"></a>开始恢复</h2><p>进入数据库databaseA，将这部分sql导入进去</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ mysql -u root -p databaseA<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用source命令（也有其他命令，可以自行搜索）</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql &gt; source &#x2F;yourpath&#x2F;backup.sql;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后等待执行就可以了。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote><p><a href="https://learnku.com/articles/20702">https://learnku.com/articles/20702</a></p><p><a href="https://www.cnblogs.com/fengzhongzhuzu/p/8973822.html">https://www.cnblogs.com/fengzhongzhuzu/p/8973822.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自定义RSSHub订阅学校官网，一劳永逸</title>
      <link href="2020/07/22/RSSHub-with-university/"/>
      <url>2020/07/22/RSSHub-with-university/</url>
      
        <content type="html"><![CDATA[<p>疫情初期，阿里云赠送在校大学生免费使用一年2G2H云服务器，想着不能浪费了，能不能在上边搭一些服务玩一玩。自己对信息的获取也是比较重视的，很早就在用RSS，这种订阅方式很高效，订阅自己关注的几个博客就可以，与之对应的是，微博、微信、知乎这些地方的信息量太大了，看一会很容易造成递归，然后，我的时间就被偷走了！</p><p>最初的构想是搭建一个RSS服务器，然后用feed43自定义功能，制作几个feed链接，但是feed43的爬取速度太慢了，要很长时间才能更新，不利于信息的及时获取，就继续寻找，找到了一个开源项目，也就是今天的主角RSSHub。</p><p>@&gt; 万物皆可 RSS</p><p>@&gt; RSSHub 是一个开源、简单易用、易于扩展的 RSS 生成器，可以给任何奇奇怪怪的内容生成 RSS 订阅源。RSSHub 借助于开源社区的力量快速发展中，目前已适配数百家网站的上千项内容。</p><p>敢打出“万物皆可RSS”的口号，说明还是很有实力的，实际体验下来也确实，路由众多，开源，用户可以随意扩展。</p><p>回到最本源，目的很单纯，找寻一个可靠的方式，订阅学校官网信息，这样就不用在需要自己去官网看消息了，有什么消息RSS会自动通知我，根据兴趣确定是否要进去官网看，省时省力！</p><p>（时间：2020年4月）看了一眼官网的<a href="https://docs.rsshub.app/joinus/">文档</a>，这好像什么都写了，也好像什么也没写，对于没有前端基础的我来说，这些都是问题！于是，放弃！</p><p>时间回到现在，这次发现了TG可以订阅RSS，又有了重启RSSHub的想法，于是又开始硬着头皮看文档，有一说一，文档写的非常“垃圾”（bushi。我没有一点前端基础，这玩意根本看不懂啊，去网上找博客，竟然没找到，也可能是我的搜索姿势有问题。</p><h2 id="什么是PR啊？"><a href="#什么是PR啊？" class="headerlink" title="什么是PR啊？"></a>什么是PR啊？</h2><p>看了其他人的pr，好像有了些门路，好像只需要修改一下仓库的js文件就好了！真的吗？真的这么简单吗？</p><p>那么问题来了，天天听人家说pr，我还从来没提交过pr呢。</p><p>不管了，这仓库我并没有操作权限，先fork一波，clone到本地再说！</p><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>奇妙的事情发生了，按照文档操作，<code>npm install</code>一波依赖后，进入<code>http://localhost:1200</code>，已经出现了一些东西了，这条路应该没错。</p><p>安装依赖的时候，由于网络原因和一些看不懂的原因，出现了一些报错，这也为之后埋下了坑。</p><h2 id="写-chao-路由和脚本"><a href="#写-chao-路由和脚本" class="headerlink" title="写(chao)路由和脚本"></a>写(chao)路由和脚本</h2><p>尝试原封不动偷（不对，读书人的事情，怎么能是偷呢，这是学习！）其他学校的路由、脚本，改成自己学校的路径，对应页面，哇，真的可以啊！</p><p>真的是so easy呢！</p><p>马上看代码，想着怎么怎么修改一下，这不就完了吗！</p><p>（草，一种植物）高兴得太早了，触及到我的知识盲区了，我没学过爬虫，也不会js，这可咋整，咱啥也不会，copy还是有一手的，然后找了几十家学校，最终敲定了zju的代码。</p><p>经过机智的我努力的修改，很快就搞定了！（屁，你明明对着代码改了有大几个小时！）</p><p>改这个很简单的，只需要这样那样然后再这样就好了！（人言否？</p><p>实际上，我对着人家的官网的HTML代码和我们学校官网的HTML代码看了半天，终于发现这个<code>.lists tr</code>好像有点东西，他们都是class=”xxx”格式的，搜一下，看看我这有没有，果然，牛逼啊！然后又改了几个地方，算是改出来了。这部分一句两句是说不清楚的，因为我没有这个基础，所以只能一边搜，一边比对代码，虽然花了大量时间，结果还好。</p><h3 id="campus-index-js"><a href="#campus-index-js" class="headerlink" title="campus/index.js"></a>campus/index.js</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> got <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@/utils/got'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> cheerio <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'cheerio'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> title<span class="token operator">:</span> <span class="token string">'公告信息'</span><span class="token punctuation">,</span> link<span class="token operator">:</span> <span class="token string">'http://info.zzuli.edu.cn/_t961/2464/list.htm'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> title<span class="token operator">:</span> <span class="token string">'学工信息'</span><span class="token punctuation">,</span> link<span class="token operator">:</span> <span class="token string">'http://info.zzuli.edu.cn/_t961/xsxx/list.htm'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> title<span class="token operator">:</span> <span class="token string">'教学信息'</span><span class="token punctuation">,</span> link<span class="token operator">:</span> <span class="token string">'http://info.zzuli.edu.cn/_t961/jwxx/list.htm'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> title<span class="token operator">:</span> <span class="token string">'信息快递'</span><span class="token punctuation">,</span> link<span class="token operator">:</span> <span class="token string">'http://info.zzuli.edu.cn/_t961/2536/list.htm'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> title<span class="token operator">:</span> <span class="token string">'学术报告'</span><span class="token punctuation">,</span> link<span class="token operator">:</span> <span class="token string">'http://info.zzuli.edu.cn/_t961/xsbg/list.htm'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> title<span class="token operator">:</span> <span class="token string">'科研信息'</span><span class="token punctuation">,</span> link<span class="token operator">:</span> <span class="token string">'http://info.zzuli.edu.cn/_t961/kyxx/list.htm'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> title<span class="token operator">:</span> <span class="token string">'网络公告'</span><span class="token punctuation">,</span> link<span class="token operator">:</span> <span class="token string">'http://info.zzuli.edu.cn/_s19/_t960/wlgg/list.psp'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> title<span class="token operator">:</span> <span class="token string">'班车查询'</span><span class="token punctuation">,</span> link<span class="token operator">:</span> <span class="token string">'http://info.zzuli.edu.cn/_s19/_t960/2619/list.htm'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> title<span class="token operator">:</span> <span class="token string">'周会表'</span><span class="token punctuation">,</span> link<span class="token operator">:</span> <span class="token string">'http://info.zzuli.edu.cn/_s19/_t960/bzhy/list.psp'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">ctx</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> type <span class="token operator">=</span> Number<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>params<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> id <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">.</span>link<span class="token punctuation">;</span>    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">got</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>        method<span class="token operator">:</span> <span class="token string">'get'</span><span class="token punctuation">,</span>        url<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>id<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>        responseType<span class="token operator">:</span> <span class="token string">'buffer'</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> $ <span class="token operator">=</span> cheerio<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.lists tr'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> items <span class="token operator">=</span>        list <span class="token operator">&amp;&amp;</span>        list            <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">index<span class="token punctuation">,</span> item</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>                item <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>                    title<span class="token operator">:</span> item<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">'td a'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'title'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    link<span class="token operator">:</span> item<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">'td a'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'href'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    pubDate<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">'td div'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span>state<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        title<span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">.</span>title<span class="token operator">+</span><span class="token string">' - 郑州轻工业大学智慧门户'</span><span class="token punctuation">,</span>        link<span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">.</span>link<span class="token punctuation">,</span>        item<span class="token operator">:</span> items<span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着又搞了一个研究生处的RSS。</p><p>这个和前边的很不一样，看到这研究生处官网的HTML代码，我开始怀疑这个人的能力了！怎么和前边不一样啊，class让你吃了吗？别人官网都有class这个的，你没有我怎么玩啊？</p><p>那好吧，我又开始了我的传统艺能，看看人家是怎么写的吧，通过学习，好像也发现了点东西。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'div table tbody tr td table tbody tr'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这句话看样子是把这个HTML的结构给表示出来了，于是对着修改成了现在的样子。</p><p>运行后，卧槽！牛逼啊！不愧是我！</p><p>至此，研究生处的RSS也就出生了。（当然，也咨询了爬虫大佬栋哥<a href="https://github.com/kiedeng">@kiedeng</a>，栋哥说用正则搞一下，凭借着正则的思想，我才发现了这段灵魂代码，感谢栋哥。）</p><h3 id="zzuli-yjsc-index-js"><a href="#zzuli-yjsc-index-js" class="headerlink" title="zzuli/yjsc/index.js"></a>zzuli/yjsc/index.js</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> got <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@/utils/got'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> cheerio <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'cheerio'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> title<span class="token operator">:</span> <span class="token string">'公告通知'</span><span class="token punctuation">,</span> link<span class="token operator">:</span> <span class="token string">'http://yjsc.zzuli.edu.cn/ggtz/list.htm'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> title<span class="token operator">:</span> <span class="token string">'招生工作'</span><span class="token punctuation">,</span> link<span class="token operator">:</span> <span class="token string">'http://yjsc.zzuli.edu.cn/2878/list.htm'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> title<span class="token operator">:</span> <span class="token string">'新闻资讯'</span><span class="token punctuation">,</span> link<span class="token operator">:</span> <span class="token string">'http://yjsc.zzuli.edu.cn/2918/list.htm'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> title<span class="token operator">:</span> <span class="token string">'培养工作'</span><span class="token punctuation">,</span> link<span class="token operator">:</span> <span class="token string">'http://yjsc.zzuli.edu.cn/2882/list.htm'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> title<span class="token operator">:</span> <span class="token string">'学位工作'</span><span class="token punctuation">,</span> link<span class="token operator">:</span> <span class="token string">'http://yjsc.zzuli.edu.cn/2890/list.htm'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">ctx</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> type <span class="token operator">=</span> Number<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>params<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> id <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">.</span>link<span class="token punctuation">;</span>    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">got</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>        method<span class="token operator">:</span> <span class="token string">'get'</span><span class="token punctuation">,</span>        url<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>id<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>        responseType<span class="token operator">:</span> <span class="token string">'buffer'</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> $ <span class="token operator">=</span> cheerio<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'div table tbody tr td table tbody tr'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> items <span class="token operator">=</span>        list <span class="token operator">&amp;&amp;</span>        list            <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">index<span class="token punctuation">,</span> item</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>                item <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>                    title<span class="token operator">:</span> item<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">'td a'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'title'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    link<span class="token operator">:</span> item<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">'td a'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'href'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    pubDate<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">'td div'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span>state<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        title<span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">.</span>title<span class="token operator">+</span><span class="token string">' - 郑州轻工业大学研究生处'</span><span class="token punctuation">,</span>        link<span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">.</span>link<span class="token punctuation">,</span>        item<span class="token operator">:</span> items<span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="添加脚本文档"><a href="#添加脚本文档" class="headerlink" title="添加脚本文档"></a>添加脚本文档</h2><p>这部分说白了就是在文档中显示这个rss，帮助其他人使用，按照教程的操作，<code>npm run docs:dev</code>，好了，我运行了，但是，他报错了！这也是之前安装依赖的时候出现的错误没有注意，还好没影响我调试脚本。搞了半天，也检查了网络问题，用了淘宝源，能用的方法都用了，还是安装不成功。我投降！</p><p>好在这部分只需要按照格式写一下markdown就可以了。</p><h2 id="所以，pr到底是啥？"><a href="#所以，pr到底是啥？" class="headerlink" title="所以，pr到底是啥？"></a>所以，pr到底是啥？</h2><p>pull request，简称PR。</p><p>确认我只在本地修改了4个文件（增加了两个，修改了两个）后，运行命令git add命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git add .\lib\routes\universities\zzuli\campus\index.js .\lib\routes\universities\zzuli\yjsc\index.js .\lib\router.js .\docs\university.md<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后git status一波看结果。</p><pre class="line-numbers language-none"><code class="language-none">PS F:\DESK\rsshub\RSSHub&gt; git statusOn branch masterYour branch is up to date with &#39;origin&#x2F;master&#39;.Changes to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)        modified:   docs&#x2F;university.md        modified:   lib&#x2F;router.js        new file:   lib&#x2F;routes&#x2F;universities&#x2F;zzuli&#x2F;campus&#x2F;index.js        new file:   lib&#x2F;routes&#x2F;universities&#x2F;zzuli&#x2F;yjsc&#x2F;index.jsChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)        modified:   package.jsonUntracked files:        lib&#x2F;routes&#x2F;universities&#x2F;zzuli&#x2F;ggtz.js<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我好想还有些残局没有收拾，忘记删除最开始的调试脚本，ggtz.js，还有一个文件进行了修改，并没有add它。</p><ul><li>删除ggtz.js <code>del ggtz.js</code>当然，linux是<code>rm -rf ggtz.js</code></li><li>撤销我的修改，<code>git checkout .\package.json</code></li></ul><p>开始commit</p><pre class="line-numbers language-none"><code class="language-none">git commit -m &quot;Add 郑州轻工业大学&quot; -m &quot;包括郑州轻工业大学 智慧门户：公告信息、学工信息、教学信息、信息快递、学术报告、科研信息、网络公告、班车查询、周会表；研究生处：公告通知、招生工作、新闻资讯、培养工作、学位工作&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里说明一下，因为我想在pr中呈现出commit和description，我担心我只提供commit的话，对于其他人查看可能并不是很友好，于是搜了一下，第一个-m参数是commit，第二个-m参数是description部分。（事实证明，这好像没啥用，这个只是在本地的自己fork的仓库中呈现，pr的时候是有专门写描述的地方的。</p><p>最后就是git push了，第一次好像没有push成功，根据提示又pull，push了几次，算是成功了。</p><p>接下来就是终极问题，如何提交我的pr，在仓库中确确实实见到了我的commit，但是我怎样提交给原仓库呢？又是一波学习。</p><p>在自己仓库中点击<code>Pull request</code>，然后第一个选<code>原站</code>仓库，第二个选<code>自己</code>的仓库，点击下边的<code>Create pull request</code>，按照指示填一下信息，就可以了。</p><p>接下来就等自动bot测试pr等结果就好了，很顺利，一次通过。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/07/22/XpN3wA5y/image-20200722194015891.png" alt="image-20200722194015891"></p><p>由于还没来得及更新doc，先使用人家提供的临时的preview。</p><p>使用的bot如图所示，很成功。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/07/22/XpN3wA5y/image-20200722194257122.png" alt="image-20200722194257122"></p><p>在我快写好这篇博客的时候，两篇推送发来了，开心！</p><p><img src="https://img.zhuomu.xyz/view/img/2020/07/22/XpN3wA5y/image-20200722194417714.png" alt="image-20200722194417714"></p><p>另外，如果有iOS设备，就不需要全天挂梯子了，因为众所周知的原因，所有通知都是先发到Apple服务器，然后再发给手机的，所以就不需要科学上网，也能及时收到通知，这里给苹果点赞！安卓啥时候能这样啊！</p>]]></content>
      
      
      <categories>
          
          <category> 技术博文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> rss </tag>
            
            <tag> RSSHub </tag>
            
            <tag> js </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 MFC 计算机图形学 实验1（Visual C++图形程序设计 ）</title>
      <link href="2020/06/13/MFC-GC-lab1-Visual-C++/"/>
      <url>2020/06/13/MFC-GC-lab1-Visual-C++/</url>
      
        <content type="html"><![CDATA[<h2 id="1-MFC应用程序开发方法"><a href="#1-MFC应用程序开发方法" class="headerlink" title="1 MFC应用程序开发方法"></a>1 MFC应用程序开发方法</h2><h3 id="1-1-创建MFC工程文件"><a href="#1-1-创建MFC工程文件" class="headerlink" title="1.1 创建MFC工程文件"></a>1.1 创建MFC工程文件</h3><blockquote><p> 挖坑，待填</p></blockquote><h2 id="2-图形设备接口和图形程序设计"><a href="#2-图形设备接口和图形程序设计" class="headerlink" title="2 图形设备接口和图形程序设计"></a>2 图形设备接口和图形程序设计</h2><h3 id="2-2-绘制基本图形"><a href="#2-2-绘制基本图形" class="headerlink" title="2.2 绘制基本图形"></a>2.2 绘制基本图形</h3><h4 id="（1）画点"><a href="#（1）画点" class="headerlink" title="（1）画点"></a>（1）画点</h4><h5 id="textout和textoutw"><a href="#textout和textoutw" class="headerlink" title="textout和textoutw"></a>textout和textoutw</h5><p>TextOutW()用于Unicode的宽字符 TextOut()用于窄字符 在<a href="https://www.baidu.com/s?wd=MFC&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">MFC</a>里头，你只要看见带w的函数都是针对宽字符的，譬如w_char什么的</p><h5 id="char-转为-CString"><a href="#char-转为-CString" class="headerlink" title="char * 转为 CString"></a>char * 转为 CString</h5><p>CString.format(“%s”,char*); <a href="https://blog.csdn.net/lidandan2016/article/details/90260172">help here</a></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; Ccglab1View 绘图void Ccglab1View::OnDraw(CDC* pDC)&#123;&#x2F;*Ccglab1Doc* pDoc &#x3D; GetDocument();ASSERT_VALID(pDoc);CString x(&quot;zsz憨批！&quot;);pDC-&gt;TextOut(30, 30, x);if (!pDoc)return;*&#x2F;&#x2F;&#x2F;绘制一组彩色点&#x2F;&#x2F;Ccglab1Doc* pDC &#x3D; GetDocument();CString x(&quot;point:&quot;);pDC-&gt;TextOut(20, 20, x);pDC-&gt;SetPixel(100, 20, RGB(255, 0, 0));&#x2F;*红*&#x2F;pDC-&gt;SetPixel(110, 20, RGB(0, 255, 0));&#x2F;*绿*&#x2F;pDC-&gt;SetPixel(120, 20, RGB(0, 0, 255));&#x2F;*蓝*&#x2F;&#x2F;*pDC-&gt;SetPixel(100, 20, RGB(255, 255, 0));pDC-&gt;SetPixel(100, 20, RGB(255, 0, 255));pDC-&gt;SetPixel(100, 20, RGB(0, 255, 255));pDC-&gt;SetPixel(100, 20, RGB(0, 0, 0));pDC-&gt;SetPixel(100, 20, RGB(255, 255, 255));*&#x2F;&#x2F;&#x2F; TODO: 在此处为本机数据添加绘制代码&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200611211440337.png" alt="image-20200611211440337"></p><h4 id="（2）画直线和折线"><a href="#（2）画直线和折线" class="headerlink" title="（2）画直线和折线"></a>（2）画直线和折线</h4><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200611213307435.png" alt="image-20200611213307435"></p><p>折线</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200611213338992.png" alt="image-20200611213338992"></p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200611213408334.png" alt="image-20200611213408334"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; Ccglab1View 绘图void Ccglab1View::OnDraw(CDC* pDC)&#123;&#x2F;&#x2F; 绘制直线CString x(&quot;Line:&quot;);pDC-&gt;TextOutW(20, 60, x);pDC-&gt;MoveTo(20, 90);pDC-&gt;LineTo(160, 90);&#x2F;&#x2F; 绘制折线1POINT polylinepoint[4] &#x3D; &#123; &#123;70, 240&#125;, &#123;20, 190&#125;, &#123;70, 190&#125;, &#123;20, 240&#125; &#125;;&#x2F;*定义四个点*&#x2F;pDC-&gt;Polyline(polylinepoint, 4);&#x2F;*根据四个点，画出折线*&#x2F;&#x2F;&#x2F; 绘制折线2POINT polypolulinePt[9] &#x3D; &#123; &#123;95, 160&#125;, &#123;120, 185&#125;, &#123;120, 250&#125;, &#123;145, 160&#125;, &#123;120, 185&#125;, &#123;90, 185&#125;, &#123;150, 185&#125;, &#123;80, 210&#125;, &#123;160, 210&#125; &#125;;&#x2F;*定义9个点*&#x2F;DWORD dwPolyPoints[4] &#x3D; &#123; 3, 2, 2, 2 &#125;;&#x2F;*分四段折线，分别占用3,2,2,2个顶点*&#x2F;pDC-&gt;PolyPolyline(polypolulinePt, dwPolyPoints, 4);&#x2F;*四段折线的顶点，以及每条折线的顶点数，折线数量*&#x2F;&#x2F;&#x2F; TODO: 在此处为本机数据添加绘制代码&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>由于一条折线至少需要 2 个顶点，因此 dwPolyPoints 数组中的数不应该小于 2。 </p></blockquote><h4 id="（3）画弧线和曲线"><a href="#（3）画弧线和曲线" class="headerlink" title="（3）画弧线和曲线"></a>（3）画弧线和曲线</h4><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200611213452725.png" alt="image-20200611213452725"></p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200611213511522.png" alt="image-20200611213511522"></p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200611215528536.png" alt="image-20200611215528536"></p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200611215545470.png" alt="image-20200611215545470"></p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">&#x2F;&#x2F; Ccglab1View 绘图void Ccglab1View::OnDraw(CDC* pDC)&#123;&#x2F;&#x2F; 用Arc() 绘制圆、圆弧和椭圆&#x2F;&#x2F; 同心圆for (int i &#x3D; 0; i &lt; 6; i++) &#123;pDC-&gt;Arc(260 - 5 * i, 70 - 5 * i, 260 + 5 * i, 70 + 5 * i, 260 + 5 * i, 70, 260 + 5 * i, 70);&#125;const double pi &#x3D; 3.1415926;double angel &#x3D; 60 * pi &#x2F; 180;for (int i &#x3D; 3; i &lt; 6; i++) &#123;&#x2F;&#x2F; 右半圆弧pDC-&gt;Arc(260 - 10 * i, 70 - 10 * i, 260 + 10 * i, 70 + 10 * i,(int)260 + 10 * i * cos(angel),(int)70 + 10 * i * sin(angel),(int)260 + 10 * i * cos(angel),(int)70 - 10 * i * sin(angel));&#x2F;&#x2F; 左半圆弧pDC-&gt;Arc(260 - 10 * i, 70 - 10 * i, 260 + 10 * i, 70 + 10 * i,(int)260 - 10 * i * cos(angel),(int)70 - 10 * i * sin(angel),(int)260 - 10 * i * cos(angel),(int)70 + 10 * i * sin(angel));&#125;        &#x2F;&#x2F; 绘制Bezier曲线&#x2F;&#x2F; 画出一条Bezier曲线和特征多边形POINT polyBezier[4] &#x3D; &#123; &#123;20, 310&#125;, &#123;60, 240&#125;, &#123;120, 300&#125;, &#123;160, 330&#125; &#125;;pDC-&gt;Polyline(polyBezier, 4);pDC-&gt;PolyBezier(polyBezier, 4);&#x2F;&#x2F; TODO: 在此处为本机数据添加绘制代码&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200611215236326.png" alt="image-20200611215236326"></p><h4 id="（4）画封闭曲线"><a href="#（4）画封闭曲线" class="headerlink" title="（4）画封闭曲线"></a>（4）画封闭曲线</h4><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200611220248895.png" alt="image-20200611220248895"></p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200611220302256.png" alt="image-20200611220302256"></p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200611220317646.png" alt="image-20200611220317646"></p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200611220332750.png" alt="image-20200611220332750"></p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200611220344557.png" alt="image-20200611220344557"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; Ccglab1View 绘图void Ccglab1View::OnDraw(CDC* pDC)&#123;&#x2F;&#x2F; 画封闭曲线&#x2F;&#x2F; 绘制矩形、圆角矩形、椭圆和多边形pDC-&gt;Rectangle(190, 270, 250, 310);pDC-&gt;RoundRect(265, 270, 330, 310, 30, 20);pDC-&gt;Ellipse(260 - 50, 200 - 30, 260 + 50, 200 + 30);POINT polygonPts[3] &#x3D; &#123; &#123;390, 160&#125;, &#123;430, 220&#125;, &#123;350, 210&#125; &#125;;pDC-&gt;Polygon(polygonPts, 3);&#x2F;&#x2F; TODO: 在此处为本机数据添加绘制代码&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200611220428854.png" alt="image-20200611220428854"></p><h3 id="2-3-画笔与画刷"><a href="#2-3-画笔与画刷" class="headerlink" title="2.3 画笔与画刷"></a>2.3 画笔与画刷</h3><h5 id="关于lopnWidth的数据类型"><a href="#关于lopnWidth的数据类型" class="headerlink" title="关于lopnWidth的数据类型"></a>关于lopnWidth的数据类型</h5><p>在lopnWidth的类型是POINT，但是y值未使用，可以大胆的使用<code>POINT&#123;1, 0&#125;</code></p><blockquote><p>The <strong>y</strong> value in the <a href="https://baike.baidu.com/item/POINT">POINT</a> structure for the <strong>lopnWidth</strong> member is not used.</p></blockquote><h4 id="（1）画笔"><a href="#（1）画笔" class="headerlink" title="（1）画笔"></a>（1）画笔</h4><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200611225122037.png" alt="image-20200611225122037"></p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200611225131395.png" alt="image-20200611225131395"></p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200611225150484.png" alt="image-20200611225150484"></p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">&#x2F;&#x2F; Ccglab1View 绘图void Ccglab1View::OnDraw(CDC* pDC)&#123;&#x2F;&#x2F; 创建画笔&#x2F;&#x2F; 方法1CPen pen1(PS_SOLID, 1, RGB(255, 0, 0));&#x2F;&#x2F; 方法2CPen Pen2;Pen2.CreatePen(PS_SOLID, 1, RGB(255, 0, 0));&#x2F;&#x2F; 方法3CPen Pen3;LOGPEN LogPen;LogPen.lopnStyle &#x3D; PS_SOLID;LogPen.lopnWidth &#x3D; POINT&#123;1, 0&#125;;&#x2F;*X field contains the width of the pen in logical units. The Y field is not used.*&#x2F;LogPen.lopnColor &#x3D; RGB(255, 0, 0);Pen3.CreatePenIndirect(&amp;LogPen);&#x2F;&#x2F; TODO: 在此处为本机数据添加绘制代码&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不同笔的测试</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">&#x2F;&#x2F; Ccglab1View 绘图void Ccglab1View::OnDraw(CDC* pDC)&#123;&#x2F;&#x2F; 创建画笔&#x2F;&#x2F; 画笔的样式、宽度和颜色int nPenStyle[] &#x3D; &#123; PS_SOLID, PS_DASH, PS_DASHDOT, PS_DASHDOTDOT, PS_NULL, PS_INSIDEFRAME &#125;;CPen* pNewPen;CPen* pOldPen;&#x2F;&#x2F; 用不同样式的画笔for (int i &#x3D; 0; i &lt; 7; i++) &#123;&#x2F;&#x2F; 构造新笔pNewPen &#x3D; new CPen;if (pNewPen-&gt;CreatePen(nPenStyle[i], 1, RGB(0, 0, 0))) &#123;pOldPen &#x3D; pDC-&gt;SelectObject(pNewPen);&#x2F;*选择新笔，并保存旧笔*&#x2F;&#x2F;&#x2F; 画直线pDC-&gt;MoveTo(20, 60 + i * 20);pDC-&gt;LineTo(160, 60 + i * 20);&#x2F;&#x2F; 恢复原有的笔pDC-&gt;SelectObject(pOldPen);&#125;else &#123;&#x2F;&#x2F; 出错提示CString error(&quot;CreatePen Error!&quot;);AfxMessageBox(error);&#125;&#x2F;&#x2F; 删除新笔delete pNewPen;&#125;&#x2F;&#x2F; 用不同的宽度的笔绘图for (int i &#x3D; 0; i &lt; 7; i++) &#123;&#x2F;&#x2F; 构造新笔pNewPen &#x3D; new CPen;if (pNewPen-&gt;CreatePen(PS_SOLID, i + 1, RGB(0, 0, 0))) &#123;pOldPen &#x3D; pDC-&gt;SelectObject(pNewPen);&#x2F;&#x2F; 画直线pDC-&gt;MoveTo(200, 60 + i * 20);pDC-&gt;LineTo(340, 60 + i * 20);&#x2F;&#x2F; 恢复原有的笔pDC-&gt;SelectObject(pOldPen);&#125;else &#123;&#x2F;&#x2F; 出错提示CString error(&quot;CreatePen error!!&quot;);AfxMessageBox(error);&#125;&#x2F;&#x2F; 删除新笔delete pNewPen;&#125;&#x2F;&#x2F; 设置颜色表struct tagColor &#123;int r, g, b;&#125;color[7] &#x3D; &#123; &#123;255, 0, 0&#125;, &#123;0, 255, 0&#125;, &#123;0, 0, 255&#125;, &#123;255, 255, 0&#125;, &#123;255, 0, 255&#125;, &#123;0, 255, 255&#125;, &#123;0, 0, 0&#125; &#125;;&#x2F;&#x2F; 用不同颜色绘图for (int i &#x3D; 0; i &lt; 7; i++) &#123;&#x2F;&#x2F; 构造新笔pNewPen &#x3D; new CPen;if (pNewPen-&gt;CreatePen(PS_SOLID, 2, RGB(color[i].r, color[i].g, color[i].b))) &#123;pOldPen &#x3D; pDC-&gt;SelectObject(pNewPen);&#x2F;&#x2F; 画直线pDC-&gt;MoveTo(380, 60 + i * 20);pDC-&gt;LineTo(520, 60 + i * 20);&#x2F;&#x2F;恢复原有的笔pDC-&gt;SelectObject(pOldPen);&#125;else &#123;&#x2F;&#x2F; 出错提示CString error(&quot;CreatePen error!!&quot;);AfxMessageBox(error);&#125;&#x2F;&#x2F; 删除新笔delete pNewPen;&#125;&#x2F;&#x2F; 画笔程序结束&#x2F;&#x2F; TODO: 在此处为本机数据添加绘制代码&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200611233826243.png" alt="image-20200611233826243"></p><h4 id="（2）画刷"><a href="#（2）画刷" class="headerlink" title="（2）画刷"></a>（2）画刷</h4><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200611233914968.png" alt="image-20200611233914968"></p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200611233927333.png" alt="image-20200611233927333"></p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">&#x2F;&#x2F; Ccglab1View 绘图void Ccglab1View::OnDraw(CDC* pDC)&#123;&#x2F;&#x2F; 画刷程序pDC-&gt;Rectangle(300, 300, 400, 400);&#x2F;*缺省的画刷，白色*&#x2F;&#x2F;&#x2F; 纯色画刷CBrush* pNewBrush1;CBrush* pOldBrush1;pNewBrush1 &#x3D; new CBrush;if (pNewBrush1-&gt;CreateSolidBrush(RGB(255, 0, 0))); &#123;&#x2F;&#x2F; 选择新画刷pOldBrush1 &#x3D; pDC-&gt;SelectObject(pNewBrush1);pDC-&gt;Rectangle(200, 200, 300, 400);&#x2F;&#x2F; 恢复原有画刷pDC-&gt;SelectObject(pOldBrush1);&#125;delete pNewBrush1;&#x2F;&#x2F; 阴影画刷CBrush Brush(HS_DIAGCROSS, RGB(255, 255, 255));CBrush* pOldBrush;pOldBrush &#x3D; pDC-&gt;SelectObject(&amp;Brush);pDC-&gt;SetBkColor(RGB(192, 192, 192));pDC-&gt;Rectangle(0, 0, 100, 100);pDC-&gt;SelectObject(pOldBrush);&#x2F;&#x2F; TODO: 在此处为本机数据添加绘制代码&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200611234841134.png" alt="image-20200611234841134"></p><h3 id="2-4-文本显示"><a href="#2-4-文本显示" class="headerlink" title="2.4 文本显示"></a>2.4 文本显示</h3><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200612002351456.png" alt="image-20200612002351456"></p><h4 id="（1）文本显示"><a href="#（1）文本显示" class="headerlink" title="（1）文本显示"></a>（1）文本显示</h4><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200612002437929.png" alt="image-20200612002437929"></p><h4 id="（2）设置文本颜色"><a href="#（2）设置文本颜色" class="headerlink" title="（2）设置文本颜色"></a>（2）设置文本颜色</h4><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200612003238848.png" alt="image-20200612003238848"></p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">&#x2F;&#x2F; Ccglab1View 绘图void Ccglab1View::OnDraw(CDC* pDC)&#123;&#x2F;&#x2F; 设置文本颜色CDC* pDC1 &#x3D; GetDC();&#x2F;*声明一个设备描述表pDC1*&#x2F;pDC1-&gt;SetTextColor(RGB(255, 0, 0));&#x2F;*设置文本颜色为红色*&#x2F;&#x2F;&#x2F; 可以通过GetBkColor()函数检索到当前文本的颜色COLORREF color &#x3D; pDC-&gt;GetTextColor();&#x2F;&#x2F; TODO: 在此处为本机数据添加绘制代码&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（3）设置字符间距"><a href="#（3）设置字符间距" class="headerlink" title="（3）设置字符间距"></a>（3）设置字符间距</h4><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200612003309024.png" alt="image-20200612003309024"></p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200612003327762.png" alt="image-20200612003327762"></p><h4 id="（4）设置文本的对齐方式"><a href="#（4）设置文本的对齐方式" class="headerlink" title="（4）设置文本的对齐方式"></a>（4）设置文本的对齐方式</h4><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200612003355900.png" alt="image-20200612003355900"></p><h2 id="3-鼠标编程"><a href="#3-鼠标编程" class="headerlink" title="3 鼠标编程"></a>3 鼠标编程</h2><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200612003644992.png" alt="image-20200612003644992"></p><h3 id="3-1-鼠标消息处理"><a href="#3-1-鼠标消息处理" class="headerlink" title="3.1 鼠标消息处理"></a>3.1 鼠标消息处理</h3><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200612004734339.png" alt="image-20200612004734339"></p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200612004757702.png" alt="image-20200612004757702"></p><h3 id="3-2-捕捉鼠标"><a href="#3-2-捕捉鼠标" class="headerlink" title="3.2 捕捉鼠标"></a>3.2 捕捉鼠标</h3><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200612004837928.png" alt="image-20200612004837928"></p><h3 id="3-3-鼠标编程综合示例"><a href="#3-3-鼠标编程综合示例" class="headerlink" title="3.3 鼠标编程综合示例"></a>3.3 鼠标编程综合示例</h3><h4 id="示例1-显示鼠标坐标及状态"><a href="#示例1-显示鼠标坐标及状态" class="headerlink" title="示例1 显示鼠标坐标及状态"></a>示例1 显示鼠标坐标及状态</h4><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200612004937810.png" alt="image-20200612004937810"></p><p>具体方法：</p><ol><li><p>新建项目，名称为myMouse，默认即可</p></li><li><p>菜单栏-&gt;项目-&gt;类向导</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200612011347778.png" alt="image-20200612011347778"></p><p>自动生成类似代码</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200612011409803.png" alt="image-20200612011409803"></p></li><li><p>输入事件处理程序</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200612011650321.png" alt="image-20200612011650321"></p></li><li><p>重复第二步，第三步</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200612012003462.png" alt="image-20200612012003462"></p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">&#x2F;&#x2F; CmyMouseView 消息处理程序void CmyMouseView::OnLButtonDown(UINT nFlags, CPoint point)&#123;&#x2F;&#x2F; TODO: 在此添加消息处理程序代码和&#x2F;或调用默认值&#x2F;&#x2F; 获得pDCCDC* pDC &#x3D; GetDC();CString LButtionDown(&quot;LBUTTIONDOWN!&quot;);pDC-&gt;TextOutW(20, 40, LButtionDown);&#x2F;*输出显示信息*&#x2F;CView::OnLButtonDown(nFlags, point);&#125;void CmyMouseView::OnLButtonUp(UINT nFlags, CPoint point)&#123;&#x2F;&#x2F; TODO: 在此添加消息处理程序代码和&#x2F;或调用默认值CDC* pDC &#x3D; GetDC();CString LButtonUp(&quot;LButton Up!&quot;);pDC-&gt;TextOutW(20, 40, LButtonUp);CView::OnLButtonUp(nFlags, point);&#125;void CmyMouseView::OnMouseMove(UINT nFlags, CPoint point)&#123;&#x2F;&#x2F; TODO: 在此添加消息处理程序代码和&#x2F;或调用默认值CDC* pDC &#x3D; GetDC();char tbuf[80];sprintf_s(tbuf, &quot;Position:(%3d, %3d)&quot;, point.x, point.y);&#x2F;&#x2F; 输出鼠标当前位置CString ttbuf(tbuf);pDC-&gt;TextOutW(20, 20, ttbuf);CView::OnMouseMove(nFlags, point);&#125;void CmyMouseView::OnRButtonDown(UINT nFlags, CPoint point)&#123;&#x2F;&#x2F; TODO: 在此添加消息处理程序代码和&#x2F;或调用默认值CDC* pDC &#x3D; GetDC();CString RButtonDown(&quot;RButton Down!&quot;);pDC-&gt;TextOutW(20, 60, RButtonDown);CView::OnRButtonDown(nFlags, point);&#125;void CmyMouseView::OnLButtonDblClk(UINT nFlags, CPoint point)&#123;&#x2F;&#x2F; TODO: 在此添加消息处理程序代码和&#x2F;或调用默认值CDC* pDC &#x3D; GetDC();CString LDbl(&quot;LButton is double clicked!&quot;);pDC-&gt;TextOutW(20, 80, LDbl);CView::OnLButtonDblClk(nFlags, point);&#125;void CmyMouseView::OnRButtonDblClk(UINT nFlags, CPoint point)&#123;&#x2F;&#x2F; TODO: 在此添加消息处理程序代码和&#x2F;或调用默认值CDC* pDC &#x3D; GetDC();CString RDbl(&quot;RButton is double clicked!&quot;);pDC-&gt;TextOutW(20, 80, RDbl);CView::OnRButtonDblClk(nFlags, point);&#125;&#x2F;&#x2F; 这个比较特殊，在上边找到void CmyMouseView::OnRButtonUp(UINT &#x2F;* nFlags *&#x2F;, CPoint point)&#123;ClientToScreen(&amp;point);CDC* pDC &#x3D; GetDC();CString RButtonUp(&quot;RButton Up!&quot;);pDC-&gt;TextOutW(20, 40, RButtonUp);OnContextMenu(this, point);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>编译程序，并验证执行结果。</p></li></ol><p>效果</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200612013746019.png" alt="image-20200612013746019"></p><blockquote><p>有些小bug，文字会重合，可能需要每次显示后，清除文本框。</p></blockquote><h4 id="示例2-采用鼠标橡皮筋技术画圆"><a href="#示例2-采用鼠标橡皮筋技术画圆" class="headerlink" title="示例2 采用鼠标橡皮筋技术画圆"></a>示例2 采用鼠标橡皮筋技术画圆</h4><ol><li><p>新建项目，项目名：MouseSpring</p></li><li><p>在<code>类向导</code>中添加<code>成员变量</code>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">CPoint m_bO; &#x2F;&#x2F; 圆心&#x2F;*比较懒，省略了*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><p>   <img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200612111102290.png" alt="image-20200612111102290"></p><ol start="3"><li><p>添加自定义的成员函数</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200613180956682.png" alt="image-20200613180956682"></p></li><li><p>在构造函数中初始化成员变量</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">&#x2F;&#x2F; CMouseSpringView 构造&#x2F;析构CMouseSpringView::CMouseSpringView() noexcept&#123;&#x2F;&#x2F; TODO: 在此处添加构造代码m_bO.x &#x3D; 0;&#x2F;*圆心*&#x2F;m_bO.y &#x3D; 0;&#x2F;*圆心*&#x2F;m_bR.x &#x3D; 0;&#x2F;*圆上的点*&#x2F;m_bR.y &#x3D; 0;&#x2F;*圆上的点*&#x2F;m_ist &#x3D; 0;&#x2F;*圆心与圆上的点的区别*&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在OnDraw()中添加代码</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">&#x2F;&#x2F; CMouseSpringView 绘图void CMouseSpringView::OnDraw(CDC* pDC)&#123;CMouseSpringDoc* pDoc &#x3D; GetDocument();ASSERT_VALID(pDoc);if (!pDoc)return;&#x2F;&#x2F; TODO: 在此处为本机数据添加绘制代码pDC-&gt;SelectStockObject(NULL_BRUSH);DrawCircle(pDC, m_bO, m_bR);&#x2F;*调用自定义的成员函数画圆*&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>添加消息响应函数LButtonDown()，MouseMove()，并补充其余部分代码。</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">&#x2F;&#x2F; CMouseSpringView 消息处理程序void CMouseSpringView::DrawCircle(CDC* pDC, CPoint cenp, CPoint ardp)&#123;&#x2F;&#x2F; TODO: 在此处添加实现代码.int radius &#x3D; ComputeRadius(cenp, ardp);&#x2F;&#x2F; 由圆心确定所画圆的外切区域CRect rc(cenp.x - radius, cenp.y - radius, cenp.x + radius, cenp.y + radius);pDC-&gt;Ellipse(rc);&#x2F;*画出一个整圆*&#x2F;&#125;int CMouseSpringView::ComputeRadius(CPoint cenp, CPoint ardp)&#123;&#x2F;&#x2F; TODO: 在此处添加实现代码.int dx &#x3D; cenp.x - ardp.x;int dy &#x3D; cenp.y - ardp.x;&#x2F;&#x2F; sqrt()函数的调用，在头文件中加入#include&lt;math.h&gt;return (int)sqrt(dx * dx + dy * dy);&#125;void CMouseSpringView::OnLButtonDown(UINT nFlags, CPoint point)&#123;&#x2F;&#x2F; TODO: 在此添加消息处理程序代码和&#x2F;或调用默认值CDC* pDC &#x3D; GetDC();pDC-&gt;SelectStockObject(NULL_BRUSH);if (!m_ist) &#123;m_bO &#x3D; m_bR &#x3D; point;&#x2F;*记录第一次点击鼠标位置，定圆心*&#x2F;m_ist++;&#125;else &#123;m_bR &#x3D; point;&#x2F;*记录第二次单击鼠标的位置，定圆周上的点*&#x2F;m_ist--;&#x2F;*为新绘图做准备*&#x2F;DrawCircle(pDC, m_bO, m_bR);&#x2F;*绘制新圆*&#x2F;&#125;ReleaseDC(pDC);&#x2F;*释放设备环境*&#x2F;CView::OnLButtonDown(nFlags, point);&#125;void CMouseSpringView::OnMouseMove(UINT nFlags, CPoint point)&#123;&#x2F;&#x2F; TODO: 在此添加消息处理程序代码和&#x2F;或调用默认值CDC* pDC &#x3D; GetDC();int nDrawmode &#x3D; pDC-&gt;SetROP2(R2_NOT);&#x2F;*设置异或绘图模式，并保存原来绘图模式*&#x2F;pDC-&gt;SelectStockObject(NULL_BRUSH);if (m_ist &#x3D;&#x3D; 1) &#123;CPoint prePnt, curPnt;prePnt &#x3D; m_bR;&#x2F;*获得鼠标所在的前一个位置*&#x2F;curPnt &#x3D; point;&#x2F;&#x2F; 绘制橡皮筋线DrawCircle(pDC, m_bO, prePnt);&#x2F;*用异或模式重复画圆，擦出所画的圆*&#x2F;DrawCircle(pDC, m_bO, curPnt);&#x2F;*用当前位置作为圆周上的点画圆*&#x2F;m_bR &#x3D; point;&#125;pDC-&gt;SetROP2(nDrawmode);&#x2F;*恢复原绘图模式*&#x2F;ReleaseDC(pDC);&#x2F;*释放设备环境*&#x2F;CView::OnMouseMove(nFlags, point);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>运行。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/13/I7BGIev6/image-20200613181416101.png" alt="image-20200613181416101"></p><p>目测是有bug 的，只能画一次图，第二次就gg了。</p></li></ol><h2 id="4-菜单编辑器"><a href="#4-菜单编辑器" class="headerlink" title="4 菜单编辑器"></a>4 菜单编辑器</h2><p>挖坑…</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> CG </tag>
            
            <tag> MFC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云CES WordPress测试</title>
      <link href="2020/06/10/aliyun-CES-WordPress/"/>
      <url>2020/06/10/aliyun-CES-WordPress/</url>
      
        <content type="html"><![CDATA[<h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><h3 id="安装-Apache-HTTP-服务"><a href="#安装-Apache-HTTP-服务" class="headerlink" title="安装 Apache HTTP 服务"></a>安装 Apache HTTP 服务</h3><p>Apache是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。</p><ol><li>执行如下命令，安装Apache服务及其扩展包。</li></ol><pre class="line-numbers language-none"><code class="language-none">yum -y install httpd httpd-manual mod_ssl mod_perl mod_auth_mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回类似如下图结果则表示安装成功。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/VpZrCxXw/TB1l7DUHpY7gK0jSZKzXXaikpXa-1050-137.png" alt="img"></p><ol start="2"><li>执行如下命令，启动Apache服务。</li></ol><pre class="line-numbers language-none"><code class="language-none">systemctl start httpd.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>测试Apache服务是否安装并启动成功。</li></ol><p>Apache默认监听80端口，所以只需在浏览器访问ECS分配的IP地址http://&lt;ECS公网地址&gt;，如下图：</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/VpZrCxXw/TB1HmVpaepyVu4jSZFhXXbBpVXa-1920-937.png" alt="img"></p><h3 id="安装-MySQL-数据库"><a href="#安装-MySQL-数据库" class="headerlink" title="安装 MySQL 数据库"></a>安装 MySQL 数据库</h3><p>由于使用wordpress搭建云上博客，需要使用MySQL数据库存储数据，所以这一步我们安装一下MySQL。</p><ol><li>执行如下命令，下载并安装MySQL官方的<code>Yum Repository</code>。</li></ol><pre class="line-numbers language-none"><code class="language-none">wget http:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql57-community-release-el7-10.noarch.rpmyum -y install mysql57-community-release-el7-10.noarch.rpmyum -y install mysql-community-server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/VpZrCxXw/TB1BRnVHxz1gK0jSZSgXXavwpXa-958-431.png" alt="img"></p><ol start="2"><li>执行如下命令，启动 MySQL 数据库。</li></ol><pre class="line-numbers language-none"><code class="language-none">systemctl start mysqld.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>执行如下命令，查看MySQL运行状态。</li></ol><pre class="line-numbers language-none"><code class="language-none">systemctl status mysqld.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/VpZrCxXw/TB1gszWHuT2gK0jSZFvXXXnFXXa-945-229.png" alt="img"></p><ol start="4"><li>执行如下命令，查看MySQL初始密码。</li></ol><pre class="line-numbers language-none"><code class="language-none">grep &quot;password&quot; &#x2F;var&#x2F;log&#x2F;mysqld.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/VpZrCxXw/TB1FmNpaepyVu4jSZFhXXbBpVXa-834-36.png" alt="img"></p><ol start="5"><li>执行如下命令，登录数据库。</li></ol><pre class="line-numbers language-none"><code class="language-none">mysql -uroot -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/VpZrCxXw/TB1Wz6UHvb2gK0jSZK9XXaEgFXa-675-226.png" alt="img"></p><ol start="6"><li>执行如下命令，修改MySQL默认密码。</li></ol><blockquote><p><strong>说明</strong> 新密码设置的时候如果设置的过于简单会报错，必须同时包含大小写英文字母、数字和特殊符号中的三类字符。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;NewPassWord1.&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="7"><li>执行如下命令，创建wordpress库。</li></ol><pre class="line-numbers language-none"><code class="language-none">create database wordpress; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="8"><li>执行如下命令，创建wordpress库。 执行如下命令，查看是否创建成功。</li></ol><pre class="line-numbers language-none"><code class="language-none">show databases;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="9"><li>输入<code>exit</code>退出数据库。</li></ol><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/VpZrCxXw/TB14Bj0HxD1gK0jSZFKXXcJrVXa-836-664.png" alt="img"></p><h3 id="安装-PHP-语言环境"><a href="#安装-PHP-语言环境" class="headerlink" title="安装 PHP 语言环境"></a>安装 PHP 语言环境</h3><p>WordPress是使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。也可以把WordPress当作一个内容管理系统（CMS）来使用。</p><ol><li>执行如下命令，安装PHP环境。</li></ol><pre class="line-numbers language-none"><code class="language-none">yum -y install php php-mysql gd php-gd gd-devel php-xml php-common php-mbstring php-ldap php-pear php-xmlrpc php-imap<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>执行如下命令创建PHP测试页面。</li></ol><pre class="line-numbers language-none"><code class="language-none">echo &quot;&lt;?php phpinfo(); ?&gt;&quot; &gt; &#x2F;var&#x2F;www&#x2F;html&#x2F;phpinfo.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>执行如下命令，重启Apache服务。</li></ol><pre class="line-numbers language-none"><code class="language-none">systemctl restart httpd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>打开浏览器，访问<code>http://&lt;ECS公网地址&gt;/phpinfo.php</code>，显示如下页面表示PHP语言环境安装成功。</li></ol><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/VpZrCxXw/TB1oCVpaepyVu4jSZFhXXbBpVXa-601-840.png" alt="img"></p><h2 id="Wordpress安装部署"><a href="#Wordpress安装部署" class="headerlink" title="Wordpress安装部署"></a>Wordpress安装部署</h2><h3 id="Wordpress安装和配置"><a href="#Wordpress安装和配置" class="headerlink" title="Wordpress安装和配置"></a>Wordpress安装和配置</h3><p>本小节将在已搭建好的LAMP 环境中，安装部署 WordPress</p><ol><li>执行如下命令，安装wordpress。</li></ol><pre class="line-numbers language-none"><code class="language-none">yum -y install wordpress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示如下信息表示安装成功。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/VpZrCxXw/TB1b02VHEz1gK0jSZLeXXb9kVXa-1042-156.png" alt="img"></p><ol start="2"><li><p>修改WordPress配置文件。</p><p>1）执行如下命令，修改wp-config.php指向路径为绝对路径。</p></li></ol><pre class="line-numbers language-none"><code class="language-none"># 进入&#x2F;usr&#x2F;share&#x2F;wordpress目录。cd &#x2F;usr&#x2F;share&#x2F;wordpress# 修改路径。ln -snf &#x2F;etc&#x2F;wordpress&#x2F;wp-config.php wp-config.php# 查看修改后的目录结构。ll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        2）执行如下命令，移动wordpress到Apache根目录。</p><pre class="line-numbers language-none"><code class="language-none"># 在Apache的根目录&#x2F;var&#x2F;www&#x2F;html下，创建一个wp-blog文件夹。mkdir &#x2F;var&#x2F;www&#x2F;html&#x2F;wp-blogmv * &#x2F;var&#x2F;www&#x2F;html&#x2F;wp-blog&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        3）执行以下命令修改wp-config.php配置文件。</p><p>在执行命令前，请先替换以下三个参数值。</p><ul><li>database_name_here为之前步骤中创建的数据库名称，本示例为wordpress。</li><li>username_here为数据库的用户名，本示例为root。</li><li>password_here为数据库的登录密码，本示例为NewPassWord1.。</li></ul><pre class="line-numbers language-none"><code class="language-none">sed -i &#39;s&#x2F;database_name_here&#x2F;wordpress&#x2F;&#39; &#x2F;var&#x2F;www&#x2F;html&#x2F;wp-blog&#x2F;wp-config.phpsed -i &#39;s&#x2F;username_here&#x2F;root&#x2F;&#39; &#x2F;var&#x2F;www&#x2F;html&#x2F;wp-blog&#x2F;wp-config.phpsed -i &#39;s&#x2F;password_here&#x2F;NewPassWord1.&#x2F;&#39; &#x2F;var&#x2F;www&#x2F;html&#x2F;wp-blog&#x2F;wp-config.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        4）执行以下命令，查看配置文件信息是否修改成功。</p><pre class="line-numbers language-none"><code class="language-none">cat -n &#x2F;var&#x2F;www&#x2F;html&#x2F;wp-blog&#x2F;wp-config.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/VpZrCxXw/TB1j02VHEz1gK0jSZLeXXb9kVXa-913-631.png" alt="img"></p><ol start="3"><li>执行如下命令，重启Apache服务。</li></ol><pre class="line-numbers language-none"><code class="language-none">systemctl restart httpd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 测试Wordpress</p><p>完成以上所有步骤后，就可以测试我们基于ECS所搭建的云上博客了。</p><ol><li><p>打开浏览器并访问http://&lt;ECS公网IP&gt;/wp-blog/wp-admin/install.php。</p></li><li><p>根据以下信息完成wordpress初始化配置。</p><ul><li>Site Title：站点名称，例如：阿里云CES WordPress测试。</li><li>Username：管理员用户名，例如：admin。</li><li>Password：访问密码，例如：HzEcgtOB)ZmiqkYaVT。</li><li>Your Email：email地址，建议为真实有效的地址。若没有，可以填写虚拟email地址，但将无法接收信息，例如：<a href="mailto:&#x61;&#100;&#109;&#105;&#110;&#64;&#x61;&#x64;&#x6d;&#105;&#x6e;&#x2e;&#99;&#x6f;&#109;">&#x61;&#100;&#109;&#105;&#110;&#64;&#x61;&#x64;&#x6d;&#105;&#x6e;&#x2e;&#99;&#x6f;&#109;</a>。</li></ul></li></ol><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/VpZrCxXw/TB1pCnYHuH2gK0jSZFEXXcqMpXa-723-689.png" alt="img"></p><ol start="3"><li><p>单击Install WordPress完成Wordpress初始化。</p></li><li><p>单击Log In进行登录。</p></li></ol><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/VpZrCxXw/TB1ear2HxD1gK0jSZFyXXciOVXa-803-464.png" alt="img"></p><ol start="5"><li>输入设置的用户名和密码。</li></ol><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/VpZrCxXw/TB1kknYHAL0gK0jSZFAXXcA9pXa-704-862.png" alt="img"></p><ol start="6"><li><p>登录后，您就可以添加博客进行发布了。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/VpZrCxXw/Snipaste_2020-06-10_12-56-08.png" alt="img"></p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/VpZrCxXw/Snipaste_2020-06-10_12-55-41.png" alt="img"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术博文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
            <tag> CES </tag>
            
            <tag> 阿里云 </tag>
            
            <tag> 博客 </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令入门</title>
      <link href="2020/06/10/Linux-command-introduction/"/>
      <url>2020/06/10/Linux-command-introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="文件与权限"><a href="#文件与权限" class="headerlink" title="文件与权限"></a>文件与权限</h2><h3 id="文件目录管理命令"><a href="#文件目录管理命令" class="headerlink" title="文件目录管理命令"></a>文件目录管理命令</h3><h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><p>命令描述：tree命令用于以树状图列出目录的内容。</p><p>tree命令没有内置在系统中，使用tree命令需要执行以下命令来安装：</p><pre class="line-numbers language-none"><code class="language-none">yum install -y tree<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令使用示例：</p><pre class="line-numbers language-none"><code class="language-none">tree &#x2F;usr&#x2F;share&#x2F;wallpapers&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1FuM_Hvb2gK0jSZK9XXaEgFXa-533-237.png" alt="img"></p><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>命令描述： ls命令用于显示指定工作目录下的内容。</p><p>命令格式：<code>ls [参数] [目录名]</code>。</p><p>参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-a</td><td align="left">显示所有文件及目录（包括隐藏文件）</td></tr><tr><td align="left">-l</td><td align="left">将文件的权限、拥有者、文件大小等详细信息列出（<code>ll</code>等同于<code>ls -l</code>）</td></tr><tr><td align="left">-r</td><td align="left">将文件反序列出（默认按英文字母正序）</td></tr><tr><td align="left">-t</td><td align="left">将文件按创建时间正序列出</td></tr><tr><td align="left">-R</td><td align="left">递归遍历目录下文件</td></tr></tbody></table><p>命令使用示例：</p><p>查看当前目录下的所有文件（包括隐藏文件）。</p><pre class="line-numbers language-none"><code class="language-none">ll -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB10gRXHQP2gK0jSZPxXXacQpXa-546-381.png" alt="img"></p><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>命令描述：获取当前工作目录的绝对路径。</p><p>命令使用示例：</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1UJhXHHr1gK0jSZR0XXbP8XXa-452-68.png" alt="img"> </p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>命令描述：cd命令用于切换工作目录。</p><p>命令使用示例：</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB16qddHHH1gK0jSZFwXXc7aXXa-412-217.png" alt="img"></p><p>在路径表示中：</p><ul><li>一个半角句号（<code>.</code>）表示当前目录，例如路径./app/log等同于app/log。</li><li>两个半角句号（<code>..</code>）表示上级目录，例如路径/usr/local/../src等同于/usr/src，其中local和src目录同级。</li></ul><p><code>cd</code>命令的默认参数为<code>~</code>，符号<code>~</code>表示当前用户的家目录，即在root用户登录时，命令<code>cd</code>、<code>cd ~</code>和<code>cd /root</code>执行效果相同。</p><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>命令描述：touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>命令格式：<code>touch [参数] [文件]</code>。</p><p>参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-c</td><td align="left">如果指定文件不存在，不会建立新文件</td></tr><tr><td align="left">-r</td><td align="left">使用参考文件的时间记录</td></tr><tr><td align="left">-t</td><td align="left">设置文件的时间记录</td></tr></tbody></table><p>命令使用示例：</p><ul><li>创建两个空文件。</li></ul><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1X_Z.HuT2gK0jSZFvXXXnFXXa-466-133.png" alt="img"></p><ul><li>修改demo1.txt的时间记录为当前系统时间。</li></ul><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1kdaraaNj0u4jSZFyXXXgMVXa-478-128.png" alt="img"></p><ul><li>更新demo2.txt的时间记录，使其和demo1.txt的时间记录相同。</li></ul><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1iMpXHUT1gK0jSZFrXXcNCXXa-499-132.png" alt="img"></p><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>命令描述：mkdir命令用于新建子目录。<code>-p</code>参数确保目录名称存在，不存在的就新建一个。</p><p>命令使用示例：</p><p>新建目录a/b/c/d，并使用tree命令查看创建后的目录结构。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1s2vcjcKfxu4jSZPfXXb3dXXa-510-254.png" alt="img"></p><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>命令描述：rm命令用于删除一个文件或者目录。</p><p>命令格式：<code>rm [参数] [文件]</code>。</p><p>参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-i</td><td align="left">删除前逐一询问确认</td></tr><tr><td align="left">-f</td><td align="left">无需确认，直接删除</td></tr><tr><td align="left">-r</td><td align="left">删除目录下所有文件</td></tr></tbody></table><p>命令使用示例：</p><p>无需确认直接删除文件。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1vLo8HqL7gK0jSZFBXXXZZpXa-522-213.png" alt="img"></p><p>无需确认直接删除目录a及其目录下所有子目录和文件。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1asFeHQT2gK0jSZFkXXcIQFXa-415-85.png" alt="img"></p><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>命令描述： cp命令主要用于复制文件或目录。</p><p>命令格式：<code>cp [参数] [源文件] [目标文件]</code>。</p><p>参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-d</td><td align="left">复制时保留链接</td></tr><tr><td align="left">-f</td><td align="left">覆盖已经存在的目标文件而不给出提示</td></tr><tr><td align="left">-i</td><td align="left">覆盖前询问</td></tr><tr><td align="left">-p</td><td align="left">除复制文件的内容外，还把修改时间和访问权限也复制到新文件中</td></tr><tr><td align="left">-r</td><td align="left">复制目录及目录内的所有项目</td></tr></tbody></table><p>命令使用示例：</p><p>将目录c/d中的所有内容复制到目录a/b下。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB10Ck3HuL2gK0jSZPhXXahvXXa-673-465.png" alt="img"></p><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>命令描述： mv命令用来为文件或目录改名、或将文件或目录移入其它位置。</p><p>命令格式：<code>mv [参数] [源文件] [目标文件]</code></p><p>参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-i</td><td align="left">若指定目录已有同名文件，则先询问是否覆盖旧文件</td></tr><tr><td align="left">-f</td><td align="left">如果目标文件已经存在，不会询问而直接覆盖</td></tr></tbody></table><p>命令使用示例：</p><ul><li><p>将文件名a.txt改为b.txt。<br><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1z1M_Hvb2gK0jSZK9XXaEgFXa-348-151.png" alt="img"></p></li><li><p>将c目录移动到a/b/c/d/下。<br><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1M9BiHRr0gK0jSZFnXXbRRXXa-387-276.png" alt="img"></p></li><li><p>将当前目录内容全部移动到/tmp目录中。</p></li></ul><pre class="line-numbers language-none"><code class="language-none">mv .&#x2F;* &#x2F;tmp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h3><p>命令描述：rename命令用字符串替换的方式批量改变文件名。rename命令有C语言和Perl语言两个版本，这里介绍C语言版本的rename命令，不支持正则表达式。</p><p>命令使用示例：</p><ul><li><p>将当前目录下所有文件名中的字符串demo改为大写的字符串DEMO。<br><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB164qEaepyVu4jSZFhXXbBpVXa-410-150.png" alt="img"></p></li><li><p>将当前目录下所有<code>.txt</code>文件后缀都改为<code>text</code>。<br><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1l3pXHUT1gK0jSZFrXXcNCXXa-386-84.png" alt="img"></p></li></ul><h2 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a>文件权限管理</h2><p>ls命令可以查看Linux系统上的文件、目录和设备的权限。</p><pre class="line-numbers language-none"><code class="language-none">ls -l &#x2F;boot&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB12gXcHND1gK0jSZFKXXcJrVXa-869-420.png" alt="img"></p><p>上述<code>ls -l</code>命令中显示的第一列就是文件权限信息，共11位字符，分5部分。</p><ul><li>第1位表示存档类型，<code>d</code>表示目录，<code>-</code>表示一般文件。</li><li>第2~4位表示当前用户的权限（属主权限）。</li><li>第5~7位表示同用户组的用户权限（属组权限）。</li><li>第8~10位表示不同用户组的用户权限（其他用户权限）。</li><li>第11位是一个半角句号<code>.</code>，表示SELinux安全标签。</li></ul><p>用户权限每组三位，rwx分别表示读、写、执行权限，对应八进制表示为4、2、1。</p><p>例如efi目录的root用户权限为<code>drwxr-xr-x.</code>。</p><ul><li>该目录对root用户具有读写和执行所有权限。</li><li>该目录对root组其他用户有读和执行权限。</li><li>该目录对其他用户有读和执行权限。</li></ul><p>所以该权限表示对应八进制权限表示为：</p><ul><li>属主权限：<code>4+2+1=7</code>。</li><li>属组权限：<code>4+1=5</code>。</li><li>其他用户权限：4+1=5。</li></ul><p>即755。</p><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>chmod命令用于修改文件权限mode，<code>-R</code>参数以递归方式对子目录和文件进行修改。</p><p>命令使用示例：</p><ol><li>新建名为hello.sh的Shell脚本，该脚本将会输出<code>Hello World</code>。用<code>ll</code>命令可以看到新建的脚本没有执行权限，其权限用八进制表示为644。</li></ol><pre class="line-numbers language-none"><code class="language-none">echo &quot;echo &#39;Hello World&#39;&quot; &gt; hello.shll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1XPRcHNv1gK0jSZFFXXb0sXXa-520-111.png" alt="img"></p><ol start="2"><li>将hello.sh文件增加属主的执行权限。</li></ol><pre class="line-numbers language-none"><code class="language-none">chmod u+x hello.shll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1RX7nXSRLWu4jSZKPXXb6BpXa-469-110.png" alt="img"></p><ol start="3"><li>将hello.sh文件撤销属主的执行权限。</li></ol><pre class="line-numbers language-none"><code class="language-none">chmod u-x hello.shll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1.q8XHFP7gK0jSZFjXXc5aXXa-458-108.png" alt="img"></p><ol start="4"><li>将hello.sh文件权限修改为八进制表示的744权限。</li></ol><pre class="line-numbers language-none"><code class="language-none">chmod 744 hello.shll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1cq..HpT7gK0jSZFpXXaTkpXa-445-110.png" alt="img"></p><ol start="5"><li>使用bash命令解释器执行hello.sh脚本文件。</li></ol><pre class="line-numbers language-none"><code class="language-none">&#x2F;bin&#x2F;bash hello.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1mIFeHQT2gK0jSZFkXXcIQFXa-448-67.png" alt="img"></p><p>其中，<code>u+x</code>表示增加属主的执行权限，u表示属主，g表示属组，o表示其他，a表示所有用户。</p><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>chown命令修改文件的属主和属组；<code>-R</code>参数以递归方式对子目录和文件进行修改；<code>ls -l</code>命令显示的第三列和第四列就是文件的属主和属组信息。</p><p>命令使用示例：</p><ol><li>新建一个文本文件test.txt，用<code>ll</code>命令可以看到该文件的属主和属组是root。<code>whoami</code>命令可以查看当前Shell环境登录的用户名。</li></ol><pre class="line-numbers language-none"><code class="language-none">whoamitouch test.txtll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1Xq..HpT7gK0jSZFpXXaTkpXa-457-153.png" alt="img"></p><ol start="2"><li>创建两个用户。</li></ol><pre class="line-numbers language-none"><code class="language-none">useradd testuseradd admin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="3"><li>修改test.txt文件的属主用户为test。</li></ol><pre class="line-numbers language-none"><code class="language-none">chown test test.txtll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1IHVfHHj1gK0jSZFuXXcrHpXa-477-106.png" alt="img"></p><ol start="4"><li>修改test.txt文件的属主和属组为admin。</li></ol><pre class="line-numbers language-none"><code class="language-none">chown admin:admin test.txtll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1KbVfHHj1gK0jSZFuXXcrHpXa-471-108.png" alt="img"></p><h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><p>chgrp命令用于修改文件的属组。</p><p>命令使用示例：</p><p>将test.txt文件的属组改为root。</p><pre class="line-numbers language-none"><code class="language-none">chgrp root test.txtll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1uLg.HxD1gK0jSZFsXXbldVXa-522-108.png" alt="img"></p><h1 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h1><h2 id="文本编辑工具Vim"><a href="#文本编辑工具Vim" class="headerlink" title="文本编辑工具Vim"></a>文本编辑工具Vim</h2><h3 id="vim的三种操作模式"><a href="#vim的三种操作模式" class="headerlink" title="vim的三种操作模式"></a>vim的三种操作模式</h3><p>vim有三种操作模式，分别是命令模式（Command mode）、输入模式（Insert mode）和底线命令模式（Last line mode）。</p><p>三种模式切换快捷键：</p><table><thead><tr><th align="left">模式</th><th align="left">快捷键</th></tr></thead><tbody><tr><td align="left">命令模式</td><td align="left">ESC</td></tr><tr><td align="left">输入模式</td><td align="left">i或a</td></tr><tr><td align="left">底线命令模式</td><td align="left">:</td></tr></tbody></table><ul><li><p>命令模式</p><p>在命令模式中控制光标移动和输入命令，可对文本进行复制、粘贴、删除和查找等工作。</p><p>使用命令vim filename后进入编辑器视图后，默认模式就是命令模式，此时敲击键盘字母会被识别为一个命令，例如在键盘上连续敲击两次d，就会删除光标所在行。</p><p>以下是在命令模式中常用的快捷操作：</p></li></ul><table><thead><tr><th align="left">操作</th><th align="left">快捷键</th></tr></thead><tbody><tr><td align="left">光标左移</td><td align="left">h</td></tr><tr><td align="left">光标右移</td><td align="left">l（小写L）</td></tr><tr><td align="left">光标上移</td><td align="left">k</td></tr><tr><td align="left">光标下移</td><td align="left">j</td></tr><tr><td align="left">光标移动到下一个单词</td><td align="left">w</td></tr><tr><td align="left">光标移动到上一个单词</td><td align="left">b</td></tr><tr><td align="left">移动游标到第n行</td><td align="left">nG</td></tr><tr><td align="left">移动游标到第一行</td><td align="left">gg</td></tr><tr><td align="left">移动游标到最后一行</td><td align="left">G</td></tr><tr><td align="left">快速回到上一次光标所在位置</td><td align="left">Ctrl+o</td></tr><tr><td align="left">删除当前字符</td><td align="left">x</td></tr><tr><td align="left">删除前一个字符</td><td align="left">X</td></tr><tr><td align="left">删除整行</td><td align="left">dd</td></tr><tr><td align="left">删除一个单词</td><td align="left">dw或daw</td></tr><tr><td align="left">删除至行尾</td><td align="left">d$或D</td></tr><tr><td align="left">删除至行首</td><td align="left">d^</td></tr><tr><td align="left">删除到文档末尾</td><td align="left">dG</td></tr><tr><td align="left">删除至文档首部</td><td align="left">d1G</td></tr><tr><td align="left">删除n行</td><td align="left">ndd</td></tr><tr><td align="left">删除n个连续字符</td><td align="left">nx</td></tr><tr><td align="left">将光标所在位置字母变成大写或小写</td><td align="left">~</td></tr><tr><td align="left">复制游标所在的整行</td><td align="left">yy（3yy表示复制3行）</td></tr><tr><td align="left">粘贴至光标后（下）</td><td align="left">p</td></tr><tr><td align="left">粘贴至光标前（上）</td><td align="left">P</td></tr><tr><td align="left">剪切</td><td align="left">dd</td></tr><tr><td align="left">交换上下行</td><td align="left">ddp</td></tr><tr><td align="left">替换整行，即删除游标所在行并进入插入模式</td><td align="left">cc</td></tr><tr><td align="left">撤销一次或n次操作</td><td align="left">u{n}</td></tr><tr><td align="left">撤销当前行的所有修改</td><td align="left">U</td></tr><tr><td align="left">恢复撤销操作</td><td align="left">Ctrl+r</td></tr><tr><td align="left">整行将向右缩进</td><td align="left">&gt;&gt;</td></tr><tr><td align="left">整行将向左退回</td><td align="left">&lt;&lt;</td></tr><tr><td align="left">若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开</td><td align="left">ZZ</td></tr></tbody></table><ul><li><p>输入模式</p><p>在命令模式下按i或a键就进入了输入模式，在输入模式下，您可以正常的使用键盘按键对文本进行插入和删除等操作。</p></li><li><p>底线命令模式</p><p>在命令模式下按<code>:</code>键就进入了底线命令模式，在底线命令模式中可以输入单个或多个字符的命令。</p><p>以下是底线命令模式中常用的快捷操作：</p></li></ul><table><thead><tr><th align="left">操作</th><th align="left">命令</th></tr></thead><tbody><tr><td align="left">保存</td><td align="left">:w</td></tr><tr><td align="left">退出</td><td align="left">:q</td></tr><tr><td align="left">保存并退出</td><td align="left">:wq（<code>:wq!</code>表示强制保存退出）</td></tr><tr><td align="left">将文件另存为其他文件名</td><td align="left">:w new_filename</td></tr><tr><td align="left">显示行号</td><td align="left">:set nu</td></tr><tr><td align="left">取消行号</td><td align="left">:set nonu</td></tr><tr><td align="left">使本行内容居中</td><td align="left">:ce</td></tr><tr><td align="left">使本行文本靠右</td><td align="left">:ri</td></tr><tr><td align="left">使本行内容靠左</td><td align="left">:le</td></tr><tr><td align="left">向光标之下寻找一个名称为word的字符串</td><td align="left">:/word</td></tr><tr><td align="left">向光标之上寻找一个字符串名称为word的字符串</td><td align="left">:?word</td></tr><tr><td align="left">重复前一个搜寻的动作</td><td align="left">:n</td></tr><tr><td align="left">从第一行到最后一行寻找word1字符串，并将该字符串取代为word2</td><td align="left"><code>:1,$s/word1/word2/g</code>或<code> :%s/word1/word2/g</code></td></tr></tbody></table><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>在本示例将使用vim在文本文件中写入一首唐诗。</p><ol><li> 新建一个文件并进入vim命令模式。</li></ol><pre class="line-numbers language-none"><code class="language-none">vim 静夜思.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1VZ4LHG61gK0jSZFlXXXDKFXa-911-414.png" alt="img"></p><ol start="2"><li> 按下<code>i</code>进入输入模式，输入《静夜思》的诗名。</li></ol><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1v7BEHQL0gK0jSZFtXXXQCXXa-913-410.png" alt="img"></p><ol start="3"><li>  按下ECS键回到命令模式，并输入底线命令<code>:ce</code>，使诗名居中。</li></ol><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1S58EHUz1gK0jSZLeXXb9kVXa-905-428.png" alt="img"></p><ol start="4"><li> 按下<code>o</code>键换行并进入输入模式，输入第一行诗。</li></ol><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1Db8GHHr1gK0jSZFDXXb9yVXa-904-412.png" alt="img"></p><ol start="5"><li> 按下ECS键回到命令模式，并输入底线命令<code>:ce</code>，使第一行诗居中。</li></ol><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1poNDHFY7gK0jSZKzXXaikpXa-902-415.png" alt="img"></p><ol start="6"><li> 按下<code>o</code>键换行并进入输入模式，输入第二行诗。</li></ol><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1YGNHHKH2gK0jSZFEXXcqMpXa-907-412.png" alt="img"></p><ol start="7"><li> 按下ECS键回到命令模式，并输入底线命令<code>:ce</code>，使第二行诗居中。</li></ol><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1HoNDHLb2gK0jSZK9XXaEgFXa-905-412.png" alt="img"></p><ol start="8"><li> 在命令模式中执行底线命令<code>:wq</code>离开vim。</li></ol><h2 id="文本文件查看命令"><a href="#文本文件查看命令" class="headerlink" title="文本文件查看命令"></a>文本文件查看命令</h2><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>命令描述：cat命令用于查看内容较少的纯文本文件。</p><p>命令格式：<code>cat [选项] [文件]</code>。</p><p>命令参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-n或–number</td><td align="left">显示行号</td></tr><tr><td align="left">-b或–number-nonblank</td><td align="left">显示行号，但是不对空白行进行编号</td></tr><tr><td align="left">-s或–squeeze-blank</td><td align="left">当遇到有连续两行以上的空白行，只显示一行的空白行</td></tr></tbody></table><p>命令使用示例：</p><ol><li> 将一个自增序列写入test.txt文件中。</li></ol><pre class="line-numbers language-none"><code class="language-none">for i in $(seq 1 10); do echo $i &gt;&gt; test.txt ; done<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>查看文件内容。</li></ol><pre class="line-numbers language-none"><code class="language-none">cat test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB17S4FHHr1gK0jSZR0XXbP8XXa-612-258.png" alt="img"></p><ol start="3"><li>将文件内容清空。</li></ol><pre class="line-numbers language-none"><code class="language-none">cat &#x2F;dev&#x2F;null &gt; test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>再次检查文件内容。</li></ol><pre class="line-numbers language-none"><code class="language-none">cat test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1CQBEHQL0gK0jSZFtXXXQCXXa-570-69.png" alt="img"></p><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>命令描述：more命令从前向后分页显示文件内容。</p><p>常用操作命令：</p><table><thead><tr><th align="left">操作</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Enter</td><td align="left">向下n行，n需要定义，默认为1行</td></tr><tr><td align="left">Ctrl+F或空格键（Space）</td><td align="left">向下滚动一页</td></tr><tr><td align="left">Ctrl+B</td><td align="left">向上滚动一页</td></tr><tr><td align="left">=</td><td align="left">输出当前行的行号</td></tr><tr><td align="left">!命令</td><td align="left">调用Shell执行命令</td></tr><tr><td align="left">q</td><td align="left">退出more</td></tr></tbody></table><p>命令使用示例：</p><p>从第20行开始分页查看系统日志文件/var/log/messages。</p><pre class="line-numbers language-none"><code class="language-none">more +20 &#x2F;var&#x2F;log&#x2F;messages<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1xcXGHHr1gK0jSZFDXXb9yVXa-1408-937.png" alt="img"></p><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>命令描述：less命令可以对文件或其它输出进行分页显示，与moe命令相似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动。</p><p>命令格式：<code>less [参数] 文件 </code>。</p><p>命令参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-e</td><td align="left">当文件显示结束后，自动离开</td></tr><tr><td align="left">-m</td><td align="left">显示类似more命令的百分比</td></tr><tr><td align="left">-N</td><td align="left">显示每行的行号</td></tr><tr><td align="left">-s</td><td align="left">显示连续空行为一行</td></tr></tbody></table><p>命令常用操作：</p><table><thead><tr><th align="left">快捷键</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">/字符串</td><td align="left">向下搜索字符串</td></tr><tr><td align="left">?字符串</td><td align="left">向上搜索字符串</td></tr><tr><td align="left">n</td><td align="left">重复前一个搜索</td></tr><tr><td align="left">N</td><td align="left">反向重复前一个搜索</td></tr><tr><td align="left">b或<code>pageup</code>键</td><td align="left">向上翻一页</td></tr><tr><td align="left">空格键或<code>pagedown</code>键</td><td align="left">向下翻一页</td></tr><tr><td align="left">u</td><td align="left">向前翻半页</td></tr><tr><td align="left">d</td><td align="left">向后翻半页</td></tr><tr><td align="left">y</td><td align="left">向前滚动一行</td></tr><tr><td align="left">回车键</td><td align="left">向后滚动一行</td></tr><tr><td align="left">q</td><td align="left">退出less命令</td></tr></tbody></table><p>命令使用示例：</p><p>查看命令历史使用记录并通过less分页显示。</p><pre class="line-numbers language-none"><code class="language-none">history | less<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>命令描述：head命令用于查看文件开头指定行数的内容。</p><p>命令格式：<code>head [参数] [文件]</code>。</p><p>命令参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-n [行数]</td><td align="left">显示开头指定行的文件内容，默认为10</td></tr><tr><td align="left">-c [字符数]</td><td align="left">显示开头指定个数的字符数</td></tr><tr><td align="left">-q</td><td align="left">不显示文件名字信息，适用于多个文件，多文件时默认会显示文件名</td></tr></tbody></table><p>命令使用示例：</p><p>查看/etc/passwd文件的前5行内容。</p><pre class="line-numbers language-none"><code class="language-none">head -5 &#x2F;etc&#x2F;passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB13Pl7Xj39YK4jSZPcXXXrUFXa-590-153.png" alt="img"></p><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>命令描述：tail命令用于查看文档的后N行或持续刷新内容。</p><p>命令格式：<code>tail [参数] [文件]</code>。</p><p>命令参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-f</td><td align="left">显示文件最新追加的内容</td></tr><tr><td align="left">-q</td><td align="left">当有多个文件参数时，不输出各个文件名</td></tr><tr><td align="left">-v</td><td align="left">当有多个文件参数时，总是输出各个文件名</td></tr><tr><td align="left">-c [字节数]</td><td align="left">显示文件的尾部n个字节内容</td></tr><tr><td align="left">-n [行数]</td><td align="left">显示文件的尾部n行内容</td></tr></tbody></table><p>命令使用示例：</p><p>查看/var/log/messages系统日志文件的最新10行，并保持实时刷新。</p><pre class="line-numbers language-none"><code class="language-none">tail -f -n 10 &#x2F;var&#x2F;log&#x2F;messages<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1Pj8JHUY1gK0jSZFCXXcwqXXa-970-240.png" alt="img"></p><p>按<code>ctrl+c</code>键退出文本实时查看界面。</p><h3 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h3><p>命令描述：用来显示文件的详细信息，包括inode、atime、mtime、ctime等。</p><p>命令使用示例：</p><p>查看/etc/passwd文件的详细信息。</p><pre class="line-numbers language-none"><code class="language-none">stat &#x2F;etc&#x2F;passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1cI8LHG61gK0jSZFlXXXDKFXa-628-195.png" alt="img"></p><h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h3><p>命令描述：wc命令用于统计指定文本的行数、字数、字节数。</p><p>命令格式：<code>wc [参数] [文件]</code>。</p><p>命令参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-l</td><td align="left">只显示行数</td></tr><tr><td align="left">-w</td><td align="left">只显示单词数</td></tr><tr><td align="left">-c</td><td align="left">只显示字节数</td></tr></tbody></table><p>命令使用示例：</p><p>统计/etc/passwd文件的行数。</p><pre class="line-numbers language-none"><code class="language-none">wc -l &#x2F;etc&#x2F;passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1E2FKHND1gK0jSZFyXXciOVXa-486-49.png" alt="img"></p><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p>命令描述： file命令用于辨识文件类型。</p><p>命令格式：<code>file [参数] [文件]</code>。</p><p>命令参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-b</td><td align="left">列出辨识结果时，不显示文件名称</td></tr><tr><td align="left">-c</td><td align="left">详细显示指令执行过程，便于排错或分析程序执行的情形</td></tr><tr><td align="left">-f [文件]</td><td align="left">指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称</td></tr><tr><td align="left">-L</td><td align="left">直接显示符号连接所指向的文件类别</td></tr></tbody></table><p>命令使用示例：</p><p>查看/var/log/messages文件的文件类型。</p><pre class="line-numbers language-none"><code class="language-none">file &#x2F;var&#x2F;log&#x2F;messages<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1aE0BHGL7gK0jSZFBXXXZZpXa-533-49.png" alt="img"></p><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>命令描述：diff命令用于比较文件的差异。</p><p>命令使用示例：</p><ol><li>构造两个相似的文件</li></ol><pre class="line-numbers language-none"><code class="language-none">echo -e &#39;第一行\n第二行\n我是log1第3行\n第四行\n第五行\n第六行&#39; &gt; 1.logecho -e &#39;第一行\n第二行\n我是log2第3行\n第四行&#39; &gt; 2.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li><p>分别查看两个文件<img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1KBxLHHj1gK0jSZFuXXcrHpXa-758-318.png" alt="img"></p></li><li><p>使用diff查看两个文件的差异</p></li></ol><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1dqRHHKH2gK0jSZFEXXcqMpXa-455-190.png" alt="img"></p><p>对比结果中的3c3表示两个文件在第3行有不同，5,6d4表示2.log文件相比1.log文件在第4行处开始少了1.log文件的第5和第6行。</p><p> 文本文件处理命令</p><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>命令描述：grep命令用于查找文件里符合条件的字符串。</p><p>grep全称是Global Regular Expression Print，表示全局正则表达式版本，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p><p>在Shell脚本中，grep通过返回一个状态值来表示搜索的状态：</p><ul><li>0：匹配成功。</li><li>1：匹配失败。</li><li>2：搜索的文件不存在。</li></ul><p>命令格式：<code>grep [参数] [正则表达式] [文件]</code>。</p><p>命令常用参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-c或–count</td><td align="left">计算符合样式的列数</td></tr><tr><td align="left">-d recurse或-r</td><td align="left">指定要查找的是目录而非文件</td></tr><tr><td align="left">-e [范本样式]</td><td align="left">指定字符串做为查找文件内容的样式</td></tr><tr><td align="left">-E 或 –extended-regexp</td><td align="left">将样式为延伸的正则表达式来使用</td></tr><tr><td align="left">-F 或 –fixed-regexp</td><td align="left">将样式视为固定字符串的列表</td></tr><tr><td align="left">-G 或 –basic-regexp</td><td align="left">将样式视为普通的表示法来使用</td></tr><tr><td align="left">-i 或 –ignore-case</td><td align="left">忽略字符大小写的差别</td></tr><tr><td align="left">-n 或 –line-number</td><td align="left">在显示符合样式的那一行之前，标示出该行的列数编号</td></tr><tr><td align="left">-v 或 –revert-match</td><td align="left">显示不包含匹配文本的所有行</td></tr></tbody></table><p>命令使用示例：</p><ul><li><p>查看sshd服务配置文件中监听端口配置所在行编号。</p><pre class="line-numbers language-none"><code class="language-none">grep -n Port &#x2F;etc&#x2F;ssh&#x2F;ssh_config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p></li></ul><ul><li><p>查询字符串在文本中出现的行数。</p><pre class="line-numbers language-none"><code class="language-none">grep -c localhost &#x2F;etc&#x2F;hosts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p></li></ul><ul><li><p>反向查找，不显示符合条件的行。</p><pre class="line-numbers language-none"><code class="language-none">ps -ef | grep sshd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">ps -ef | grep -v grep | grep sshd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 命令输出结果：</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1GVNGHUT1gK0jSZFrXXcNCXXa-668-149.png" alt="img"></p></li><li><p>以递归的方式查找目录下含有关键字的文件。</p><pre class="line-numbers language-none"><code class="language-none">grep -r *.sh &#x2F;etc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p></li></ul><ul><li><p>使用正则表达式匹配httpd配置文件中异常状态码响应的相关配置。</p><pre class="line-numbers language-none"><code class="language-none">grep &#39;ntp[0-9].aliyun.com&#39; &#x2F;etc&#x2F;ntp.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p></li></ul><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p>命令描述：sed是一种流编辑器，它是文本处理中非常中的工具，能够完美的配合正则表达式使用。</p><ol><li><p>处理时，把当前处理的行存储在临时缓冲区中，称为模式空间（pattern space）。</p></li><li><p>接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。</p></li><li><p>接着处理下一行，这样不断重复，直到文件末尾。</p></li></ol><p>注意：</p><ul><li>sed命令不会修改原文件，例如删除命令只表示某些行不打印输出，而不是从原文件中删去。</li><li>如果要改变源文件，需要使用-i选项。</li></ul><p>命令格式：<code>sed [参数] [动作] [文件]</code>。 </p><p>参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-e [script]</td><td align="left">执行多个script</td></tr><tr><td align="left">-f [script文件]</td><td align="left">执行指定script文件</td></tr><tr><td align="left">-n</td><td align="left">仅显示script处理后的结果</td></tr><tr><td align="left">-i</td><td align="left">输出到原文件，静默执行（修改原文件）</td></tr></tbody></table><p>动作说明：</p><table><thead><tr><th align="left">动作</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">a</td><td align="left">在行后面增加内容</td></tr><tr><td align="left">c</td><td align="left">替换行</td></tr><tr><td align="left">d</td><td align="left">删除行</td></tr><tr><td align="left">i</td><td align="left">在行前面插入</td></tr><tr><td align="left">p</td><td align="left">打印相关的行</td></tr><tr><td align="left">s</td><td align="left">替换内容</td></tr></tbody></table><p>命令使用示例：</p><ul><li><p>删除第3行到最后一行内容。</p><pre class="line-numbers language-none"><code class="language-none">sed &#39;3,$d&#39; &#x2F;etc&#x2F;passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p></li></ul><ul><li><p>在最后一行新增行。</p><pre class="line-numbers language-none"><code class="language-none">sed &#39;$a admin:x:1000:1000:admin:&#x2F;home&#x2F;admin:&#x2F;bin&#x2F;bash&#39; &#x2F;etc&#x2F;passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p></li></ul><ul><li><p>替换内容。</p><pre class="line-numbers language-none"><code class="language-none">sed &#39;s&#x2F;SELINUX&#x3D;disabled&#x2F;SELINUX&#x3D;enforcing&#x2F;&#39; &#x2F;etc&#x2F;selinux&#x2F;config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p></li></ul><ul><li><p>替换行。</p><pre class="line-numbers language-none"><code class="language-none">sed &#39;1c abcdefg&#39; &#x2F;etc&#x2F;passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p></li></ul><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>命令描述：和 sed 命令类似，awk 命令也是逐行扫描文件（从第 1 行到最后一行），寻找含有目标文本的行，如果匹配成功，则会在该行上执行用户想要的操作；反之，则不对行做任何处理。</p><p>命令格式：<code>awk [参数] [脚本] [文件]</code>。</p><p>参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-F fs</td><td align="left">指定以fs作为输入行的分隔符，awk 命令默认分隔符为空格或制表符</td></tr><tr><td align="left">-f file</td><td align="left">读取awk脚本</td></tr><tr><td align="left">-v val=val</td><td align="left">在执行处理过程之前，设置一个变量var，并给其设置初始值为val</td></tr></tbody></table><p>内置变量：</p><table><thead><tr><th align="left">变量</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">FS</td><td align="left">字段分隔符</td></tr><tr><td align="left">$n</td><td align="left">指定分隔的第n个字段，如$1、$3分别表示第1、第三列</td></tr><tr><td align="left">$0</td><td align="left">当前读入的整行文本内容</td></tr><tr><td align="left">NF</td><td align="left">记录当前处理行的字段个数（列数）</td></tr><tr><td align="left">NR</td><td align="left">记录当前已读入的行数</td></tr><tr><td align="left">FNR</td><td align="left">当前行在源文件中的行号</td></tr></tbody></table><p>awk中还可以指定脚本命令的运行时机。默认情况下，awk会从输入中读取一行文本，然后针对该行的数据执行程序脚本，但有时可能需要在处理数据前运行一些脚本命令，这就需要使用BEGIN关键字，BEGIN会在awsk读取数据前强制执行该关键字后指定的脚本命令。</p><p>和BEGIN关键字相对应，END关键字允许我们指定一些脚本命令，awk会在读完数据后执行它们。</p><p>命令使用示例：</p><ul><li><p>查看本机IP地址。</p><pre class="line-numbers language-none"><code class="language-none">ifconfig eth0 |awk &#39;&#x2F;inet&#x2F;&#123;print $2&#125;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p></li></ul><ul><li><p>查看本机剩余磁盘容量。</p><pre class="line-numbers language-none"><code class="language-none">df -h |awk &#39;&#x2F;\&#x2F;$&#x2F;&#123;print $4&#125;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p></li></ul><ul><li><p>统计系统用户个数。</p><pre class="line-numbers language-none"><code class="language-none">awk -F: &#39;$3&lt;1000&#123;x++&#125; END&#123;print x&#125;&#39; &#x2F;etc&#x2F;passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p></li></ul><ul><li><p>输出其中登录Shell不以nologin结尾（对第7个字段做!~反向匹配）的用户名、登录Shell信息。</p><pre class="line-numbers language-none"><code class="language-none">awk -F: &#39;$7!~&#x2F;nologin$&#x2F;&#123;print $1,$7&#125;&#39; &#x2F;etc&#x2F;passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p></li></ul><ul><li><p>输出/etc/passwd文件中前三行记录的用户名和用户uid。</p><pre class="line-numbers language-none"><code class="language-none">head -3 &#x2F;etc&#x2F;passwd | awk  &#39;BEGIN&#123;FS&#x3D;&quot;:&quot;;print &quot;name\tuid&quot;&#125;&#123;print $1,&quot;\t&quot;$3&#125;END&#123;print &quot;sum lines &quot;NR&#125;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p></li></ul><ul><li><p>查看tcp连接数。</p><pre class="line-numbers language-none"><code class="language-none">netstat -na | awk &#39;&#x2F;^tcp&#x2F; &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p></li></ul><ul><li><p>关闭指定服务的所有的进程。</p><pre class="line-numbers language-none"><code class="language-none">ps -ef | grep httpd | awk &#123;&#39;print $2&#39;&#125; | xargs kill -9<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3></li></ul><p>命令描述：cut命令主要用来切割字符串，可以对输入的数据进行切割然后输出。</p><p>命令格式：<code>cut [参数] [文件]</code>。</p><p>参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-b</td><td align="left">以字节为单位进行分割</td></tr><tr><td align="left">-c</td><td align="left">以字符为单位进行分割</td></tr><tr><td align="left">-d</td><td align="left">自定义分隔符，默认为制表符</td></tr></tbody></table><p>命令使用示例：</p><ul><li>按字节进行切割。</li></ul><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1ulVKHQT2gK0jSZFkXXcIQFXa-514-109.png" alt="img"></p><ul><li> 按字符进行切割。</li></ul><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1HqRHHKH2gK0jSZFEXXcqMpXa-494-150.png" alt="img"></p><ul><li>按指定字符进行切割。</li></ul><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB17VNGHUT1gK0jSZFrXXcNCXXa-516-107.png" alt="img"></p><h3 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h3><p>命令描述：tr命令用于对来自标准输入的字符进行替换、压缩和删除。</p><p>命令格式：<code>tr [参数] [文本]</code>。</p><p>参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-c</td><td align="left">反选指定字符</td></tr><tr><td align="left">-d</td><td align="left">删除指定字符</td></tr><tr><td align="left">-s</td><td align="left">将重复的字符缩减成一个字符</td></tr><tr><td align="left">-t [第一字符集] [第二字符集]</td><td align="left">删除第一字符集较第二字符集多出的字符，使两个字符集长度相等</td></tr></tbody></table><p>命令使用示例：</p><ul><li><p>将输入字符由大写转换为小写。</p><pre class="line-numbers language-none"><code class="language-none">echo &quot;HELLO WORLD&quot; | tr &#39;A-Z&#39; &#39;a-z&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p></li></ul><ul><li><p>删除字符。</p><pre class="line-numbers language-none"><code class="language-none">echo &quot;hello 123 world 456&quot; | tr -d &#39;0-9&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p></li></ul><ul><li><p>压缩字符。</p><pre class="line-numbers language-none"><code class="language-none">echo &quot;thissss is      a text linnnnnnne.&quot; | tr -s &#39; sn&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p></li></ul><ul><li><p>产生随机密码。</p><pre class="line-numbers language-none"><code class="language-none">cat &#x2F;dev&#x2F;urandom | tr -dc a-zA-Z0-9 | head -c 13<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1kGFGHQP2gK0jSZPxXXacQpXa-573-69.png" alt="img"></p></li></ul><h1 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h1><h2 id="常用系统工作命令"><a href="#常用系统工作命令" class="headerlink" title="常用系统工作命令"></a>常用系统工作命令</h2><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>命令描述：echo命令用于在终端输出字符串或变量提取后的值。</p><p>命令格式：<code>echo [字符串 | $变量]</code>。</p><p>命令用法示例：</p><ul><li><p>显示普通字符串</p><pre class="line-numbers language-none"><code class="language-none">echo &quot;Hello World&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>显示变量</p><p>首先在shell环境中定义一个临时变量name。</p><pre class="line-numbers language-none"><code class="language-none">export name&#x3D;&quot;Tom&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用echo命令将变量name的值显示到终端。</p><pre class="line-numbers language-none"><code class="language-none">echo $name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出结果：</p></li></ul><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1P6NMHHH1gK0jSZFwXXc7aXXa-506-89.png" alt="img"></p><ul><li><p>显示结果定向至文件</p><p>以下命令会将文本<code>This is a test text.</code>输出重定向到文件test.txt中，如果文件已存在，将会覆盖文件内容，如果不存在则创建。其中<code>&gt;</code>符号表示输出重定向。</p><pre class="line-numbers language-none"><code class="language-none">echo &quot;This is a test text.&quot; &gt; test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果您希望将文本追加到文件内容最后，而不是覆盖它，请使用<code>&gt;&gt;</code>输出追加重定向符号。</p></li><li><p>显示命令执行结果</p><p>以下命令将会在终端显示当前的工作路径。</p><pre class="line-numbers language-none"><code class="language-none">echo &#96;pwd&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：pwd命令是用一对反引号（``）包裹，而不是一对单引号（’’）。</p><p>使用<code>$(command)</code>形式可以达到相同效果。</p><pre class="line-numbers language-none"><code class="language-none">echo $(pwd)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出结果：</p></li></ul><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1ntFMHNv1gK0jSZFFXXb0sXXa-513-154.png" alt="img"></p><h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p>命令描述：date命令用于显示和设置系统的时间和日期。</p><p>命令格式：<code>date [选项] [+格式]</code>。</p><p>其中，时间格式的部分控制字符解释如下：</p><table><thead><tr><th align="left">字符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">%a</td><td align="left">当地时间的星期名缩写（例如： 日，代表星期日）</td></tr><tr><td align="left">%A</td><td align="left">当地时间的星期名全称 （例如：星期日）</td></tr><tr><td align="left">%b</td><td align="left">当地时间的月名缩写 （例如：一，代表一月）</td></tr><tr><td align="left">%B</td><td align="left">当地时间的月名全称 （例如：一月）</td></tr><tr><td align="left">%c</td><td align="left">当地时间的日期和时间 （例如：2005年3月3日 星期四 23:05:25）</td></tr><tr><td align="left">%C</td><td align="left">世纪；比如 %Y，通常为省略当前年份的后两位数字（例如：20）</td></tr><tr><td align="left">%d</td><td align="left">按月计的日期（例如：01）</td></tr><tr><td align="left">%D</td><td align="left">按月计的日期；等于%m/%d/%y</td></tr><tr><td align="left">%F</td><td align="left">完整日期格式，等价于 %Y-%m-%d</td></tr><tr><td align="left">%j</td><td align="left">按年计的日期（001-366）</td></tr><tr><td align="left">%p</td><td align="left">按年计的日期（001-366）</td></tr><tr><td align="left">%r</td><td align="left">当地时间下的 12 小时时钟时间 （例如：11:11:04 下午）</td></tr><tr><td align="left">%R</td><td align="left">24 小时时间的时和分，等价于 %H:%M</td></tr><tr><td align="left">%s</td><td align="left">自UTC 时间 1970-01-01 00:00:00 以来所经过的秒数</td></tr><tr><td align="left">%T</td><td align="left">时间，等于%H:%M:%S</td></tr><tr><td align="left">%U</td><td align="left">一年中的第几周，以周日为每星期第一天（00-53）</td></tr><tr><td align="left">%x</td><td align="left">当地时间下的日期描述 （例如：12/31/99）</td></tr><tr><td align="left">%X</td><td align="left">当地时间下的时间描述 （例如：23:13:48）</td></tr><tr><td align="left">%w</td><td align="left">一星期中的第几日（0-6），0 代表周一</td></tr><tr><td align="left">%W</td><td align="left">一年中的第几周，以周一为每星期第一天（00-53）</td></tr></tbody></table><p>命令用法示例：</p><ul><li><p>按照默认格式查看当前系统时间</p><pre class="line-numbers language-none"><code class="language-none">date<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出结果：</p></li></ul><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1EXbMjcKfxu4jSZPfXXb3dXXa-476-46.png" alt="img"></p><ul><li><p>按照指定格式查看当前系统时间</p><pre class="line-numbers language-none"><code class="language-none">date &quot;+%Y-%m-%d %H:%M:%S&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出结果：</p></li></ul><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1tv9Yc5cKOu4jSZKbXXc19XXa-494-48.png" alt="img"></p><ul><li><p>查看今天是当年中的第几天</p><pre class="line-numbers language-none"><code class="language-none">date &quot;+%j&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出结果：</p></li></ul><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1Qq4OHKH2gK0jSZJnXXaT1FXa-492-46.png" alt="img"></p><ul><li><p>将系统的当前时间设置为2020年02月20日20点20分20秒</p><pre class="line-numbers language-none"><code class="language-none">date -s &quot;20200220 20:20:20&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出结果：</p></li></ul><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1sUJGHFY7gK0jSZKzXXaikpXa-576-47.png" alt="img"></p><ul><li><p>校正系统时间，与网络时间同步</p><p>a. 安装ntp校时工具</p></li></ul><pre class="line-numbers language-none"><code class="language-none">yum -y install ntp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  b. 用ntpdate从时间服务器更新时间</p><pre class="line-numbers language-none"><code class="language-none">ntpdate time.nist.gov<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  输出结果：</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB11jd_Xj39YK4jSZPcXXXrUFXa-728-51.png" alt="img"></p><h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><p>命令描述：在终端中下载文件。</p><p>命令格式：<code>wget [参数] 下载地址</code>。</p><p>参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">-b</td><td align="left">后台下载</td></tr><tr><td align="left">-P</td><td align="left">下载到指定目录</td></tr><tr><td align="left">-t</td><td align="left">最大重试次数</td></tr><tr><td align="left">-c</td><td align="left">断点续传</td></tr><tr><td align="left">-p</td><td align="left">下载页面内所有资源，包括图片、视频等</td></tr><tr><td align="left">-r</td><td align="left">递归下载</td></tr></tbody></table><p>命令使用示例：</p><p>下载一张图片到路径/root/static/img/中，<code>-p</code>参数默认值为当前路径，如果指定路径不存在会自动创建。</p><pre class="line-numbers language-none"><code class="language-none">wget -P &#x2F;root&#x2F;static&#x2F;img&#x2F; http:&#x2F;&#x2F;img.alicdn.com&#x2F;tfs&#x2F;TB1.R._t7L0gK0jSZFxXXXWHVXa-2666-1500.png<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出结果：</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1vQxHHFT7gK0jSZFpXXaTkpXa-1740-257.png" alt="img"></p><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>命令描述：ps命令用于查看系统中的进程状态。</p><p>命令格式：<code>ps [参数]</code>。</p><p>命令参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">-a</td><td align="left">显示现行终端机下的所有程序，包括其他用户的程序</td></tr><tr><td align="left">-u</td><td align="left">以用户为主的格式来显示程序状况</td></tr><tr><td align="left">-x</td><td align="left">显示没有控制终端的进程，同时显示各个命令的具体路径</td></tr><tr><td align="left">-e</td><td align="left">列出程序时，显示每个程序所使用的环境变量</td></tr><tr><td align="left">-f</td><td align="left">显示当前所有的进程</td></tr><tr><td align="left">-t</td><td align="left">指定终端机编号，并列出属于该终端机的程序的状况</td></tr></tbody></table><p>命令使用示例：</p><pre class="line-numbers language-none"><code class="language-none">ps -ef | grep sshd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出结果：</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1PWHcaepyVu4jSZFhXXbBpVXa-588-93.png" alt="img"></p><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>命令描述：top命令动态地监视进程活动与系统负载等信息。</p><p>命令使用示例：</p><pre class="line-numbers language-none"><code class="language-none">top<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出结果：</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1RGHcaepyVu4jSZFhXXbBpVXa-700-345.png" alt="img"></p><p>命令输出参数解释：</p><p>以上命令输出视图中分为两个区域，一个统计信息区，一个进程信息区。</p><ul><li><p>统计信息区</p><ul><li>第一行信息依次为：系统时间、运行时间、登录终端数、系统负载（三个数值分别为1分钟、5分钟、15分钟内的平均值，数值越小意味着负载越低）。</li><li>第二行信息依次为：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。</li><li>第三行信息依次为：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。</li><li>第四行信息依次为：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。</li><li>第五行信息依次为：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、预加载内存量。</li></ul></li><li><p>进程信息区</p><table><thead><tr><th align="left">列名</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">PID</td><td align="left">进程ID</td></tr><tr><td align="left">USER</td><td align="left">进程所有者的用户名</td></tr><tr><td align="left">PR</td><td align="left">进程优先级</td></tr><tr><td align="left">NI</td><td align="left">nice值。负值表示高优先级，正值表示低优先级</td></tr><tr><td align="left">VIRT</td><td align="left">进程使用的虚拟内存总量，单位kb</td></tr><tr><td align="left">RES</td><td align="left">进程使用的、未被换出的物理内存大小，单位kb</td></tr><tr><td align="left">SHR</td><td align="left">共享内存大小，单位kb</td></tr><tr><td align="left">S</td><td align="left">进程状态D：不可中断的睡眠状态R：正在运行S：睡眠T：停止Z：僵尸进程</td></tr><tr><td align="left">%CPU</td><td align="left">上次更新到现在的CPU时间占用百分比</td></tr><tr><td align="left">%MEM</td><td align="left">进程使用的物理内存百分比</td></tr><tr><td align="left">TIME+</td><td align="left">进程使用的CPU时间总计，单位1/100秒</td></tr><tr><td align="left">COMMAND</td><td align="left">命令名</td></tr></tbody></table></li></ul><p>按 q 键退出监控页面。</p><h3 id="pidof"><a href="#pidof" class="headerlink" title="pidof"></a>pidof</h3><p>命令描述：pidof命令用于查询指定服务进程的PID值。</p><p>命令格式：<code>pidof [服务名称]</code>。</p><p>命令参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-s</td><td align="left">仅返回一个进程号</td></tr><tr><td align="left">-c</td><td align="left">只显示运行在root目录下的进程，这个选项只对root用户有效</td></tr><tr><td align="left">-o</td><td align="left">忽略指定进程号的进程</td></tr><tr><td align="left">-x</td><td align="left">显示由脚本开启的进程</td></tr></tbody></table><p>命令使用示例：</p><p>查询出crond服务下的所有进程ID。</p><pre class="line-numbers language-none"><code class="language-none">pidof crond<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出结果：</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1iG8KHQL0gK0jSZFAXXcA9pXa-486-44.png" alt="img"></p><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>命令描述：kill命令用于终止指定PID的服务进程。</p><p>kill可将指定的信息送至程序。预设的信息为<code>SIGTERM(15)</code>，可将指定程序终止。若仍无法终止该程序，可使用<code>SIGKILL(9)</code>信息尝试强制删除程序。</p><p>命令格式：<code>kill [参数] [进程PID]</code>。</p><p>命令使用示例：</p><p>删除pid为1247的进程。</p><pre class="line-numbers language-none"><code class="language-none">kill -9 1247<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="killall"><a href="#killall" class="headerlink" title="killall"></a>killall</h3><p>命令描述：killall命令用于终止指定名称的服务对应的全部进程。</p><p>命令格式：<code>killall [进程名称]</code>。</p><p>命令使用示例：</p><p>删除crond服务下的所有进程。</p><pre class="line-numbers language-none"><code class="language-none">killall crond<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h3><p>命令描述：reboot命令用来重启系统。</p><p>命令格式：<code>reboot [-n] [-w] [-d] [-f] [-i]</code>。</p><p>命令参数说明：</p><ul><li>-n：保存数据后再重新启动系统。</li><li>-w：仅做测试，并不是真的将系统重新开机，只会把重新开机的数据写入记录文件/var/log/wtmp。</li><li>-d：重新启动时不把数据写入记录文件/var/tmp/wtmp。</li><li>-f：强制重新开机，不调用shutdown指令的功能。</li><li>-i：关闭网络设置之后再重新启动系统。</li></ul><p>命令使用示例：</p><pre class="line-numbers language-none"><code class="language-none">reboot<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="poweroff"><a href="#poweroff" class="headerlink" title="poweroff"></a>poweroff</h3><p>命令描述：poweroff命令用来关闭系统。</p><p>命令使用示例：</p><pre class="line-numbers language-none"><code class="language-none">poweroff<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="系统状态检测命令"><a href="#系统状态检测命令" class="headerlink" title="系统状态检测命令"></a>系统状态检测命令</h2><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p>命令描述：ifconfig命令用于获取网卡配置与网络状态等信息。</p><p>命令示例：</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1L3dIHUH1gK0jSZSyXXXtlpXa-634-351.png" alt="img"></p><p>命令输出说明：</p><ul><li>第一部分的第一行显示网卡状态信息。<ul><li>eth0表示第一块网卡。</li><li>UP代表网卡开启状态。</li><li>RUNNING代表网卡的网线被接上。</li><li>MULTICAST表示支持组播。</li></ul></li><li>第二行显示网卡的网络信息。<ul><li>inet（IP地址）：172.16.132.195。</li><li>broadcast（广播地址）：172.16.143.255。</li><li>netmask（掩码地址）：255.255.240.0。</li></ul></li><li>RX表示接收数据包的情况，TX表示发送数据包的情况。</li><li>lo表示主机的回环网卡，是一种特殊的网络接口，不与任何实际设备连接，而是完全由软件实现。与回环地址（127.0.0.0/8 或 ::1/128）不同，回环网卡对系统显示为一块硬件。任何发送到该网卡上的数据都将立刻被同一网卡接收到。</li></ul><h3 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h3><p>命令描述：uname命令用于查看系统内核与系统版本等信息。</p><p>命令语法：<code>uname [-amnrsv][--help][--version]</code></p><p>命令使用示例：</p><ul><li><p>显示系统信息。</p><pre class="line-numbers language-none"><code class="language-none">uname -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p></li></ul><ul><li><p>显示当前系统的硬件架构。</p><pre class="line-numbers language-none"><code class="language-none">uname -i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p></li></ul><ul><li><p>显示操作系统发行编号。</p><pre class="line-numbers language-none"><code class="language-none">uname -r<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p></li></ul><ul><li><p>显示操作系统名称。</p><pre class="line-numbers language-none"><code class="language-none">uname -s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p></li></ul><ul><li><p>显示主机名称。</p><pre class="line-numbers language-none"><code class="language-none">uname -n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令输出结果：</p></li></ul><h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><p>命令描述：uptime 用于查看系统的负载信息。</p><p>命令使用示例：</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB13YVJHHr1gK0jSZFDXXb9yVXa-606-50.png" alt="img"></p><p>命令输出说明：</p><table><thead><tr><th align="left">负载信息</th><th align="left">命令输出值</th></tr></thead><tbody><tr><td align="left">当前服务器时间</td><td align="left">14:20:27</td></tr><tr><td align="left">当前服务器运行时长</td><td align="left">2 min</td></tr><tr><td align="left">当前用户数</td><td align="left">2 users</td></tr><tr><td align="left">当前负载情况</td><td align="left"><code>load average: 0.03, 0.04, 0.02</code>（分别取1min，5min，15min的均值）</td></tr></tbody></table><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>命令描述：free用于显示当前系统中内存的使用量信息。</p><p>命令语法：<code>free [-bkmotV][-s &lt;间隔秒数&gt;]</code>。</p><p>命令参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-b</td><td align="left">以Byte为单位显示内存使用情况</td></tr><tr><td align="left">-k</td><td align="left">以KB为单位显示内存使用情况</td></tr><tr><td align="left">-m</td><td align="left">以MB为单位显示内存使用情况</td></tr><tr><td align="left">-h</td><td align="left">以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。</td></tr></tbody></table><p>命令使用示例：</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1xm4IHHr1gK0jSZR0XXbP8XXa-747-88.png" alt="img"></p><p>命令输出说明：</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">total</td><td align="left">物理内存总数</td></tr><tr><td align="left">used</td><td align="left">已经使用的内存数</td></tr><tr><td align="left">free</td><td align="left">空间的内存数</td></tr><tr><td align="left">share</td><td align="left">多个进程共享的内存总额</td></tr><tr><td align="left">buff/cache</td><td align="left">应用使用内存数</td></tr><tr><td align="left">available</td><td align="left">可用的内存数</td></tr><tr><td align="left">Swap</td><td align="left">虚拟内存（阿里云ECS服务器默认不开启虚拟内存）</td></tr></tbody></table><h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3><p>命令描述：who 命令显示关于当前在本地系统上的所有用户的信息。</p><p>命令使用示例：</p><ul><li>显示当前登录系统的用户</li></ul><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1sTdKHQY2gK0jSZFgXXc5OFXa-527-69.png" alt="img"></p><ul><li>显示用户登录来源</li></ul><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1phBIHKT2gK0jSZFvXXXnFXXa-524-94.png" alt="img"></p><ul><li>只显示当前用户</li></ul><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1fMFKHO_1gK0jSZFqXXcpaXXa-510-67.png" alt="img"></p><ul><li>精简模式显示</li></ul><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1saBJHQP2gK0jSZPxXXacQpXa-452-65.png" alt="img"></h2><h3 id="last"><a href="#last" class="headerlink" title="last"></a>last</h3><p>命令描述： last 命令用于显示用户最近登录信息。</p><p>命令使用示例：</p><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB107xHHQL0gK0jSZFtXXXQCXXa-645-215.png" alt="img"></p><p>由于这些信息都是以日志文件的形式保存在系统中，黑客可以很容易地对内容进行篡改，所以该命令输出的信息并不能作为服务器是否被入侵的依据。</p><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>命令描述：history命令用于显示历史执行过的命令。</p><p>bash默认记录1000条执行过的历史命令，被记录在~/.bash_history文件中。</p><p>命令使用示例：</p><ul><li>显示最新10条执行过的命令。</li></ul><p><img src="https://img.zhuomu.xyz/view/img/2020/06/10/b3IA1hHm/TB1_PNMHHH1gK0jSZFwXXc7aXXa-592-238.png" alt="img"></p><ul><li><p>清除历史记录。</p><pre class="line-numbers language-none"><code class="language-none">history -c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Pygments 给实验报告的代码润润色</title>
      <link href="2020/05/17/Pygments-highlight-code/"/>
      <url>2020/05/17/Pygments-highlight-code/</url>
      
        <content type="html"><![CDATA[<p>最初接触到这个东西是在写XCPC板子时遇到的，从Github上clone了人家的$\LaTeX$源码，然后在编译的时候发现需要安装<code>Pygments</code>，所以又查了些资料，发现这个项目润色后的代码确实美观。之前用的是<a href="http://www.planetb.ca/syntax-highlight-word">planetB</a>来写实验报告，很不错，但是和<code>Pygments</code>比起来，少了几分色彩缤纷，于是一直用着<code>Pygments</code>的网页版的<a href="https://pygments.org/demo/">demo</a>，但是由于是国外的网站，加上 ISP 质量较差，总有那么几次急用的时候打不开，比较难顶！于是就在本地部署，使用了几次，效果还不错。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/05/18/YQLR0301/image-20200518011443522.png" alt="无法加载"></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>原理很简单，大多数<code>Syntax Highlight Code</code>采用的策略大致相同，就是通过<code>css</code>渲染出特定的<code>HTML</code>网页，然后通过剪切板，将格式复制走，粘贴到对应支持富文本的其他文档中，比如<code>Word</code>就支持这种格式。由于Word默认的粘贴是保留源格式，所以，相应的彩色部分也就被保留了下来。</p><h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><p>!&gt; 由于Pygments是由Python写的，请确保本地环境已安装Python3.x。</p><ol><li><p>通过<code>pip</code>命令安装<code>Pygments</code>的<code>Packaged versions</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">pip install Pygments<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>Pygments</code>提供多种使用方式，可以在<a href="https://pygments.org/docs/quickstart/">这里</a>查看，这里我们介绍<a href="https://pygments.org/docs/cmdline/"><code>CLI</code></a>模式，也就是<code>Command Line Interface</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pygmentize -f html -O full -o test.html test.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对命令做一些解释：</p><ul><li><code>-f</code> 即format，表示输出文件的格式。</li><li><code>-O</code> 后边所带参数大概是表示输出文档的渲染效果，如：<code>full</code>就是表示输出<code>full HTML document</code>，当然，后边还可以接别的参数，这个在后边会有示例。</li><li><code>-o</code> 可以指定输出文件的命名</li><li>最后接上源文件</li></ul></li><li><p>在本地文件夹用浏览器打开<code>test.html</code>就可以看到被渲染好的文件，粘贴进<code>Word</code>即可。</p></li><li><p>由于字体较大，建议设置为 <code>Consolas</code> 字体，大小 <code>10</code> 号，当然，可以根据自己喜好调整。</p></li></ol><h2 id="部分其他参数以及输出效果"><a href="#部分其他参数以及输出效果" class="headerlink" title="部分其他参数以及输出效果"></a>部分其他参数以及输出效果</h2><p>!&gt; 以下部分test.html文件的预览是在原Microsoft Edge中截图，chrome截图效果可能会差些，但是不影响。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pygmentize -O full,style&#x3D;emacs -o test.html test.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img.zhuomu.xyz/view/img/2020/05/18/YQLR0301/image-20200518015322785.png" alt="image-20200518015322785"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pygmentize -f html -O style&#x3D;colorful,linenos&#x3D;1 -l cpp -o test.html test.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img.zhuomu.xyz/view/img/2020/05/18/YQLR0301/image-20200518015201858.png" alt="image-20200518015201858"></p><p>由于我比较懒，于是在<code>test.cpp</code>同目录下写了自动脚本，渲染完成后，直接调用浏览器打开html文件，这样，直接在命令行中运行bash脚本就可以直接打开渲染结果，然后复制到word文档中去。</p><p>以下分享一下我的脚本<code>auto.sh</code> 的内容</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;shpygmentize -f html -O full -o test.html test.cpp&quot;C:\Program Files (x86)\Google\Chrome\Application\chrome.exe&quot; $1 test.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当然，你也可选择其他浏览器来打开这个html文件，只需要修改路径即可。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>更改Win10 DNS</title>
      <link href="2020/05/11/change-Win10-DNS/"/>
      <url>2020/05/11/change-Win10-DNS/</url>
      
        <content type="html"><![CDATA[<h2 id="更改Win10-DNS"><a href="#更改Win10-DNS" class="headerlink" title="更改Win10 DNS"></a>更改Win10 DNS</h2><h3 id="0x00-预备知识"><a href="#0x00-预备知识" class="headerlink" title="0x00 预备知识"></a>0x00 预备知识</h3><p><strong>命令提示符是什么</strong>？</p><blockquote><p> cmd是<a href="https://baike.baidu.com/item/command/19652640">command</a>的缩写.即<a href="https://baike.baidu.com/item/%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6/998728">命令提示符</a>（CMD），是在OS / 2 ， Win为基础的操作系统（包括[Windows 2000](<a href="https://baike.baidu.com/item/Windows">https://baike.baidu.com/item/Windows</a> 2000/2769068)和XP中， Vista中，和Server 2003 ）下的“MS-DOS 方式”。中文版Windows XP 中的命令提示符进一步提高了与DOS 下操作命令的兼容性，用户可以在命令提示符直接输入中文调用文件。</p><p> 摘自<a href="%5Bhttps://baike.baidu.com/item/cmd%E5%91%BD%E4%BB%A4%5D(https://baike.baidu.com/item/cmd%E5%91%BD%E4%BB%A4)">百度百科</a></p></blockquote><p><strong>如何打开命令提示符</strong>？</p><p>下面介绍几种方法，能看懂哪一个就使用哪一个。</p><ul><li>法一：<code>开始</code> -&gt; <code>Windows系统</code> -&gt; <code>运行</code> -&gt; <code>cmd</code>，出现一个小黑框就是我们所说的命令提示符了。</li><li>法二：快捷键 <code>Win + R</code> -&gt; <code>cmd</code>。</li><li>法三：打开<code>C:\Windows\System32</code>文件夹，往下努力翻，找到<code>cmd.exe</code>这个程序，双击打开。</li></ul><blockquote><p>Win键一般在键盘上<code>Ctrl</code>旁边，笔记本大多会在<code>Fn</code>键旁边，有时Win键也会以微软logo，也就是<code>四个小方块</code>形式印在键盘上。</p></blockquote><p>以下文中提到的<code>cmd</code>均指上文所说的小黑框。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/05/11/hUDV4dQ2/image-20200511181315102.png" alt="image-20200511181315102"></p><h3 id="0x01-正式篇"><a href="#0x01-正式篇" class="headerlink" title="0x01 正式篇"></a>0x01 正式篇</h3><ul><li><p>在<code>cmd</code>中输入<code>control.exe /name Microsoft.NetworkAndSharingCenter</code>，回车，显示如下图所示，然后点击①处。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/05/11/hUDV4dQ2/image-20200511181909270.png" alt="image-20200511181909270"></p></li><li><p>点击<code>属性</code></p><img src="https://img.zhuomu.xyz/view/img/2020/05/11/hUDV4dQ2/image-20200511182041828.png" alt="image-20200511182041828" style="zoom:67%;" /></li><li><p>双击箭头所指地方。</p><img src="https://img.zhuomu.xyz/view/img/2020/05/11/hUDV4dQ2/image-20200511182246418.png" alt="image-20200511182246418" style="zoom:67%;" /></li><li><p>更改DNS时，将②处内容更改为<code>223.5.5.5</code>、<code>223.6.6.6</code>、<code>114.114.114.114</code> 或 <code>8.8.8.8</code>，这几个中任选两个即可。如果有改IP的需求，在①处按照要求修改即可。</p><img src="https://img.zhuomu.xyz/view/img/2020/05/11/hUDV4dQ2/image-20200511182557713.png" alt="image-20200511182557713" style="zoom:67%;" /></li><li><p>最后，刷新DNS。在cmd中输入<code>ipconfig /flushdns</code>，回车，显示下图内容。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/05/11/hUDV4dQ2/image-20200511182940859.png" alt="image-20200511182940859"></p></li><li><p>到了这里，DNS算是更改完成了。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决 Github 图片资源无法显示问题</title>
      <link href="2020/05/10/Github-img-error/"/>
      <url>2020/05/10/Github-img-error/</url>
      
        <content type="html"><![CDATA[<h1 id="解决-Github-图片资源无法显示问题"><a href="#解决-Github-图片资源无法显示问题" class="headerlink" title="解决 Github 图片资源无法显示问题"></a>解决 Github 图片资源无法显示问题</h1><h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><p>任意打开一个 Github 仓库，暂且用<a href="https://github.com/PowerShell/PowerShell">PowerShell</a>来测试，如下图所示，有些图片资源无法显示。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/05/10/4JdT35j7/image-20200510171153468.png" alt="image-20200510171153468"></p><p><img src="https://img.zhuomu.xyz/view/img/2020/05/10/4JdT35j7/image-20200510171229071.png" alt="image-20200510171229071"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li><p>在Chrome中，F12，选择<code>Network</code>，刷新页面，查看错误信息。（下图是在Edge中截的）</p><p><img src="https://img.zhuomu.xyz/view/img/2020/05/10/4JdT35j7/image-20200510171534716.png" alt="image-20200510171534716"></p><p>双击红色部分，然后复制链接。</p></li><li><p>在<a href="https://www.ipaddress.com/">这里</a>查询IP（看这个网站的标题就知道什么意思了，The Best IP Address, Email and Networking Tools - IPAddress.com）。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/05/10/4JdT35j7/image-20200510172711418.png" alt="image-20200510172711418"></p></li><li><p>根据查询的结果，将这个IP放到本地<code>hosts</code>文件中即可，当然，如果过一段时间失效了，那就再来查询一次，更新<code>hosts</code>文件。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/05/10/4JdT35j7/image-20200510172454593.png" alt="image-20200510172454593"></p></li><li><p>最后还需要刷新一下 <code>dns</code> 缓存，在 <code>cmd</code> 中输入，<code>ipconfig /flushdns</code>.</p></li></ul><blockquote><p>ps：hosts文件一般在<code>C:\Windows\System32\drivers\etc</code>路径下。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术博文 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用人体工学调整你的桌面[by:Microsoft]</title>
      <link href="2020/05/07/comfortable-desk-Microsoft/"/>
      <url>2020/05/07/comfortable-desk-Microsoft/</url>
      
        <content type="html"><![CDATA[<h1 id="设置你的桌面"><a href="#设置你的桌面" class="headerlink" title="设置你的桌面"></a>设置你的桌面</h1><p>当你在办公桌前工作时，避免不舒服的姿势，使身体保持正确姿势很重要。这可提高你的整体舒适度并使你高效工作。下面是一些可用于正确设置人体工学工作站的提示。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/05/08/HBcx1IYT/MicrosoftDesk.jpg" alt="Diagram of proper desktop position"></p><h2 id="下面是一些需要记住的其他提示"><a href="#下面是一些需要记住的其他提示" class="headerlink" title="下面是一些需要记住的其他提示"></a>下面是一些需要记住的其他提示</h2><ul><li>多注意休息。</li><li>使用软件和硬件功能，如快速滚动以更高效地工作。</li><li>通过使监视器远离光源来避免炫光。</li><li>使手腕和前臂保持在一条线上。</li><li>键入时，不要使用手腕以外的部位。</li></ul><h3 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h3><h4 id="健康计算指南"><a href="#健康计算指南" class="headerlink" title="健康计算指南"></a>健康计算指南</h4><p><strong>用于提高工作区舒适度的提示。</strong></p><p>下载我们的指南，以了解如何更舒适地工作并帮助降低重复性压力损伤的风险。你的工作区和外围设备有所不同。</p><p><a href="http://download.microsoft.com/download/E/4/1/E413E1EC-B4E7-4B49-B786-F07BA02C57D3/Healthy_Computing_Guide.pdf">下载指南</a></p><h4 id="人体工学白皮书"><a href="#人体工学白皮书" class="headerlink" title="人体工学白皮书"></a>人体工学白皮书</h4><p>如何使用人体工学输入设备降低工作相关的肌肉骨骼失调疾病。</p><p>下载我们的白皮书以获取有关如何更舒适地工作的更多详细信息。了解如何减少事故并降低重复性压力损伤的代价。</p><p><a href="http://download.microsoft.com/download/E/4/1/E413E1EC-B4E7-4B49-B786-F07BA02C57D3/Ergonomic_Whitepaper.pdf">下载指南</a></p><h4 id="员工的健康计算指南"><a href="#员工的健康计算指南" class="headerlink" title="员工的健康计算指南"></a>员工的健康计算指南</h4><p>人体工学、相关的好处和 Microsoft 产品的概述。</p><p>在此快速参考指南中快速查看提升工作环境健康度的好处及相关产品。</p><p><a href="http://download.microsoft.com/download/E/4/1/E413E1EC-B4E7-4B49-B786-F07BA02C57D3/Healthy_Computing_Employee_Reference_Guide.pdf">下载指南</a></p><h4 id="雇主的健康计算指南"><a href="#雇主的健康计算指南" class="headerlink" title="雇主的健康计算指南"></a>雇主的健康计算指南</h4><p>有关提高员工舒适度的信息和建议。</p><p>查看有关如何提升工作环境健康度的信息和提示。</p><p><a href="http://download.microsoft.com/download/E/4/1/E413E1EC-B4E7-4B49-B786-F07BA02C57D3/Healthy_Computing_Business_Reference_Guide.pdf">下载指南</a></p><h4 id="从我们认证的专业人体工学专家那里获取专家建议"><a href="#从我们认证的专业人体工学专家那里获取专家建议" class="headerlink" title="从我们认证的专业人体工学专家那里获取专家建议"></a>从我们认证的专业人体工学专家那里获取专家建议</h4><p>Edie Adams 是一名认证的专业人体工学专家，他谈论了与使用计算机关联的健康风险以及怎样做会尽可能降低损伤风险。</p><p><a href="http://download.microsoft.com/download/E/4/1/E413E1EC-B4E7-4B49-B786-F07BA02C57D3/Healthy_Computing_Business_Reference_Guide.pdf">下载指南</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人体工学 </tag>
            
            <tag> Microsoft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sublime Text 3 解决GB2312或GBK乱码问题</title>
      <link href="2020/05/01/Sublime-Text-3-GB2312-or-GBK/"/>
      <url>2020/05/01/Sublime-Text-3-GB2312-or-GBK/</url>
      
        <content type="html"><![CDATA[<p>安装插件：gbk support</p>]]></content>
      
      
      <categories>
          
          <category> 技术博文 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>肖申克的救赎 叙旧</title>
      <link href="2020/04/20/The-Shawshank-Redemption/"/>
      <url>2020/04/20/The-Shawshank-Redemption/</url>
      
        <content type="html"><![CDATA[<ul><li><p>它关得住我们的身体，却关不住自由的心。永远不要放弃希望。</p></li><li><p>希望是美好的，也许是人间至善，而美好的事物永不消逝。</p><p>原文：Hope is a good thing, maybe the best of things and no good thing ever dies.</p></li><li><p>恐惧囚禁灵魂，希望还你自由。</p><p>原文：Fear can hold you prisoner, hope can set you free.</p></li><li><p>每个人的忍耐都会有限度的。</p><p>原文：Every man’s got a breaking point.</p></li><li><p>在没有任何希望和自由的情况下，人应该怎么办。安迪，没有想像般的柔弱，他之所以感动人，就在于他自己救赎自己……</p></li><li><p>有一种鸟是永远也关不住的，因为它的每片羽翼上都沾满了自由的光辉！ 另译：有的鸟毕竟是关不住的，他们的羽翼太光辉了，当他们飞走，你会由衷庆贺他获得自由。 </p><p>原文：Some birds aren’t meant to be caged. Their feathers are just too bright. And when they fly away，the part of you that knows it was a sin to lock them up does rejoice.</p></li><li><p>强者自救，圣者渡人。</p><p>原文：It takes a strong man to save himself，and a great man to save another.</p></li><li><p>我发现自己是如此的激动，以至于不能静静地坐下来思考。我想只有那些重获自由即将踏上新征程的人们才能感受到这种即将揭开未来神秘面纱的激动心情。我希望跨越千山万水握住朋友的手，我希望太平洋的海水如同梦中的一样蓝：我希望……</p><p>原文：I find I’m so excited. I can barely sit still or hold a thought in my head. I think it’s the excitement only a free man can feel, a free man at the start of a long journey whose conclusion is uncertain. I hope I can make it across the border, I hope to see my friend, and shake his hand. I hope the Pacific is as blue as it has been in my dreams. I hope.</p></li><li><p>监狱生活充满了一段又一段的例行公事。</p></li><li><p>监狱里的高墙实在是很有趣。刚入狱的时候，你痛恨周围的高墙；慢慢地，你习惯了生活在其中；最终你会发现自己不得不依靠它而生存。这就是体制化。</p><p>原文：These walls are kind of funny like that. First you hate them, then you get used to them. Enough time passed, get so you depend on them. That’s institutionalized.</p></li><li><p>我无时不刻地对自己的所作所为深感内疚，这不是因为我在这里（指监狱），也不是讨好你们（指假释官）。回首曾经走过的弯路，我多么想对那个犯下重罪的愚蠢的年轻人说些什*么，告诉他我现在的感受，告诉他还可以有其他的方式解决问题。可是，我做不到了。那个年轻人早已淹没在岁月的长河里，只留下一个老人孤独地面对过去。重新做人？骗人罢了！小子，别再浪费我的时间了，盖你的章吧，我没什么可说的了。</p><p>原文：There’s not a day goes by I don’t feel regret. Not because I’m in here, or because you think I should. I look back on the way I was then. Then a young, stupid kid who committed that terrible crime. I want to talk to him. I want to try and talk some sense to him, tell him the way things are. But I can’t. That kid’s long gone and this old man is all that’s left. I got to live with that. Rehabilitated? It’s just a bullshit word. So you go on and stamp your form, sonny, and stop wasting my time. Because to tell you the truth, I don’t give a shit.</p></li><li><p>生命可以归结为一种简单的选择：要么忙于生存，要么赶著去死。</p><p>原文：I guess it comes down to a simple choice: get busy living or get busy dying. </p><p>每个人都是自己的上帝。如果你自己都放弃自己了，还有谁会救你？每个人都在忙，有的忙著生，有的忙著死。忙著追名逐利的你，忙著柴米油盐的你，停下来想一秒：你的大脑，是不是已经被体制化了？你的上帝在哪里？</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Greek Handwriting — Handwritten letters in Greek</title>
      <link href="2020/04/02/Greek-Handwriting-Handwritten-letters-in-Greek/"/>
      <url>2020/04/02/Greek-Handwriting-Handwritten-letters-in-Greek/</url>
      
        <content type="html"><![CDATA[<h1 id="Greek-Handwriting-—-Handwritten-letters-in-Greek"><a href="#Greek-Handwriting-—-Handwritten-letters-in-Greek" class="headerlink" title="Greek Handwriting — Handwritten letters in Greek"></a>Greek Handwriting — Handwritten letters in Greek</h1><p>This page is part of the <a href="http://www.foundalis.com/">author</a>’s set of pages on the <a href="http://www.foundalis.com/lan/greek.htm">Greek language</a>.</p><hr><p> Instructions for hand-writing the letters of the Greek alphabet are given below. Each letter is given in its capital form on the left, and lowercase form on the right. When the Greek letter is identical to some Roman one (even if the Greek letter stands for a different sound) no instructions are given, assuming the reader knows how to draw the Roman letters. Otherwise, the strokes that are necessary to draw the Greek letter are numbered (1, 2, 3,…), unless there is a single stroke, and each stroke is marked at its starting point with a green dot (•) and at its end-point with a red dot (•).<strong>Note</strong>: <em>cursive</em> writing is not customary in Greek. Some Greeks do employ cursive forms in their hand-writing, but the practice is not used widely. Some cursive, or “calligraphic” forms are given below, next to the more common non-cursive ones. </p><table><thead><tr><th><strong>Uppercase (Capital)</strong></th><th><strong>Comment</strong></th><th><strong>Lowercase</strong></th><th><strong>Comment</strong></th></tr></thead><tbody><tr><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwua.gif" alt="A"></td><td>Same as Roman A.</td><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwla.gif" alt="a"></td><td>The first of the two is the most typical, “the Greek way” of writing an alpha. Some Greeks, however, write it just like a common hand-written version of the Roman a, as shown on the right. If you prefer your writing to look more genuinely Greek, use the first way; but if you like the safety of the familiar, you may use the second way.</td></tr><tr><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwub.gif" alt="B"></td><td>Same as Roman B.</td><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwlb.gif" alt="b"></td><td>Two ways to draw a beta, differing only in the starting point of the strokes. The first way yields a more squarish beta at the top, and is done in two strokes. The second way yields a more roundish top, and is done in a single stroke (but starts a bit awkwardly at the bottom). Use whatever seems more convenient to you.</td></tr><tr><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwug.gif" alt="G"></td><td>Note: many non-native writers tend to put a little vertical “tail” at the end of the second stroke, seeing it in printed forms of this letter ( Γ ). <em>That’s a serif**!</em> It does not belong to the basic form of gamma any more than the serifs at the end of the horizontal bar of a capital T belong to it. When we write, we usually do not mark the serifs.</td><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwlg.gif" alt="g"></td><td>Not really different, the two ways depend on where you make the crossing point. Making it higher than the notebook line (first way) is more convenient in handwriting. Making it right at the line (second way) is more like the printed letter.</td></tr><tr><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwud.gif" alt="D"></td><td>An alternative order to draw the strokes is just as in A, with the horizontal line (3rd stroke) being the base of the triangle.</td><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwld.gif" alt="d"></td><td>When written quickly, the angle at the top-left usually comes out as a curve.</td></tr><tr><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwue.gif" alt="E"></td><td>Same as Roman E.</td><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwle.gif" alt="e"></td><td>An alternative way to draw this letter is like a c with a horizontal line in the middle (like this: є, or just as the math symbol for “belongs” — for whomever is familiar with that — but in small size).</td></tr><tr><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwuz.gif" alt="Z"></td><td>Same as Roman Z.</td><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwlz.gif" alt="z"></td><td>The length of the top horizontal line doesn’t matter. Also, that line is sometimes slightly curved like a wide-open bowl. The hook at the bottom can be more closed or more open.</td></tr><tr><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwuh.gif" alt="H"></td><td>Same as Roman H (but note that this is the Greek vowel eta).</td><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwlh.gif" alt="h"></td><td>The first form is less common, but more consistent with Greek-style hand-writing. The second form is more common, and appears more familiar to non-Greeks, since it’s identical to the Roman letter n.</td></tr><tr><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwuq.gif" alt="Q"></td><td>Like an O with a horizontal bar bisecting it.</td><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwlq.gif" alt="q"></td><td>The first form is thinner than its corresponding capital letter. The second form is cursive.</td></tr><tr><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwui.gif" alt="I"></td><td>Same as Roman I.</td><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwli.gif" alt="i"></td><td>Same as Roman i without the dot.</td></tr><tr><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwuk.gif" alt="K"></td><td>Same as Roman K.</td><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwlk.gif" alt="k"></td><td>The second form (which looks like the Roman u) is cursive but quite common — perhaps more common than the first form.</td></tr><tr><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwul.gif" alt="L"></td><td>Same as an A without the horizontal bar.</td><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwll.gif" alt="l"></td><td>Sometimes stroke #1 ends with a little hook pointing to the right.</td></tr><tr><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwum.gif" alt="M"></td><td>Same as Roman M.</td><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwlm.gif" alt="m"></td><td>Drawing the strokes in the given order makes it a bit more cursive (preparing for the next letter). But you can also draw a Roman u first, and then extend the line on the left.</td></tr><tr><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwun.gif" alt="N"></td><td>Same as Roman N.</td><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwln.gif" alt="n"></td><td>If you want to distinguish the Greek ν from the Roman v, use the first form.</td></tr><tr><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwuj.gif" alt="J"></td><td>A very rare letter. The second form probably exists so that the letter doesn’t appear discontinuous.</td><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwlj.gif" alt="j"></td><td>Looks complicated, but it’s actually like a lowercase zeta (see it above), the curve of which has acquired an extra spike. Another way to see it is as a final sigma (or Roman s) on top of which stands a lowercase cursive tau (see it below).</td></tr><tr><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwuo.gif" alt="O"></td><td>Same as Roman O.</td><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwlo.gif" alt="o"></td><td>Same as Roman o.</td></tr><tr><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwup.gif" alt="P"></td><td></td><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwlp.gif" alt="p"></td><td>The second form is cursive, and quite rare.</td></tr><tr><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwur.gif" alt="R"></td><td>Same as Roman P (but note that this is the Greek rho).</td><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwlr.gif" alt="r"></td><td>Don’t confuse the Greek ρ with the Roman p. The former has a complete circle, whereas the latter is nearly semicircular.</td></tr><tr><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwus.gif" alt="S"></td><td>The mid-point can sometimes be drawn so that it reaches as far to the right as the upper and lower end-points, but more commonly it stands a little to the left of those.</td><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwls.gif" alt="s"></td><td>In the first form, the top horizontal line is about as long as 1/2 diameter (or 1 radius) of the circle. The second form is the final sigma only (<em>never</em> use it instead of the mid-word sigma), and is identical to the Roman s. <strong>Note</strong>: some books written by non-Greek authors might suggest the Byzantine form c instead. <em>Nobody</em> writes a sigma like that today, save for the Greek Orthodox Church.</td></tr><tr><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwut.gif" alt="T"></td><td>Same as Roman T.</td><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwlt.gif" alt="t"></td><td>The second form is cursive, and perhaps more common than the first one.</td></tr><tr><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwuu.gif" alt="U"></td><td>Same as Roman Y (but note that this is the Greek upsilon).</td><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwlu.gif" alt="u"></td><td>The hook on the left is optional, but usually present.</td></tr><tr><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwuf.gif" alt="F"></td><td>The circle can sometimes be larger, reaching further down, and sometimes (rarely) all the way to the bottom line.</td><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwlf.gif" alt="f"></td><td>The second form is calligraphic, and quite common.</td></tr><tr><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwux.gif" alt="X"></td><td>Same as Roman X (but note that this is the Greek chi).</td><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwlx.gif" alt="x"></td><td>The second form is cursive, and not very common.</td></tr><tr><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwuc.gif" alt="C"></td><td>As with Φ (above), the curve can sometimes be larger, reaching further down, but <em>never</em> all the way to the bottom line.</td><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwlc.gif" alt="c"></td><td>The second stroke often starts at the same height as the two end-points of the bowl.</td></tr><tr><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwuw.gif" alt="W"></td><td>Both forms are equally common.</td><td><img src="https://img.zhuomu.xyz/view/img/2020/04/02/nhseDa8S/hwlw.gif" alt="w"></td><td></td></tr></tbody></table><p>Back to the <a href="http://www.foundalis.com/lan/greek.htm">main page</a> on the Greek language.</p><p>以下是用<a href="https://zh.wikipedia.org/wiki/KK%E9%9F%B3%E6%A8%99">KK音标</a><a href="https://zh.wikipedia.org/wiki/Wikipedia:%E8%8B%B1%E8%AA%9E%E5%9C%8B%E9%9A%9B%E9%9F%B3%E6%A8%99">?</a>表示的<strong>希腊字母的英语发音</strong>，即<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E8%87%98%E5%AD%97%E6%AF%8D">希腊字母</a>的<a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E5%B8%8C%E8%87%98%E8%AA%9E">古希腊语</a>发音。在科学里，元音的发音会比较接近希腊语发音，如*psi.*的发音为/ˈpsiː/而并非/ˈsaɪ/。</p><table><thead><tr><th align="center">希腊语</th><th align="center">古希腊语名字[<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E8%87%98%E5%AD%97%E6%AF%8D%E7%9A%84%E8%8B%B1%E8%AA%9E%E7%99%BC%E9%9F%B3#cite_note-1">1]</a></th><th align="center">英语名字</th><th align="center"><a href="https://zh.wikipedia.org/wiki/Wikipedia:IPA_for_English">英语发音</a></th><th align="center"></th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"><strong>英式</strong></td><td align="center"><strong>美式</strong></td></tr><tr><td align="center">Α α</td><td align="center">ἅλφα</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%CE%91">Alpha</a></td><td align="center">/ˈælfə/</td><td align="center"></td></tr><tr><td align="center">Β β</td><td align="center">βῆτα</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%CE%92">Beta</a></td><td align="center">/ˈbiːtə/</td><td align="center">/ˈbeɪtə/</td></tr><tr><td align="center">Γ γ</td><td align="center">γάμμα</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%CE%93">Gamma</a></td><td align="center">/ˈɡæmə/</td><td align="center"></td></tr><tr><td align="center">Δ δ</td><td align="center">δέλτα</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%CE%94">Delta</a></td><td align="center">/ˈdɛltə/</td><td align="center"></td></tr><tr><td align="center">Ε ε</td><td align="center">ἔψιλόν</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%CE%95">Epsilon</a></td><td align="center">/ˈɛpsɨlɒn/，/ɛpˈsaɪlən/</td><td align="center">/ˈɛpsɨlɒn/</td></tr><tr><td align="center">Ζ ζ</td><td align="center">ζῆτα</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%CE%96">Zeta</a></td><td align="center">/ˈziːtə/</td><td align="center">/ˈzeɪtə/</td></tr><tr><td align="center">Η η</td><td align="center">ῆτα</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%CE%97">Eta</a></td><td align="center">/ˈiːtə/</td><td align="center">/ˈeɪtə/</td></tr><tr><td align="center">Θ θ</td><td align="center">θῆτα</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%CE%98">Theta</a></td><td align="center">/ˈθiːtə/</td><td align="center">/ˈθeɪtə/</td></tr><tr><td align="center">Ι ι</td><td align="center">ἰῶτα</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%CE%99">Iota</a></td><td align="center">/aɪˈoʊtə/</td><td align="center"></td></tr><tr><td align="center">Κ κ</td><td align="center">κάππα</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%CE%9A">Kappa</a></td><td align="center">/ˈkæpə/</td><td align="center"></td></tr><tr><td align="center">Λ λ</td><td align="center">λάμβδα</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%CE%9B">Lambda</a></td><td align="center">/ˈlæmdə/</td><td align="center"></td></tr><tr><td align="center">Μ μ</td><td align="center">μῦ</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%CE%9C">Mu</a></td><td align="center">/ˈmjuː/</td><td align="center">/ˈmuː/</td></tr><tr><td align="center">Ν ν</td><td align="center">νῦ</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%CE%9D">Nu</a></td><td align="center">/ˈnjuː/</td><td align="center">/ˈnuː/</td></tr><tr><td align="center">Ξ ξ</td><td align="center">ξεῖ</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%CE%9E">Xi</a></td><td align="center">/ˈzaɪ/, /ˈksaɪ/</td><td align="center"></td></tr><tr><td align="center">Ο ο</td><td align="center">ὄμικρόν</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%CE%9F">Omicron</a></td><td align="center">/oʊˈmaɪkrɒn/，/ˈɒmɨkrɒn/</td><td align="center">/ˈɒmɨkrɒn/</td></tr><tr><td align="center">Π π</td><td align="center">πεῖ</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%CE%A0">Pi</a></td><td align="center">/ˈpaɪ/</td><td align="center"></td></tr><tr><td align="center">Ρ ρ</td><td align="center">ῥῶ</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%CE%A1">Rho</a></td><td align="center">/ˈroʊ/</td><td align="center"></td></tr><tr><td align="center">Σ σ ς （词尾）</td><td align="center">σῖγμα</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%CE%A3">Sigma</a></td><td align="center">/ˈsɪɡmə/</td><td align="center"></td></tr><tr><td align="center">Τ τ</td><td align="center">ταῦ</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%CE%A4">Tau</a></td><td align="center">/ˈtaʊ/，/ˈtɔː/</td><td align="center"></td></tr><tr><td align="center">Υ υ</td><td align="center">ὔψιλόν</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%CE%A5">Upsilon</a></td><td align="center">/juːpˈsaɪlən/，/ˈʊpsɨlɒn/</td><td align="center"></td></tr><tr><td align="center">/ʌpˈsaɪlən/</td><td align="center">/ˈʌpsɨlɒn/</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Φ φ</td><td align="center">φεῖ</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%CE%A6">Phi</a></td><td align="center">/ˈfaɪ/</td><td align="center"></td></tr><tr><td align="center">Χ χ</td><td align="center">χεῖ</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%CE%A7">Chi</a></td><td align="center">/ˈkaɪ/</td><td align="center"></td></tr><tr><td align="center">Ψ ψ</td><td align="center">ψεῖ</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%CE%A8">Psi</a></td><td align="center">/ˈsaɪ/，/ˈpsaɪ/</td><td align="center"></td></tr><tr><td align="center">Ω ω</td><td align="center">ὦμέγα</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%CE%A9">Omega</a></td><td align="center">/ˈoʊmɨɡə/[<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E8%87%98%E5%AD%97%E6%AF%8D%E7%9A%84%E8%8B%B1%E8%AA%9E%E7%99%BC%E9%9F%B3#cite_note-2">2]</a></td><td align="center">/oʊˈmeɪɡə/</td></tr></tbody></table><p>@&gt; 参考链接：<br>@&gt; - <a href="http://www.foundalis.com/lan/hw/grkhandw.htm">Greek Handwriting</a><br>@&gt; - <a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E8%87%98%E5%AD%97%E6%AF%8D%E7%9A%84%E8%8B%B1%E8%AA%9E%E7%99%BC%E9%9F%B3">wiki 希腊字母的英语发音</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手写 </tag>
            
            <tag> 希腊字母 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提问的智慧——一生中必看的文章，不看后悔一辈子(#滑稽</title>
      <link href="2020/04/01/How-To-Ask-Questions-The-Smart-Way/"/>
      <url>2020/04/01/How-To-Ask-Questions-The-Smart-Way/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md">摘自</a></p><h1 id="提问的智慧"><a href="#提问的智慧" class="headerlink" title="提问的智慧"></a>提问的智慧</h1><p><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/pulls"><img src="https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square" alt="PRs Welcome"></a></p><p><strong>How To Ask Questions The Smart Way</strong></p><p>Copyright © 2001,2006,2014 Eric S. Raymond, Rick Moen</p><p>本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。</p><p>原文网址：<a href="http://www.catb.org/~esr/faqs/smart-questions.html">http://www.catb.org/~esr/faqs/smart-questions.html</a></p><p>Copyleft 2001 by D.H.Grand(nOBODY/Ginux), 2010 by Gasolin, 2015 by Ryan Wu</p><p>本中文指南是基于原文 3.10 版以及 2010 年由 <a href="https://github.com/gasolin">Gasolin</a> 所翻译版本的最新翻译；</p><p>协助指出翻译问题，<strong>请<a href="https://github.com/ryanhanwu/smartquestions/issues/new">发 Issue</a>，或直接<a href="https://github.com/ryanhanwu/smartquestions/compare/">发 Pull Request</a> 给我。</strong></p><p>本文另有<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README.md">繁體中文版</a>。</p><h2 id="原文版本历史"><a href="#原文版本历史" class="headerlink" title="原文版本历史"></a><a href="https://github.com/ryanhanwu/smartquestions/blob/master/history.md">原文版本历史</a></h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E5%A3%B0%E6%98%8E">声明</a></li><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%9C%A8%E6%8F%90%E9%97%AE%E4%B9%8B%E5%89%8D">在提问之前</a></li><li><a href="#%E5%BD%93%E4%BD%A0%E6%8F%90%E9%97%AE%E6%97%B6">当你提问时</a><ul><li><a href="#%E6%85%8E%E9%80%89%E6%8F%90%E9%97%AE%E7%9A%84%E8%AE%BA%E5%9D%9B">慎选提问的论坛</a></li><li><a href="#stack-overflow">Stack Overflow</a></li><li><a href="#%E7%BD%91%E7%AB%99%E5%92%8C-irc-%E8%AE%BA%E5%9D%9B">网站和 IRC 论坛</a></li><li><a href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%BD%BF%E7%94%A8%E9%A1%B9%E7%9B%AE%E9%82%AE%E4%BB%B6%E5%88%97%E8%A1%A8">第二步，使用项目邮件列表</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%9C%89%E6%84%8F%E4%B9%89%E4%B8%94%E6%8F%8F%E8%BF%B0%E6%98%8E%E7%A1%AE%E7%9A%84%E6%A0%87%E9%A2%98">使用有意义且描述明确的标题</a></li><li><a href="#%E4%BD%BF%E9%97%AE%E9%A2%98%E5%AE%B9%E6%98%93%E5%9B%9E%E5%A4%8D">使问题容易回复</a></li><li><a href="#%E7%94%A8%E6%B8%85%E6%99%B0%E6%AD%A3%E7%A1%AE%E7%B2%BE%E5%87%86%E5%B9%B6%E5%90%88%E6%B3%95%E8%AF%AD%E6%B3%95%E7%9A%84%E8%AF%AD%E5%8F%A5">用清晰、正确、精准并合法语法的语句</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%98%93%E4%BA%8E%E8%AF%BB%E5%8F%96%E4%B8%94%E6%A0%87%E5%87%86%E7%9A%84%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8F%91%E9%80%81%E9%97%AE%E9%A2%98">使用易于读取且标准的文件格式发送问题</a></li><li><a href="#%E7%B2%BE%E7%A1%AE%E5%9C%B0%E6%8F%8F%E8%BF%B0%E9%97%AE%E9%A2%98%E5%B9%B6%E8%A8%80%E4%B9%8B%E6%9C%89%E7%89%A9">精确地描述问题并言之有物</a></li><li><a href="#%E8%AF%9D%E4%B8%8D%E5%9C%A8%E5%A4%9A%E8%80%8C%E5%9C%A8%E7%B2%BE">话不在多而在精</a></li><li><a href="#%E5%88%AB%E5%8A%A8%E8%BE%84%E5%A3%B0%E7%A7%B0%E6%89%BE%E5%88%B0-bug">别动辄声称找到 Bug</a></li><li><a href="#%E4%BD%8E%E5%A3%B0%E4%B8%8B%E6%B0%94%E4%B8%8D%E8%83%BD%E4%BB%A3%E6%9B%BF%E4%BD%A0%E7%9A%84%E5%8A%9F%E8%AF%BE">低声下气不能代替你的功课</a></li><li><a href="#%E6%8F%8F%E8%BF%B0%E9%97%AE%E9%A2%98%E7%97%87%E7%8A%B6%E8%80%8C%E9%9D%9E%E4%BD%A0%E7%9A%84%E7%8C%9C%E6%B5%8B">描述问题症状而非你的猜测</a></li><li><a href="#%E6%8C%89%E5%8F%91%E7%94%9F%E6%97%B6%E9%97%B4%E5%85%88%E5%90%8E%E5%88%97%E5%87%BA%E9%97%AE%E9%A2%98%E7%97%87%E7%8A%B6">按发生时间先后列出问题症状</a></li><li><a href="#%E6%8F%8F%E8%BF%B0%E7%9B%AE%E6%A0%87%E8%80%8C%E4%B8%8D%E6%98%AF%E8%BF%87%E7%A8%8B">描述目标而不是过程</a></li><li><a href="#%E5%88%AB%E8%A6%81%E6%B1%82%E4%BD%BF%E7%94%A8%E7%A7%81%E4%BA%BA%E7%94%B5%E9%82%AE%E5%9B%9E%E5%A4%8D">别要求使用私人电邮回复</a></li><li><a href="#%E6%B8%85%E6%A5%9A%E6%98%8E%E7%A1%AE%E7%9A%84%E8%A1%A8%E8%BE%BE%E4%BD%A0%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E9%9C%80%E6%B1%82">清楚明确的表达你的问题以及需求</a></li><li><a href="#%E8%AF%A2%E9%97%AE%E6%9C%89%E5%85%B3%E4%BB%A3%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98%E6%97%B6">询问有关代码的问题时</a></li><li><a href="#%E5%88%AB%E6%8A%8A%E8%87%AA%E5%B7%B1%E5%AE%B6%E5%BA%AD%E4%BD%9C%E4%B8%9A%E7%9A%84%E9%97%AE%E9%A2%98%E8%B4%B4%E4%B8%8A%E6%9D%A5">别把自己家庭作业的问题贴上来</a></li><li><a href="#%E5%8E%BB%E6%8E%89%E6%97%A0%E6%84%8F%E4%B9%89%E7%9A%84%E6%8F%90%E9%97%AE%E5%8F%A5">去掉无意义的提问句</a></li><li><a href="#%E5%8D%B3%E4%BD%BF%E4%BD%A0%E5%BE%88%E6%80%A5%E4%B9%9F%E4%B8%8D%E8%A6%81%E5%9C%A8%E6%A0%87%E9%A2%98%E5%86%99%E7%B4%A7%E6%80%A5">即使你很急也不要在标题写紧急</a></li><li><a href="#%E7%A4%BC%E5%A4%9A%E4%BA%BA%E4%B8%8D%E6%80%AA%E8%80%8C%E4%B8%94%E6%9C%89%E6%97%B6%E8%BF%98%E5%BE%88%E6%9C%89%E5%B8%AE%E5%8A%A9">礼多人不怪，而且有时还很有帮助</a></li><li><a href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%90%8E%E5%8A%A0%E4%B8%AA%E7%AE%80%E7%9F%AD%E7%9A%84%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E">问题解决后，加个简短的补充说明</a></li></ul></li><li><a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E8%AF%BB%E7%AD%94%E6%A1%88">如何解读答案</a><ul><li><a href="#rtfm-%E5%92%8C-stfw%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E4%BD%A0%E5%B7%B2%E5%AE%8C%E5%85%A8%E6%90%9E%E7%A0%B8%E4%BA%86">RTFM 和 STFW：如何知道你已完全搞砸了</a></li><li><a href="#%E5%A6%82%E6%9E%9C%E8%BF%98%E6%98%AF%E6%90%9E%E4%B8%8D%E6%87%82">如果还是搞不懂</a></li><li><a href="#%E5%A4%84%E7%90%86%E6%97%A0%E7%A4%BC%E7%9A%84%E5%9B%9E%E5%BA%94">处理无礼的回应</a></li></ul></li><li><a href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%89%AE%E6%BC%94%E5%A4%B1%E8%B4%A5%E8%80%85">如何避免扮演失败者</a></li><li><a href="#%E4%B8%8D%E8%AF%A5%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98">不该问的问题</a></li><li><a href="#%E5%A5%BD%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A0%A2%E9%97%AE%E9%A2%98">好问题与蠢问题</a></li><li><a href="#%E5%A6%82%E6%9E%9C%E5%BE%97%E4%B8%8D%E5%88%B0%E5%9B%9E%E7%AD%94">如果得不到回答</a></li><li><a href="#%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E5%9C%B0%E5%9B%9E%E7%AD%94%E9%97%AE%E9%A2%98">如何更好地回答问题</a></li><li><a href="#%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90">相关资源</a></li><li><a href="#%E9%B8%A3%E8%B0%A2">鸣谢</a></li></ul><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>许多项目在他们的使用协助/说明网页中链接了本指南，这么做很好，我们也鼓励大家都这么做。但如果你是负责管理这个项目网页的人，请在超链接附近的显著位置上注明：</p><p><strong>本指南不提供此项目的实际支持服务！</strong></p><p>我们已经深刻领教到少了上述声明所带来的痛苦。因为少了这点声明，我们不停地被一些白痴纠缠。这些白痴认为既然我们发布了这本指南，那么我们就有责任解决世上所有的技术问题。</p><p>如果你是因为需要某些协助而正在阅读这本指南，并且最后离开是因为发现从本指南作者们身上得不到直接的协助，那么你就是我们所说的那些白痴之一。别问我们问题，我们只会忽略你。我们在这本指南中是教你如何从那些真正懂得你所遇到软件或硬件问题的人取得协助，而 99% 的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在<a href="http://www.catb.org/~esr/faqs/hacker-howto.html">黑客</a>的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确的提问以获得你满意的答案。</p><p>不只是黑客，现在开源（Open Source）软件已经相当盛行，你常常也可以由其他有经验的使用者身上得到好答案，这是件<strong>好事</strong>；使用者比起黑客来，往往对那些新手常遇到的问题更宽容一些。然而，将有经验的使用者视为黑客，并采用本指南所提的方法与他们沟通，同样也是能从他们身上得到满意回答的最有效方式。</p><p>首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发他们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，”好问题！”是诚挚的大力称赞。</p><p>尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。</p><p>我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 —— 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 <code>失败者（撸瑟）</code> （由于历史原因，我们有时把它拼作 <code>lusers</code>）。</p><p>我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们了解这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们回答问题的风格是指向那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就是在降低做自己最擅长的事情上的效率。</p><p>我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答<code>赢家（winner）</code>的问题。</p><p>如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 —— 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。</p><p>所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 – 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。</p><p>如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 – 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。</p><p>（欢迎对本指南提出改进意见。你可以 email 你的建议至 <a href="esr@thyrsus.com">esr@thyrsus.com</a> 或 <a href="respond-auto@linuxmafia.com">respond-auto@linuxmafia.com</a>。然而请注意，本文并非<a href="http://www.ietf.org/rfc/rfc1855.txt">网络礼节</a>的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议）。</p><h2 id="在提问之前"><a href="#在提问之前" class="headerlink" title="在提问之前"></a>在提问之前</h2><p>在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：</p><ol><li>尝试在你准备提问的论坛的旧文章中搜索答案。</li><li>尝试上网搜索以找到答案。</li><li>尝试阅读手册以找到答案。</li><li>尝试阅读常见问题文件（FAQ）以找到答案。</li><li>尝试自己检查或试验以找到答案。</li><li>向你身边的强者朋友打听以找到答案。</li><li>如果你是程序开发者，请尝试阅读源代码以找到答案。</li></ol><p>当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所<strong>学到</strong>的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。</p><p>运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（既搜索 <a href="http://groups.google.com/">Google 论坛</a>，也搜索网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 <code>我在 Google 中搜过下列句子但没有找到什么有用的东西</code> 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。</p><p>别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。</p><p>准备好你的问题，再将问题仔细的思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。</p><p>小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着<code>蠢问题…</code>， 一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。</p><p>绝不要自以为<strong>够格</strong>得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去<strong>挣到</strong>一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 —— 一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。</p><p>另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。<code>谁能给点提示？</code>、<code>我的这个例子里缺了什么？</code>以及<code>我应该检查什么地方</code>比<code>请把我需要的确切的过程贴出来</code>更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。</p><h2 id="当你提问时"><a href="#当你提问时" class="headerlink" title="当你提问时"></a>当你提问时</h2><h3 id="慎选提问的论坛"><a href="#慎选提问的论坛" class="headerlink" title="慎选提问的论坛"></a>慎选提问的论坛</h3><p>小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：</p><ul><li>在与主题不合的论坛上贴出你的问题。</li><li>在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。</li><li>在太多的不同新闻群组上重复转贴同样的问题（cross-post）。</li><li>向既非熟人也没有义务解决你问题的人发送私人电邮。</li></ul><p>黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。</p><p>因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括<strong>阅读</strong> FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。</p><p>向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 – 如果你不确定，那就向别处发送，或者压根别发。</p><p>在选择论坛、新闻群组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。</p><p>别像机关枪似的一次”扫射”所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。</p><p>搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。</p><p>一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。</p><p>可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 —— 已经好几次了，一些热门软件的作者从自己软件的支持中抽身出来，因为伴随而来涌入其私人邮箱的无用邮件变得无法忍受。</p><h3 id="Stack-Overflow"><a href="#Stack-Overflow" class="headerlink" title="Stack Overflow"></a>Stack Overflow</h3><p>搜索，<strong>然后</strong> 在 Stack Exchange 问。</p><p>近年来，Stack Exchange community 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。</p><p>因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的机率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。</p><p>Stack Exchange 已经成长到<a href="http://stackexchange.com/sites">超过一百个网站</a>，以下是最常用的几个站：</p><ul><li>Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。</li><li>Stack Overflow 是问写程序有关的问题。</li><li>Server Fault 是问服务器和网管相关的问题。</li></ul><h3 id="网站和-IRC-论坛"><a href="#网站和-IRC-论坛" class="headerlink" title="网站和 IRC 论坛"></a>网站和 IRC 论坛</h3><p>本地的使用者群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表）， 这些地方是开始提问的好首选，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。</p><p>事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复 “用<strong>我们的</strong>版本”。</p><p>在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。</p><p>通过论坛或 IRC 频道来提供使用者支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。</p><p>在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。</p><h3 id="第二步，使用项目邮件列表"><a href="#第二步，使用项目邮件列表" class="headerlink" title="第二步，使用项目邮件列表"></a>第二步，使用项目邮件列表</h3><p>当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：</p><ul><li>任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。</li><li>向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。</li><li>大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。</li><li>如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。</li></ul><p>如果一个项目既有”使用者” 也有”开发者”（或”黑客”）邮件列表或论坛，而你又不会动到那些源代码，那么就向”使用者”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。</p><p>然而，如果你<strong>确信</strong>你的问题很特别，而且在”使用者” 列表或论坛中几天都没有回复，可以试试前往”开发者”列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意）</p><p>如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。</p><h3 id="使用有意义且描述明确的标题"><a href="#使用有意义且描述明确的标题" class="headerlink" title="使用有意义且描述明确的标题"></a>使用有意义且描述明确的标题</h3><p>在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的<code>帮帮忙</code>、<code>跪求</code>、<code>急</code>（更别说<code>救命啊！！！！</code>这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。</p><p>一个好标题范例是<code>目标 —— 差异</code>式的描述，许多技术支持组织就是这样做的。在<code>目标</code>部分指出是哪一个或哪一组东西有问题，在<code>差异</code>部分则描述与期望的行为不一致的地方。</p><blockquote><p>蠢问题：救命啊！我的笔记本电脑不能正常显示了！</p></blockquote><blockquote><p>聪明问题：X.org 6.8.1 的鼠标光标会变形，某牌显卡 MV1005 芯片组。</p></blockquote><blockquote><p>更聪明问题：X.org 6.8.1 的鼠标光标，在某牌显卡 MV1005 芯片组环境下 - 会变形。</p></blockquote><p>编写<code>目标 —— 差异</code> 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标光标或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境<strong>和</strong>你遇到的问题。</p><p>总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。</p><p>如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 <code>Re: 测试</code> 或者 <code>Re: 新 bug</code> 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。</p><p>对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许使用者按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。</p><p>仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。</p><p>在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你<strong>只想</strong>在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。</p><h3 id="使问题容易回复"><a href="#使问题容易回复" class="headerlink" title="使问题容易回复"></a>使问题容易回复</h3><p>以<code>请将你的回复发送到……</code>来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，<a href="http://linuxmafia.com/faq/Mail/muas.html">换个好点的</a>；如果是操作系统不支持这种邮件程序，也换个好点的。</p><p>在论坛，要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感（有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如<code>追踪此讨论串</code>、<code>有回复时发送邮件提醒</code>等功能。</p><h3 id="用清晰、正确、精准并语法正确的语句"><a href="#用清晰、正确、精准并语法正确的语句" class="headerlink" title="用清晰、正确、精准并语法正确的语句"></a>用清晰、正确、精准并语法正确的语句</h3><p>我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。</p><p>正确的拼写、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 —— 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它<strong>必须很</strong>准确，而且有迹象表明你是在思考和关注问题。</p><p>正确地拼写、使用标点和大小写，不要将<code>its</code>混淆为<code>it&#39;s</code>，<code>loose</code>搞成<code>lose</code>或者将<code>discrete</code>弄成<code>discreet</code>。不要<strong>全部用大写</strong>，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。<a href="http://en.wikipedia.org/wiki/Alan_Cox">Alan Cox</a> 也许可以这样做，但你不行）。</p><p>更白话的说，如果你写得像是个半文盲[译注：<a href="http://zh.wikipedia.org/wiki/%E5%B0%8F%E7%99%BD">小白</a>]，那多半得不到理睬。也不要使用即时通信中的简写或<a href="http://zh.wikipedia.org/wiki/%E7%81%AB%E6%98%9F%E6%96%87">火星文</a>，如将<code>的</code>简化为<code>d</code>会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。</p><p>如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。</p><p>如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：<br>[译注：以下附上原文以供使用]</p><blockquote><p>English is not my native language; please excuse typing errors.</p></blockquote><ul><li>英文不是我的母语，请原谅我的错字或语法。</li></ul><blockquote><p>If you speak $LANGUAGE, please email/PM me;<br>I may need assistance translating my question.</p></blockquote><ul><li>如果你说<strong>某语言</strong>，请寄信/私讯给我；我需要有人协助我翻译我的问题。</li></ul><blockquote><p>I am familiar with the technical terms,<br>but some slang expressions and idioms are difficult for me.</p></blockquote><ul><li>我对技术名词很熟悉，但对于俗语或是特别用法比较不甚了解。</li></ul><blockquote><p>I’ve posted my question in $LANGUAGE and English.<br>I’ll be glad to translate responses, if you only use one or the other.</p></blockquote><ul><li>我把我的问题用<strong>某语言</strong>和英文写出来，如果你只用一种语言回答，我会乐意将其翻译成另一种。</li></ul><h3 id="使用易于读取且标准的文件格式发送问题"><a href="#使用易于读取且标准的文件格式发送问题" class="headerlink" title="使用易于读取且标准的文件格式发送问题"></a>使用易于读取且标准的文件格式发送问题</h3><p>如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：</p><ul><li>使用纯文字而不是 HTML (<a href="http://archive.birdhouse.org/etc/evilmail.html">关闭 HTML</a> 并不难）。</li><li>使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。</li><li>不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。</li><li>但是，对一些特殊的文件<strong>不要</strong>设置固定宽度（譬如日志档案拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。</li><li>在英语论坛中，不要使用<code>Quoted-Printable</code> MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的<code>=20</code>符号既难看也分散注意力，甚至有可能破坏内容的语意。</li><li>绝对，<strong>永远</strong>不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。</li><li>如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的<code>智能引号</code>功能 （从[选项] &gt; [校订] &gt; [自动校正选项]，勾选掉<code>智能引号</code>单选框），以免在你的邮件中到处散布垃圾字符。</li><li>在论坛，勿滥用<code>表情符号</code>和<code>HTML</code>功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。</li></ul><p>如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的<code>查看源代码</code>命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。</p><h3 id="精确地描述问题并言之有物"><a href="#精确地描述问题并言之有物" class="headerlink" title="精确地描述问题并言之有物"></a>精确地描述问题并言之有物</h3><ul><li>仔细、清楚地描述你的问题或 Bug 的症状。</li><li>描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：<code>Fedora Core 4</code>、<code>Slackware 9.1</code>等）。</li><li>描述在提问前你是怎样去研究和理解这个问题的。</li><li>描述在提问前为确定问题而采取的诊断步骤。</li><li>描述最近做过什么可能相关的硬件或软件变更。</li><li>尽可能的提供一个可以<code>重现这个问题的可控环境</code>的方法。</li></ul><p>尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能遇到的问题回答一遍。</p><p>以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。</p><p><a href="http://www.chiark.greenend.org.uk/~sgtatham/">Simon Tatham</a> 写过一篇名为《<a href="http://www.chiark.greenend.org.uk/~sgtatham/bugs-cn.html">如何有效的报告 Bug</a>》的出色文章。强力推荐你也读一读。</p><h3 id="话不在多而在精"><a href="#话不在多而在精" class="headerlink" title="话不在多而在精"></a>话不在多而在精</h3><p>你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。</p><p>这样做的用处至少有三点。<br>第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；<br>第二，简化问题使你更有可能得到<strong>有用</strong>的答案；<br>第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。</p><h3 id="别动辄声称找到-Bug"><a href="#别动辄声称找到-Bug" class="headerlink" title="别动辄声称找到 Bug"></a>别动辄声称找到 Bug</h3><p>当你在使用软件中遇到问题，除非你非常、<strong>非常</strong>的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的<code>Bug</code>，你应该能提供相应位置的修正或替代文件。</p><p>请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前<a href="#%E5%9C%A8%E6%8F%90%E9%97%AE%E4%B9%8B%E5%89%8D">已经做了这些，是吧</a>？）。这也意味着很有可能是你弄错了而不是软件本身有问题。</p><p>编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有<code>Bug</code>时，这尤其严重。</p><p>提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是<strong>你</strong>做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。</p><h3 id="低声下气不能代替你的功课"><a href="#低声下气不能代替你的功课" class="headerlink" title="低声下气不能代替你的功课"></a>低声下气不能代替你的功课</h3><p>有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 —— 低声下气：<code>我知道我只是个可悲的新手，一个撸瑟，但...</code>。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。</p><p>别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。</p><p>有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。</p><h3 id="描述问题症状而非你的猜测"><a href="#描述问题症状而非你的猜测" class="headerlink" title="描述问题症状而非你的猜测"></a>描述问题症状而非你的猜测</h3><p>告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。</p><p><strong>蠢问题</strong></p><blockquote><p>我在编译内核时接连遇到 SIG11 错误，<br>我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组），<br>256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误，<br>但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。<br>所有内存都换过了，没有效果。相关部分的标准编译记录如下…。</p></blockquote><p>由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：<code>所有的诊断专家都来自密苏里州。</code> 美国国务院的官方座右铭则是：<code>让我看看</code>（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：<code>我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。</code>） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我们看吧！</p><h3 id="按发生时间先后列出问题症状"><a href="#按发生时间先后列出问题症状" class="headerlink" title="按发生时间先后列出问题症状"></a>按发生时间先后列出问题症状</h3><p>问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。</p><p>如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，<code>多</code>不等于<code>好</code>。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。</p><p>如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。</p><h3 id="描述目标而不是过程"><a href="#描述目标而不是过程" class="headerlink" title="描述目标而不是过程"></a>描述目标而不是过程</h3><p>如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。</p><p>经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。</p><p><strong>蠢问题</strong></p><blockquote><p>我怎样才能从某绘图程序的颜色选择器中取得十六进制的的 RGB 值？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot），<br>但却无法从某绘图程序的颜色选择器取得十六进制的的 RGB 值。</p></blockquote><p>第二种提问法比较聪明，你可能得到像是<code>建议采用另一个更合适的工具</code>的回复。</p><h3 id="别要求使用私人电邮回复"><a href="#别要求使用私人电邮回复" class="headerlink" title="别要求使用私人电邮回复"></a>别要求使用私人电邮回复</h3><p>黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。</p><p>当你要求私下回复时，这个过程和奖励都被中止。别这样做，让<strong>回复者</strong>来决定是否私下回答 —— 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人没有兴趣。</p><p>这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是<code>向我发电邮，我将为论坛归纳这些回复</code>。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 —— 但你必须信守诺言。</p><h3 id="清楚明确的表达你的问题以及需求"><a href="#清楚明确的表达你的问题以及需求" class="headerlink" title="清楚明确的表达你的问题以及需求"></a>清楚明确的表达你的问题以及需求</h3><p>漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。</p><p>如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。</p><p>要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。</p><p>所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你有用答案相当有帮助 —— 但这技巧通常和简化问题有所区别。因此，问<code>我想更好的理解 X，可否指点一下哪有好一点说明？</code>通常比问<code>你能解释一下 X 吗？</code>更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。</p><h3 id="询问有关代码的问题时"><a href="#询问有关代码的问题时" class="headerlink" title="询问有关代码的问题时"></a>询问有关代码的问题时</h3><p>别要求他人帮你调试有问题的代码，不提示一下应该从何入手。张贴几百行的代码，然后说一声：<code>它不能工作</code>会让你完全被忽略。只贴几十行代码，然后说一句：<code>在第七行以后，我期待它显示 &lt;x&gt;，但实际出现的是 &lt;y&gt;</code>比较有可能让你得到回应。</p><p>最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能<strong>刚好</strong>展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译/直译/被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看<a href="#%E8%AF%9D%E4%B8%8D%E5%9C%A8%E5%A4%9A%E8%80%8C%E5%9C%A8%E7%B2%BE">话不在多而在精</a>一节）。</p><p>一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做的是种好习惯。这种方式可以帮助你了解如何自行解决这个问题 —— 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。</p><p>如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。</p><h3 id="别把自己家庭作业的问题贴上来"><a href="#别把自己家庭作业的问题贴上来" class="headerlink" title="别把自己家庭作业的问题贴上来"></a>别把自己家庭作业的问题贴上来</h3><p>黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由<strong>你</strong>来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。</p><p>如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在使用者群组，论坛或（最后一招）在项目的<strong>使用者</strong>邮件列表或论坛中提问。尽管黑客们<strong>会</strong>看出来，但一些有经验的使用者也许仍会给你一些提示。</p><h3 id="去掉无意义的提问句"><a href="#去掉无意义的提问句" class="headerlink" title="去掉无意义的提问句"></a>去掉无意义的提问句</h3><p>避免用无意义的话结束提问，例如<code>有人能帮我吗？</code>或者<code>这有答案吗？</code>。</p><p>首先：如果你对问题的描述不是很好，这样问更是画蛇添足。</p><p>其次：由于这样问是画蛇添足，黑客们会很厌烦你 —— 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：<code>没错，有人能帮你</code>或者<code>不，没答案</code>。</p><p>一般来说，避免用 <code>是或否</code>、<code>对或错</code>、<code>有或没有</code>类型的问句，除非你想得到<a href="http://homepage.ntlworld.com./jonathan.deboynepollard/FGA/questions-with-yes-or-no-answers.html">是或否类型的回答</a>。</p><h3 id="即使你很急也不要在标题写紧急"><a href="#即使你很急也不要在标题写紧急" class="headerlink" title="即使你很急也不要在标题写紧急"></a>即使你很急也不要在标题写<code>紧急</code></h3><p>这是你的问题，不是我们的。宣称<code>紧急</code>极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，<code>紧急</code>这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 —— 你希望能看到你问题的人可能永远也看不到。</p><p>有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。</p><p>当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如<code>紧急：帮我救救这个毛绒绒的小海豹！</code>肯定让你被黑客忽略或惹恼他们，即使他们认为毛绒绒的小海豹很重要。</p><p>如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。</p><h3 id="礼多人不怪，而且有时还很有帮助"><a href="#礼多人不怪，而且有时还很有帮助" class="headerlink" title="礼多人不怪，而且有时还很有帮助"></a>礼多人不怪，而且有时还很有帮助</h3><p>彬彬有礼，多用<code>请</code>和<code>谢谢您的关注</code>，或<code>谢谢你的关照</code>。让大家都知道你对他们花时间免费提供帮助心存感激。</p><p>坦白说，这一点并没有比清晰、正确、精准并合法语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的）</p><p>然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。</p><p>（我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得<code>先谢了</code>意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说<code>先谢了</code>，<strong>然后</strong>事后再对回复者表示感谢，或者换种方式表达感激，譬如用<code>谢谢你的关注</code>或<code>谢谢你的关照</code>。）</p><h3 id="问题解决后，加个简短的补充说明"><a href="#问题解决后，加个简短的补充说明" class="headerlink" title="问题解决后，加个简短的补充说明"></a>问题解决后，加个简短的补充说明</h3><p>问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。</p><p>最理想的方式是向最初提问的话题回复此消息，并在标题中包含<code>已修正</code>，<code>已解决</code>或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串<code>问题 X</code>和<code>问题 X - 已解决</code>的潜在回复者就明白不用再浪费时间了（除非他个人觉得<code>问题 X</code>的有趣），因此可以利用此时间去解决其它问题。</p><p>补充说明不必很长或是很深入；简单的一句<code>你好，原来是网线出了问题！谢谢大家 – Bill</code>比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。</p><p>对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此<strong>之后</strong>才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。</p><p>除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表/新闻群组/论坛中搜索到真正解决你问题的方案，让他们也从中受益。</p><p>至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。</p><p>思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。</p><p>在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。</p><h2 id="如何解读答案"><a href="#如何解读答案" class="headerlink" title="如何解读答案"></a>如何解读答案</h2><p><a id="RTFM"></a></p><h3 id="RTFM-和-STFW：如何知道你已完全搞砸了"><a href="#RTFM-和-STFW：如何知道你已完全搞砸了" class="headerlink" title="RTFM 和 STFW：如何知道你已完全搞砸了"></a>RTFM 和 STFW：如何知道你已完全搞砸了</h3><p>有一个古老而神圣的传统：如果你收到<code>RTFM （Read The Fucking Manual）</code>的回应，回答者认为你<strong>应该去读他妈的手册</strong>。当然，基本上他是对的，你应该去读一读。</p><p>RTFM 有一个年轻的亲戚。如果你收到<code>STFW（Search The Fucking Web）</code>的回应，回答者认为你<strong>应该到他妈的网上搜索</strong>。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 **<a href="http://lmgtfy.com/">Google 是你的朋友</a>**！）</p><p>在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。</p><p>通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为</p><ul><li><strong>你需要的信息非常容易获得</strong>；</li><li><strong>你自己去搜索这些信息比灌给你，能让你学到更多</strong>。</li></ul><p>你不应该因此不爽；<strong>依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见</strong>。你应该对他祖母般的慈祥表示感谢。</p><h3 id="如果还是搞不懂"><a href="#如果还是搞不懂" class="headerlink" title="如果还是搞不懂"></a>如果还是搞不懂</h3><p>如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。</p><p>比方说，如果我回答你：<code>看来似乎是 zentry 卡住了；你应该先清除它。</code>，然后，这是一个<strong>很糟的</strong>后续问题回应：<code>zentry 是什么？</code> <strong>好</strong>的问法应该是这样：<code>哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？</code></p><h3 id="处理无礼的回应"><a href="#处理无礼的回应" class="headerlink" title="处理无礼的回应"></a>处理无礼的回应</h3><p>很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。</p><p>如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这<strong>没有</strong>发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而<strong>你</strong>将被视为有错的一方，这将伤害到你获取信息或帮助的机会。</p><p>另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。</p><p>（有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会<strong>正常</strong>交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们<strong>喜欢</strong>我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑）。</p><p>Jeff Bigler 的观察总结和这个相关也值得一读 (<strong><a href="http://www.mit.edu/~jcb/tact.html">tact filters</a></strong>)。</p><p>在下一节，我们会谈到另一个问题，当<strong>你</strong>行为不当时所会受到的<code>冒犯</code>。</p><h2 id="如何避免扮演失败者"><a href="#如何避免扮演失败者" class="headerlink" title="如何避免扮演失败者"></a>如何避免扮演失败者</h2><p>在黑客社区的论坛中有那么几次你可能会搞砸 —— 以本指南所描述到的或类似的方式。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。</p><p>这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反地，你该这么做：</p><p>熬过去，这很正常。事实上，它是有益健康且合理的。</p><p>社区的标准不会自行维持，它们是通过参与者积极而<strong>公开地</strong>执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。</p><p>也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称<code>如果你不想帮助用户就闭嘴。</code> 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。</p><p>夸张的讲法是：你要的是“友善”（以上述方式）还是有用？两个里面挑一个。</p><p>记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心<strong>你</strong>和<strong>他的社区</strong>而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。</p><p>有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是<strong>真的</strong>会把问题搞砸。</p><p>这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。</p><p>也别让自己卷入口水战，最好不要理睬大多数的口水战 – 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。</p><h2 id="不该问的问题"><a href="#不该问的问题" class="headerlink" title="不该问的问题"></a>不该问的问题</h2><p>以下是几个经典蠢问题，以及黑客没回答时心中所想的：</p><p>问题：<a href="#q1">我能在哪找到 X 程序或 X 资源？</a></p><p>问题：<a href="#q2">我怎样用 X 做 Y？</a></p><p>问题：<a href="#q3">如何设定我的 shell 提示？</a></p><p>问题：<a href="#q4">我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</a></p><p>问题：<a href="#q5">我的程序/设定/SQL 语句没有用</a></p><p>问题：<a href="#q6">我的 Windows 电脑有问题，你能帮我吗？</a></p><p>问题：<a href="#q7">我的程序不会动了，我认为系统工具 X 有问题</a></p><p>问题：<a href="#q8">我在安装 Linux（或者 X ）时有问题，你能帮我吗？</a></p><p>问题：<a href="#q9">我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</a></p><hr><p><a id="q1"></a></p><blockquote><p>问题：我能在哪找到 X 程序或 X 资源？</p></blockquote><p>回答：就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 <a href="http://www.google.com/">Google</a> 吗？</p><p><a id="q2"></a></p><blockquote><p>问题：我怎样用 X 做 Y？</p></blockquote><p>回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。</p><p><a id="q3"></a></p><blockquote><p>问题：如何设定我的 shell 提示？？</p></blockquote><p>回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 <a href="#RTFM">RTFM</a>，然后自己去找出来。</p><p><a id="q4"></a></p><blockquote><p>问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</p></blockquote><p>回答：试试看就知道了。如果你试过，你既知道了答案，就不用浪费我的时间了。</p><p><a id="q5"></a></p><blockquote><p>问题：我的{程序/设定/SQL 语句}不工作</p></blockquote><p>回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 —— 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种</p><ul><li>你还有什么要补充的吗？</li><li>真糟糕，希望你能搞定。</li><li>这关我有什么屁事？</li></ul><p><a id="q6"></a></p><blockquote><p>问题：我的 Windows 电脑有问题，你能帮我吗？</p></blockquote><p>回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧。</p><p>注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你<strong>可以</strong>问与 Windows 相关的问题， 只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。</p><p><a id="q7"></a></p><blockquote><p>问题：我的程序不会动了，我认为系统工具 X 有问题</p></blockquote><p>回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库档案有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。</p><p><a id="q8"></a></p><blockquote><p>问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？</p></blockquote><p>回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在<a href="http://www.linux.org/groups/index.html">这儿</a>找到使用者群组的清单）。</p><p>注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地使用者群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 <code>Linux</code> 和<strong>所有</strong>被怀疑的硬件作关键词仔细搜索。</p><p><a id="q9"></a></p><blockquote><p>问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</p></blockquote><p>回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！</p><h2 id="好问题与蠢问题"><a href="#好问题与蠢问题" class="headerlink" title="好问题与蠢问题"></a>好问题与蠢问题</h2><p>最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我可以在哪儿找到关于 Foonly Flurbamatic 的资料？</p></blockquote><p>这种问法无非想得到 <a href="#RTFM">STFW</a> 这样的回答。</p><p><strong>聪明问题</strong>：</p><blockquote><p>我用 Google 搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？</p></blockquote><p>这个问题已经 STFW 过了，看起来他真的遇到了麻烦。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我从 foo 项目找来的源码没法编译。它怎么这么烂？</p></blockquote><p>他觉得都是别人的错，这个傲慢自大的提问者。</p><p><strong>聪明问题</strong>：</p><blockquote><p>foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？</p></blockquote><p>提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我的主机板有问题了，谁来帮我？</p></blockquote><p>某黑客对这类问题的回答通常是：<code>好的，还要帮你拍拍背和换尿布吗？</code>，然后按下删除键。</p><p><strong>聪明问题</strong>：</p><blockquote><p>我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？</p></blockquote><p>这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。</p><p>在最后一个问题中，注意<code>告诉我答案</code>和<code>给我启示，指出我还应该做什么诊断工作</code>之间微妙而又重要的区别。</p><p>事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。</p><p>通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。</p><p>事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候， 一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的<strong>名</strong>人，而是因为我用了正确的方式来提问。</p><p>黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我<strong>像</strong>个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。</p><h2 id="如果得不到回答"><a href="#如果得不到回答" class="headerlink" title="如果得不到回答"></a>如果得不到回答</h2><p>如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。</p><p>总的来说，简单的重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。</p><p>你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。</p><p>有许多网上的以及本地的使用者群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。</p><p>另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了 —— 完全可能如此 —— 你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。</p><p>对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名使用者。根本不可能由一个人来处理来自上万名使用者的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开源软件的要高得多，且内容也没那么丰富）。</p><h2 id="如何更好地回答问题"><a href="#如何更好地回答问题" class="headerlink" title="如何更好地回答问题"></a>如何更好地回答问题</h2><p><strong>态度和善一点</strong>。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p><p><strong>对初犯者私下回复</strong>。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。</p><p><strong>如果你不确定，一定要说出来</strong>！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p><p><strong>如果帮不了忙，也别妨碍他</strong>。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 —— 有些可怜的呆瓜会把它当成真的指令。</p><p><strong>试探性的反问以引出更多的细节</strong>。如果你做得好，提问者可以学到点东西 —— 你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。</p><p>尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。</p><p><strong>如果你决定回答，就请给出好的答案</strong>。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（wordaround），应推荐更好的工具，重新界定问题。</p><p><strong>正面的回答问题</strong>！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 <code>试试看 A 或是 B</code> 或者 <code>试试 X 、 Y 、 Z 、 A 、 B 、 C</code> 并附上一个链接一点用都没有。</p><p><strong>帮助你的社区从问题中学习</strong>。当回复一个好问题时，问问自己<code>如何修改相关文件或常见问题文件以免再次解答同样的问题？</code>，接着再向文件维护者发一份补丁。</p><p>如果你是在研究一番后才做出的回答，<strong>展现你的技巧而不是直接端出结果</strong>。毕竟<code>授人以鱼不如授人以渔</code>。</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><p>如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅 <a href="http://en.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/">Unix 系统和网络基本原理</a>。</p><p>当你发布软件或补丁时，试着按<a href="http://en.tldp.org/HOWTO/Software-Release-Practice-HOWTO/index.html">软件发布实践</a>操作。</p><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p>Evelyn Mitchel 贡献了一些愚蠢问题例子并启发了编写<code>如何更好地回答问题</code>这一节， Mikhail Ramendik 贡献了一些特别有价值的建议和改进。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用VS Code编写LaTex</title>
      <link href="2020/03/25/VS-Code-with-LaTex/"/>
      <url>2020/03/25/VS-Code-with-LaTex/</url>
      
        <content type="html"><![CDATA[<p>对于如何安装TexLive，可以参考这篇文档<br>[post cid=”96” /]</p><h2 id="安装VS-Code"><a href="#安装VS-Code" class="headerlink" title="安装VS Code"></a>安装VS Code</h2><p><a href="https://code.visualstudio.com/">官方地址</a></p><h2 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h2><p>market搜索<code>LaTeX Workshop</code></p><a id="more"></a><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>在VS Code的<code>seeting.json</code>添加以下内容</p><p>!&gt; 这里的<strong>tools</strong>部分，可以自定义编译选项，如果有报错，根据自己的提示修改下边<strong>args</strong>里边的参数。</p><p>[collapse status=”false” title=”setting.json”]</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;latex-workshop.latex.tools&quot;: [                &#123;            &quot;name&quot;: &quot;xelatex&quot;,            &quot;command&quot;: &quot;xelatex&quot;,            &quot;args&quot;: [              &quot;-synctex&#x3D;1&quot;,               &quot;-interaction&#x3D;nonstopmode&quot;,              &quot;-shell-escape&quot;,              &quot;%DOC%&quot;            ]        &#125;,         &#123;            &quot;name&quot;: &quot;bibtex&quot;,            &quot;command&quot;: &quot;bibtex&quot;,            &quot;args&quot;: [                &quot;%DOCFILE%&quot;            ]        &#125;    ],    &quot;latex-workshop.latex.recipes&quot;: [        &#123;          &quot;name&quot;: &quot;xelatex&quot;,          &quot;tools&quot;: [            &quot;xelatex&quot;          ]        &#125;,        &#123;          &quot;name&quot;: &quot;PDFLaTeX&quot;,          &quot;tools&quot;: [            &quot;pdflatex&quot;          ]        &#125;,        &#123;          &quot;name&quot;: &quot;latexmk&quot;,          &quot;tools&quot;: [            &quot;latexmk&quot;          ]        &#125;,        &#123;          &quot;name&quot;: &quot;bibtex&quot;,          &quot;tools&quot;: [            &quot;bibtex&quot;          ]        &#125;,        &#123;          &quot;name&quot;: &quot;pdflatex -&gt; bibtex -&gt; pdflatex*2&quot;,          &quot;tools&quot;: [            &quot;pdflatex&quot;,            &quot;bibtex&quot;,            &quot;pdflatex&quot;,            &quot;pdflatex&quot;          ]        &#125;,        &#123;          &quot;name&quot;: &quot;xelatex -&gt; bibtex -&gt; xelatex*2&quot;,          &quot;tools&quot;: [            &quot;xelatex&quot;,            &quot;bibtex&quot;,            &quot;xelatex&quot;,            &quot;xelatex&quot;          ]        &#125;    ],    &quot;latex-workshop.latex.clean.fileTypes&quot;: [      &quot;*.aux&quot;,      &quot;*.bbl&quot;,      &quot;*.blg&quot;,      &quot;*.idx&quot;,      &quot;*.ind&quot;,      &quot;*.lof&quot;,      &quot;*.lot&quot;,      &quot;*.out&quot;,      &quot;*.toc&quot;,      &quot;*.acn&quot;,      &quot;*.acr&quot;,      &quot;*.alg&quot;,      &quot;*.glg&quot;,      &quot;*.glo&quot;,      &quot;*.gls&quot;,      &quot;*.ist&quot;,      &quot;*.fls&quot;,      &quot;*.log&quot;,      &quot;*.fdb_latexmk&quot;,      &quot;*.gz&quot;    ],    &quot;latex-workshop.view.pdf.viewer&quot;: &quot;tab&quot;,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[/collapse]</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li><code>Ctrl+Alt+B</code>编译，<code>Ctrl+S</code>保存的时候也会自动编译。</li><li><code>Ctrl+Alt+V</code>，在右侧预览PDF文件（这个快捷键可能和你其他软件的快捷键冲突，博主的和为知笔记发生冲突了</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术博文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTex </tag>
            
            <tag> TexLive </tag>
            
            <tag> VS Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CenOS安装Texlive2019</title>
      <link href="2020/03/25/CenOS-install-Texlive2019/"/>
      <url>2020/03/25/CenOS-install-Texlive2019/</url>
      
        <content type="html"><![CDATA[<h2 id="安装Perl模块"><a href="#安装Perl模块" class="headerlink" title="安装Perl模块"></a>安装<code>Perl</code>模块</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install perl*yum install cpan<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><a id="more"></a><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ul><li>安装过程中需要调用Perl的模块 <code>Digest::MD5</code> 来检测 ISO 文件的完整性</li><li>升级过程中界面需要调用 Perl 的模块 <code>Tk</code></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install perl-Digest-MD5 perl-Tk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>到<a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet/">清华镜像源</a>下载安装包，并解压</p><ul><li>如果报错，可能需要安装<code>wget</code>和<code>unzip</code></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install wget #如果已有可以忽略yum install unzip #如果已有可以忽略wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;CTAN&#x2F;systems&#x2F;texlive&#x2F;tlnet&#x2F;install-tl.zipunzip install-tl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>自动安装</strong></p><p>打开解压好的目录，运行安装脚本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;install-tl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>出现选项后，输入 <code>I</code> 直接安装。</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>在<code>~/.bashrc</code>中添加类似如下部分，让系统识别tex的编译器、info手册以及manual手册的位置。</p><p>参考<a href="https://www.tug.org/texlive/doc/texlive-en/texlive-en.html#x1-310003.4.1">官方文档</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># TeXLive 2019PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;texlive&#x2F;2019&#x2F;bin&#x2F;x86_64-linux:$PATH; export PATHMANPATH&#x3D;&#x2F;usr&#x2F;local&#x2F;texlive&#x2F;2019&#x2F;texmf-dist&#x2F;doc&#x2F;man:$MANPATH; export MANPATHINFOPATH&#x3D;&#x2F;usr&#x2F;local&#x2F;texlive&#x2F;2019&#x2F;texmf-dist&#x2F;doc&#x2F;info:$INFOPATH; export INFOPATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后用source加载该文件内容到执行环境中</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">source .&#x2F;bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="测试安装是否成功"><a href="#测试安装是否成功" class="headerlink" title="测试安装是否成功"></a>测试安装是否成功</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tex --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>@&gt; 其他请参考：<a href="https://www.tug.org/texlive/doc/texlive-zh-cn/texlive-zh-cn.pdf">官方2019的中文文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> LaTex </tag>
            
            <tag> TexLive </tag>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PDF自动化添加书签目录</title>
      <link href="2020/03/23/PDF-auto-add-/"/>
      <url>2020/03/23/PDF-auto-add-/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h2><p>最近需要基本书的电子版，但是找来的PDF扫描版有些参差不齐，于是想起了之前在B乎上看到的一个PDF扫描加整理一条龙服务的回答，又回去翻看学习。</p><p>@&gt; 想把自己的书籍扫描成PDF，什么样的扫描仪比较合适？ - <a href="https://www.zhihu.com/question/46979886/answer/694324952">白垩纪的回答 </a></p><p>得到的PDF长这个样子。</p><ul><li>四周有黑边</li><li>纸张有些歪</li></ul><p><img src="https://img.zhuomu.xyz/view/img/2020/03/23/aKO7Nydl/Snipaste_2020-03-23_20-19-26.png" alt="Snipaste_2020-03-23_20-19-26" style="zoom: 50%;" /> <img src="https://img.zhuomu.xyz/view/img/2020/03/23/aKO7Nydl/Snipaste_2020-03-23_20-21-53.png" alt="Snipaste_2020-03-23_20-21-53" style="zoom: 50%;" /></p><h2 id="0x01-提取图片"><a href="#0x01-提取图片" class="headerlink" title="0x01 提取图片"></a>0x01 提取图片</h2><p>这里用到的是<code>PDF补丁丁</code>这个软件。</p><p>先对PDF的图片进行提取</p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/23/aKO7Nydl/Snipaste_2020-03-23_20-33-54.png" alt="Snipaste_2020-03-23_20-33-54"></p><p>按照图示，操作，为图片建一个<code>out</code>文件夹，其余默认即可，保存所有的图片，便于后续处理。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/23/aKO7Nydl/Snipaste_2020-03-23_20-39-41.png" alt="Snipaste_2020-03-23_20-39-41"></p><p>提取完成</p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/23/aKO7Nydl/Snipaste_2020-03-23_20-41-43.png" alt="Snipaste_2020-03-23_20-41-43"></p><h2 id="0x02-切边处理"><a href="#0x02-切边处理" class="headerlink" title="0x02 切边处理"></a>0x02 切边处理</h2><p>切边处理，使用<code>ComicEnhancerPro</code>这个软件。</p><p>任意打开一张图片，处理后，保存参数，便于批量处理。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/23/aKO7Nydl/Snipaste_2020-03-23_20-44-54.png" alt="Snipaste_2020-03-23_20-44-54"></p><p>调整参数，<code>自动纠斜</code>、页面大小设置<code>内容框大小</code>（选择其他的可能会有空白的部分）、划线部分可以针对情况自己选、DPI改为<code>600</code>，确定。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/23/aKO7Nydl/Snipaste_2020-03-23_20-48-53.png" alt="Snipaste_2020-03-23_20-48-53"></p><p>切边后效果</p><img src="https://img.zhuomu.xyz/view/img/2020/03/23/aKO7Nydl/Snipaste_2020-03-23_20-52-14.png" alt="Snipaste_2020-03-23_20-52-14" style="zoom:67%;" /><p>保存参数</p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/23/aKO7Nydl/Snipaste_2020-03-23_20-53-13.png" alt="Snipaste_2020-03-23_20-53-13"></p><p>批量处理</p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/23/aKO7Nydl/Snipaste_2020-03-23_20-54-03.png" alt="Snipaste_2020-03-23_20-54-03"></p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/23/aKO7Nydl/Snipaste_2020-03-23_20-56-24.png" alt="Snipaste_2020-03-23_20-56-24"></p><h2 id="0x03-添加书签目录"><a href="#0x03-添加书签目录" class="headerlink" title="0x03 添加书签目录"></a>0x03 添加书签目录</h2><p>这里我们使用两个软件一起操作。</p><p><code>FreePic2Pdf</code>、<code>PdgCntEditor</code>，这两个软件一定要放到同一个目录下。</p><p>我们使用<code>FreePic2PDF</code>这个软件增加目录功能，使用<code>PdfCntEditor</code>的编辑目录功能。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/23/aKO7Nydl/Snipaste_2020-03-23_21-01-04.png" alt="Snipaste_2020-03-23_21-01-04"></p><p>按照如下步骤操作，下面对步骤做一下解释。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/23/aKO7Nydl/Snipaste_2020-03-23_21-02-36.png" alt="Snipaste_2020-03-23_21-02-36"></p><ol><li><p>浏览PDF文件</p></li><li><p>选择存放<code>接口配置</code>的文件夹，这里随便选择一个就可以</p></li><li><p>编辑<code>接口配置</code></p><p>按照如下配置编辑，<code>BasePage</code>表示正文第一页，根据内容自行调整。</p><pre class="line-numbers language-none"><code class="language-none">[Images][Font]Language&#x3D;GBKFontSize&#x3D;7Margin&#x3D;0.5[Bkmk]File&#x3D;FreePic2Pdf_bkmk.txtAddAsText&#x3D;0ShowBkmk&#x3D;1ShowAll&#x3D;1BasePage&#x3D;10[Main]ContentsPage&#x3D;TextPage&#x3D;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>编辑目录，这里就仁者见仁智者见智了，推荐使用OCR文字识别，这里提供一种方法，把目录截图，然后使用<a href="https://fanyi.baidu.com/">百度翻译</a>自带的OCR识别功能，选择上传文档，然后复制文字，在记事本里边做调整。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/23/aKO7Nydl/Snipaste_2020-03-23_21-12-05.png" alt="Snipaste_2020-03-23_21-12-05"></p><p>这里的格式大致为，<code>\t</code>代表制表符，也就是<code>Tab</code>键，后边的1,2,3代表页码</p><pre class="line-numbers language-none"><code class="language-none">一级标题\t1\t二级标题\t2\t\t三级标题\t3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>二级三级目录可以使用软件里自带的工具栏调整缩进，以及其他部分。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/23/aKO7Nydl/Snipaste_2020-03-23_21-16-05.png" alt="Snipaste_2020-03-23_21-16-05"></p><p>Trick：</p><ul><li>如果要给目录的位置再加一个书签，可以设置页码为负值。</li></ul><p>保存。</p></li><li><p>预览目录树，看是否符合自己的要求。</p></li><li><p>操作之前把原来的PDF关闭，开始操作，等待操作完成。</p></li><li><p>重新打开是否符合要求，不符合再微调。</p></li></ol><h2 id="0x04-完成"><a href="#0x04-完成" class="headerlink" title="0x04 完成"></a>0x04 完成</h2><p><img src="https://img.zhuomu.xyz/view/img/2020/03/23/aKO7Nydl/Snipaste_2020-03-23_21-20-56.png" alt="Snipaste_2020-03-23_21-20-56"></p><h2 id="0x05-补充"><a href="#0x05-补充" class="headerlink" title="0x05 补充"></a>0x05 补充</h2><p><code>其他PDF优化的操作详见知乎页面</code></p><p>所需文件下载链接：</p><ul><li><a href="https://img2.zhuomu.xyz/down/uploads/PDF%E8%A1%A5%E4%B8%81%E4%B8%81Patcher.0.6.2.3546.7z">PDF补丁丁</a></li><li><a href="https://img2.zhuomu.xyz/down/uploads/ComicEnhancerPro_chn%20201907%20%E5%B8%A6%E5%9B%9B%E4%B8%AA%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0.rar">ComicEnhancerPro</a></li><li><a href="https://img2.zhuomu.xyz/down/uploads/FreePic2Pdf.1395217315.zip">FreePic2Pdf</a></li><li><a href="https://img2.zhuomu.xyz/down/uploads/PdgCntEditor.exe">PdgCntEditor</a></li></ul><p>已完成：</p><ul><li>[button color=”succees” url=”https://img2.zhuomu.xyz/down/uploads/2021%E6%B1%A4%E5%AE%B6%E5%87%A4%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E8%BE%85%E5%AF%BC%E8%AE%B2%E4%B9%892.pdf”]2021汤家凤高等数学辅导讲义[/button]</li><li>[button color=”succees” url=”https://img2.zhuomu.xyz/down/uploads/2021%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6%E4%B8%80%E6%B1%A4%E5%AE%B6%E5%87%A4%E6%8E%A5%E5%8A%9B%E9%A2%98%E5%85%B81800%E3%80%90%E9%A2%98%E7%9B%AE%E5%86%8C%E3%80%91.pdf”]2021接力题典1800 题目册[/button]</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF </tag>
            
            <tag> 书签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome浏览器net::ERR_BLOCKED_BY_CLIENT 解决</title>
      <link href="2020/03/18/Chrome-net--ERR_BLOCKED_BY_CLIENT-solve/"/>
      <url>2020/03/18/Chrome-net--ERR_BLOCKED_BY_CLIENT-solve/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-问题复现"><a href="#0x00-问题复现" class="headerlink" title="0x00 问题复现"></a>0x00 问题复现</h2><p>在测试了一下网站迁移，在另一台服务器上搭建和网站一样的，迁移完成后，发现我的图片都显示不出来了<a id="more"></a>，用的是又拍云的图床，但是我并没有设置防盗链，图片的链接也是可以直接打开的，同时我也设置了<code>403</code>、<code>404</code>、<code>405</code>图片，按理说如果图床挂了，应该会有正常的反馈才是的。</p><p>多次更改图床的访问控制，还是无果，我坚信<del>不是浏览器的问题</del>，所以没有换一个浏览器尝试（最后疯狂打脸），当我在手机上可以打开的时候，我傻了……连的是统一个无线，这肯定是浏览器的问题啊，于是<code>F12</code>了一波，发现了猫腻。</p><p>我图床的图片全线飘红<code>net::ERR_BLOCKED_BY_CLIENT</code></p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/18/HXTlbtds/Snipaste_2020-03-18_17-19-30.png" alt="Snipaste_2020-03-18_17-19-30"></p><h2 id="0x01-解决办法"><a href="#0x01-解决办法" class="headerlink" title="0x01 解决办法"></a>0x01 解决办法</h2><p>网上查询了<code>net::ERR_BLOCKED_BY_CLIENT</code>，结果发现是<code>AdBlock</code>在作祟。</p><img src="https://img.zhuomu.xyz/view/img/2020/03/18/3YypCjSd/Snipaste_2020-03-18_17-31-06.png" alt="Snipaste_2020-03-18_17-31-06" style="zoom:80%;" /><p>关闭掉这个网站上的<code>AdBlock</code>就可以了。</p><p>@&gt; 可能是我这个网站是通过IP访问的，AdBlock误认为这个图片域名和网站无关，是广告，毕竟咱的域名还很年轻。<br>又水了一批博客</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome </tag>
            
            <tag> AdBlock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 更新Git到2.0以上版本</title>
      <link href="2020/03/17/CentOS-update-Git-to-2_0+/"/>
      <url>2020/03/17/CentOS-update-Git-to-2_0+/</url>
      
        <content type="html"><![CDATA[<p>服务器上附带的git版本是<code>git version 1.8.3.1</code>，在Cloud Studio中建议<code>版本&gt;=2</code>，所以需要升级一下。</p><p>首先卸载Git</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">yum remove git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加新的源，然后安装</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">yum install -y https:&#x2F;&#x2F;centos7.iuscommunity.org&#x2F;ius-release.rpmyum install -y git2u<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结束以后检查Git版本</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我这里显示了当前最新的版本，<code>git version 2.16.6</code>。</p><p>大功告成。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cloud Studio利用Python实现高等数学微积分公式推导和计算</title>
      <link href="2020/03/16/Cloud-Studio-Python-math-sympy/"/>
      <url>2020/03/16/Cloud-Studio-Python-math-sympy/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h2><p>Cloud Studio：<a href="https://cloudstudio.net/">https://cloudstudio.net/</a></p><p>sympy：<a href="https://www.sympy.org/zh/index.html">https://www.sympy.org/zh/index.html</a></p><p>最近发现一个Python库，<code>sympy</code>，可以用来进行科学计算，可以利用它来求解高数问题，解决做高数习题时对答案有疑问的问题。</p><p>@&gt; Sympy是一个数学符号库（sym代表了symbol，符号），包括了积分，微分方程等各种数学运算方法，为python提供了强大的数学运算支持。对于图像来说，虽然都是做离散的计算，操作最多的还是numpy里的数组，但实际上，这个库包含了积分微分，三角等最基本的数学运算，可以说是工科最基本的，用起来媲美matlab。</p><p>于是在自己的PC上进行测试，果然好用，于是想着，我总不能一直带着电脑吧，能不能把他部署到我的服务器上边，在web上进行使用，这样，我在图书馆用iPad就可以使用这个工具，那样可能会极大的方便我的学习。</p><p>在网上找了些方案</p><ul><li><a href="https://github.com/Coding/WebIDE">WebIDE</a></li><li><a href="https://github.com/cdr/code-server">code-server</a></li><li><a href="https://cloudstudio.net/">Cloud Studio</a></li></ul><p>通过了解，发现这些方案均是围绕<code>Visual Studio Code</code>开源项目来二次开发的，巨硬的牛批(超大声)！</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><strong>WebIDE</strong></p><p>coding的开源项目，侧重在Git，体验之后，并不符合我的需求。</p><p><strong>code-server</strong></p><p>vscode的浏览器版本，部署简单，使用docker运行即可，但是docker触及到了我的知识盲区，学习了一部分后，部署完成，但是并不是很会搞这个Python环境，果断放弃。（全是知识盲区，这完全是递归学习啊。。。。</p><p><strong>Cloud Studio</strong></p><p>时隔一年，我还是用回了它，最开始是19年1月在这上边部署hexo博客，这样可以在任何地方写博客，然后push到Github Page上边，不过后来还是转到了本地部署，就闲置了。</p><p>经过一年的发展，Cloud Studio确实更新了不少，第一版基本上和WebIDE差不多，现在完全使用了vscode，腾讯牛批！</p><h2 id="0x01-注册Cloud-Studio"><a href="#0x01-注册Cloud-Studio" class="headerlink" title="0x01 注册Cloud Studio"></a>0x01 注册Cloud Studio</h2><p><a href="https://cloudstudio.net/">Cloud Studio</a></p><h2 id="0x02-新建工作空间"><a href="#0x02-新建工作空间" class="headerlink" title="0x02 新建工作空间"></a>0x02 新建工作空间</h2><p>注册完成之后，进入Cloud Studio</p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/16/PoBZKmRT/Snipaste_2020-03-16_15-24-38.png" alt="Snipaste_2020-03-16_15-24-38"></p><p>新建一个工作空间</p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/16/0LODHehF/Snipaste_2020-03-16_15-27-06.png" alt="Snipaste_2020-03-16_15-27-06"></p><p>输入控件的<code>名称</code>，选择<code>Ubuntu环境</code>（虽然我比较喜欢用的是CentOS，但是只有ubuntu选了…），代码来源选<code>空</code></p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/16/LIGA9UVU/Snipaste_2020-03-16_15-28-49.png" alt="Snipaste_2020-03-16_15-28-49"></p><p>到了这里，已经完成了90%了。</p><h2 id="0x03-安装Python环境"><a href="#0x03-安装Python环境" class="headerlink" title="0x03 安装Python环境"></a>0x03 安装Python环境</h2><p>打开终端，可以使用快捷键<code>Ctrl + `</code> 。</p><p>分别执行下列命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt-get updatesudo apt-get install python3-pipsudo python3 -m pip install --upgrade pippip3 --version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>环境部署完成以后，然后新建一个<code>test.py</code>文件进行测试。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from __future__ import divisionfrom sympy import *x &#x3D; Symbol(&#39;x&#39;)f &#x3D; (x+sqrt(1+x**2))**(1&#x2F;x)print(limit(f, x, oo))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个是求</p><p>$$\lim\limits_{x \to \infty }{(x+\sqrt{1+x^2})^\frac{1}{x}}\ =\ 1$$</p><p>运行后结果也是<code>1</code>。</p><p>关于其他，请自行测试。</p><h2 id="0x04-补充"><a href="#0x04-补充" class="headerlink" title="0x04 补充"></a>0x04 补充</h2><p>提供一些参考资料：</p><ul><li><p>官方文档：<a href="https://docs.sympy.org/latest/index.html">https://docs.sympy.org/latest/index.html</a></p></li><li><p>sympy库的使用教程1：<a href="https://mp.weixin.qq.com/s/QP3I_DZIJjanvcTGuUYHew">https://mp.weixin.qq.com/s/QP3I_DZIJjanvcTGuUYHew</a></p></li><li><p>sympy库的使用教程2：<a href="https://zhuanlan.zhihu.com/p/35150541">https://zhuanlan.zhihu.com/p/35150541</a></p></li><li><p>如果pip下载速度满的话，可以换清华的源：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/">https://mirrors.tuna.tsinghua.edu.cn/help/pypi/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术博文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> sympy </tag>
            
            <tag> Cloud Studio </tag>
            
            <tag> 高等数学 </tag>
            
            <tag> 微积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在ECS服务器上部署Coding WebIDE</title>
      <link href="2020/03/15/ECS-Coding-WebIDE/"/>
      <url>2020/03/15/ECS-Coding-WebIDE/</url>
      
        <content type="html"><![CDATA[<h2 id="安装宝塔"><a href="#安装宝塔" class="headerlink" title="安装宝塔"></a>安装宝塔</h2><p><strong>Centos安装命令：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y wget &amp;&amp; wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install_6.0.sh &amp;&amp; sh install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其他参考<a href="https://www.bt.cn/bbs/thread-19376-1-1.html">这里</a></p><h2 id="安装docker管理器"><a href="#安装docker管理器" class="headerlink" title="安装docker管理器"></a>安装docker管理器</h2><p>在宝塔软件商店中安装<code>docker管理器</code></p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/15/zFHpLxZX/Snipaste_20200315190144.png" alt="QQ截图20200315190144"></p><h2 id="开启端口"><a href="#开启端口" class="headerlink" title="开启端口"></a>开启端口</h2><p>在安全里边，开启8080端口，服务器安全组中也要把8080端口打开。</p><h2 id="Docker-server"><a href="#Docker-server" class="headerlink" title="Docker server"></a>Docker server</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker run -p 8080:8080 -v coding-ide-home:&#x2F;root&#x2F;.coding-ide webide&#x2F;webide<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>后台运行用这个</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker run -dit -p 8080:8080 -v coding-ide-home:&#x2F;root&#x2F;.coding-ide webide&#x2F;webide<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><!--https://yarn.bootcss.com/docs/install/#centos-stable--><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>打开<code>http://yourip:8080</code></p><p>添加RSA秘钥到Github或Coding中</p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/15/CJZVjg1c/Snipaste_20200315190757.png" alt="QQ截图20200315190757">添加SSH Key</p><p><a href="https://github.com/settings/keys">https://github.com/settings/keys</a></p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/15/l9pS9UJL/Snipaste_2020-03-15_19-09-50.png" alt="Snipaste_2020-03-15_19-09-50"></p><p>输入仓库SSH地址，即可clone仓库到WebIDE中。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>这样，就可以在浏览器上使用了</p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/15/L518cD7h/Snipaste_2020-03-15_19-12-25.png" alt="Snipaste_2020-03-15_19-12-25"></p>]]></content>
      
      
      <categories>
          
          <category> 技术博文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> ECS </tag>
            
            <tag> Coding </tag>
            
            <tag> WebIDE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将Git bash添加到Windows Terminal中</title>
      <link href="2020/03/04/Git-bash-Windows-Terminal/"/>
      <url>2020/03/04/Git-bash-Windows-Terminal/</url>
      
        <content type="html"><![CDATA[<p>给 Windows Terminal 增加Git bash终端</p><h2 id="下载安装Windows-Terminal"><a href="#下载安装Windows-Terminal" class="headerlink" title="下载安装Windows Terminal"></a>下载安装Windows Terminal</h2><p>Windows Terminal已经在Github上开源了。相信看到这篇博文的时候已经安装好了Windows Terminal，我也不再啰嗦。</p><p>Github：<a href="https://github.com/microsoft/terminal">microsoft/terminal</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>打开Windows Terminal，修改Terminal的配置文件，按照如图所示方法打开配置文件，也可以使用快捷键<code>Ctrl+,</code>打开。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/05/RJAoF5Ed/Snipaste_2020-03-05_00-10-19.png" alt="Snipaste_2020-03-05_00-10-19"></p><p>可以看到如下配置信息，复制已有的一部分，仿照着修改即可。</p><blockquote><p>注意：最后一个参数后边不能有<code>,</code>。</p></blockquote><p><img src="https://img.zhuomu.xyz/view/img/2020/03/05/n3ktygxR/Snipaste_2020-03-05_00-13-55.png" alt="Snipaste_2020-03-05_00-13-55"></p><p>一些可选参数说明：</p><ul><li><code>commandline</code>：这里填写你的新终端的路径，我的是<code>C:\Program Files\Git\bin\bash.exe</code>。</li><li><code>guid</code>：这个需要是<code>唯一</code>的，guid有<code>固定的格式</code>，可以去网上<code>自动生成</code>一个，但要保证和其他的<code>不一样</code>。</li><li><code>name</code>：这个是终端的名称，我的是<code>Git bash</code>。</li><li><code>icon</code>：终端图标，可以自定义。参数直接填写图片路径即可，这里提供一个<a href="https://img.zhuomu.xyz/view/icons/git_bash_icon.png">Git-icon</a>下载。</li><li><code>startingDirectory</code>：初始路径，由于我的Git相关的文件均在一个目录，所以设置了路径<code>D:\DATA</code>。</li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://img.zhuomu.xyz/view/img/2020/03/05/9XaJdrr7/Snipaste_2020-03-05_00-42-41.png" alt="Snipaste_2020-03-05_00-42-41"></p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/05/6odj7vBd/Snipaste_2020-03-05_00-44-40.png" alt="Snipaste_2020-03-05_00-44-40"></p><p>其他参数修改，请参考Terminal官方文档。</p><h2 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h2><p><strong>设置<code>git bash</code> 编码格式为<code>UTF-8</code></strong></p><p>打开<code>bash.bashrc</code>配置文件，路径为：<code>C:\Program Files\Git\etc</code></p><p>添加代码</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">export LANG&#x3D;&quot;zh_CN.UTF-8&quot;export LC_ALL&#x3D;&quot;zh_CN.UTF-8&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>设置<code>vim</code>编码格式为<code>UTF-8</code></strong></p><p>编辑<code>vimrc</code>文件，路径为：<code>C:\Program Files\Git\etc</code></p><p>添加以下代码</p><pre class="line-numbers language-none"><code class="language-none">set nu &quot; show line numberset fencs&#x3D;utf-8,gbk,utf-16,utf-32,ucs-bom<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Terminal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Office解决无法选择/显示中文字体问题</title>
      <link href="2020/03/03/Office--chinese-simple-font-selection/"/>
      <url>2020/03/03/Office--chinese-simple-font-selection/</url>
      
        <content type="html"><![CDATA[<p>Office解决无法选择/显示中文字体问题</p><h2 id="0x00-检查是否安装字体"><a href="#0x00-检查是否安装字体" class="headerlink" title="0x00 检查是否安装字体"></a>0x00 检查是否安装字体</h2><p>检查<code>C:\Windows\Fonts</code>路径下有没有对应的中文字体。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/03/oWM9o3ox/image-20200303201136175.png" alt="image-20200303201136175"></p><p>如果没有，可以去百度上下载找对应Windows版本的字体包。</p><h2 id="0x01-设置非Unicode程序的语言"><a href="#0x01-设置非Unicode程序的语言" class="headerlink" title="0x01 设置非Unicode程序的语言"></a>0x01 设置非Unicode程序的语言</h2><blockquote><p>示例系统：Win10，不同版本系统可能会有所差异。</p></blockquote><p><code>控制面板</code>-&gt;<code>时钟和区域</code>-&gt;<code>区域</code></p><p>设置为<code>中文</code></p><img src="https://img.zhuomu.xyz/view/img/2020/03/03/oWM9o3ox/image-20200303203804394.png" alt="image-20200303203804394" style="zoom: 67%;" /><h2 id="0x02-设置Office的语言"><a href="#0x02-设置Office的语言" class="headerlink" title="0x02 设置Office的语言"></a>0x02 设置Office的语言</h2><p>打开<code>Word</code>-&gt;<code>选项</code></p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/03/oWM9o3ox/image-20200303204254392.png" alt="image-20200303204254392"></p><p>设置首选语言为<code>中文（中国）</code>，如果系统语言默认为中文，与Windows匹配即可。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/03/oWM9o3ox/image-20200303204502745.png" alt="image-20200303204502745"></p><h2 id="0x03-重启"><a href="#0x03-重启" class="headerlink" title="0x03 重启"></a>0x03 重启</h2><p>重启后可恢复中文字体</p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/03/oWM9o3ox/image-20200303204638370.png" alt="image-20200303204638370"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Office </tag>
            
            <tag> 字体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法竞赛入门到进阶</title>
      <link href="2020/02/26/algorithm-liurujia/"/>
      <url>2020/02/26/algorithm-liurujia/</url>
      
        <content type="html"><![CDATA[<h1 id="算法竞赛入门到进阶"><a href="#算法竞赛入门到进阶" class="headerlink" title="算法竞赛入门到进阶"></a>算法竞赛入门到进阶</h1><h2 id="第3章-STL和基本数据结构"><a href="#第3章-STL和基本数据结构" class="headerlink" title="第3章 STL和基本数据结构"></a>第3章 STL和基本数据结构</h2><p>STL包含容器（container）、迭代器（iterator）、空间配置器（allocator）、配接器（adapter）、算法（algorithm）、仿函数（functor）。</p><h3 id="3-1-容器"><a href="#3-1-容器" class="headerlink" title="3.1 容器"></a>3.1 容器</h3><p><strong>1. 顺序式容器</strong></p><ul><li>vector：动态数组，从末尾能快速插入与删除，直接访问任何元素。</li><li>list：双向链表，从任何地方快速插入与删除。</li><li>deque：双向队列，从前面或后面快速插入与删除，直接访问任何元素。</li><li>queue：队列，先进后出。</li><li>priority_queue：优先队列，最高优先级元素总是第一个出列。</li><li>stack：栈，先进后出</li></ul><p><strong>2. 关联式容器</strong></p><ul><li>set：集合，快速查找，不允许重复值。</li><li>multiset：快速查找，允许重复值。</li><li>map：一对多映射，基于关键字快速查找，不允许重复值。</li><li>multimap：一对多映射，基于关键字快速查找，允许重复值。</li></ul><h4 id="3-1-1-vector"><a href="#3-1-1-vector" class="headerlink" title="3.1.1 vector"></a>3.1.1 vector</h4><p>定义</p><table><thead><tr><th>例子</th><th>说明</th></tr></thead><tbody><tr><td>vector&lt; int &gt; a;</td><td>默认初始化，a为空</td></tr><tr><td>vector&lt; int &gt; b(a);</td><td>用a定义b</td></tr><tr><td>vector&lt; int &gt; a(100);</td><td>a有100个值为0的元素</td></tr><tr><td>vector&lt; int &gt; a(100, 6);</td><td>100个值为6的元素</td></tr><tr><td>vector&lt; string &gt; a(10, “null”);</td><td>10个值为null的元素</td></tr><tr><td>vector&lt; string &gt; vec(10, “hello”);</td><td>10个值为hello的元素</td></tr><tr><td>vector&lt; string &gt; b(a.begin(), a.end());</td><td>b是a的复制</td></tr><tr><td>struct point {int x, y;}; vector&lt; point &gt; a;</td><td>a用来存坐标</td></tr></tbody></table><p>常用操作</p><table><thead><tr><th>功能</th><th>例子</th><th>说明</th></tr></thead><tbody><tr><td>赋值</td><td>a.push_back(100);</td><td>在尾部添加元素</td></tr><tr><td>元素个数</td><td>int size = a.size();</td><td>元素个数</td></tr><tr><td>是否为空</td><td>bool isEmpty=a.empty();</td><td>判断是否为空</td></tr><tr><td>打印</td><td>cout&lt;&lt;a[0]&lt;&lt;endl;</td><td>打印第一个元素</td></tr><tr><td>中间插入</td><td>a.insert(a.begin()+i, k);</td><td><code>在第i个元素前面插入k</code></td></tr><tr><td>尾部插入</td><td>a.push_back(8);</td><td>在尾部插入值为8的元素</td></tr><tr><td>尾部插入</td><td>a.insert(a.end(), 10, 5);</td><td><code>尾部插入10个值为5的元素</code></td></tr><tr><td>删除尾部</td><td>a.pop_back();</td><td>删除末尾元素</td></tr><tr><td>删除区间</td><td>a.erase(a.begin()+i, a.begin()+j);</td><td><code>删除区间[i, j-1]的元素</code></td></tr><tr><td>删除元素</td><td>a.erase(a.begin() + 2);</td><td><code>删除第3个元素</code></td></tr><tr><td>调整大小</td><td>a.resize(n);</td><td><code>数组大小变为n</code></td></tr><tr><td>清空</td><td>a.clear()；</td><td>清空</td></tr><tr><td>翻转</td><td>reverse(a.begin(), a.end());</td><td><code>用函数reverse()翻转数组</code></td></tr><tr><td>排序</td><td>sort(a.begin(), a.end());</td><td>用函数sort()排序，从小到大</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>细说Linux基础知识</title>
      <link href="2020/02/24/Linux-study/"/>
      <url>2020/02/24/Linux-study/</url>
      
        <content type="html"><![CDATA[<h1 id="细说Linux基础知识"><a href="#细说Linux基础知识" class="headerlink" title="细说Linux基础知识"></a>细说Linux基础知识</h1><h2 id="第2章-不识庐山真面目，只缘身在此山中：Linux系统安装"><a href="#第2章-不识庐山真面目，只缘身在此山中：Linux系统安装" class="headerlink" title="第2章 不识庐山真面目，只缘身在此山中：Linux系统安装"></a>第2章 不识庐山真面目，只缘身在此山中：Linux系统安装</h2><h3 id="2-1-虚拟机软件VMware的应用"><a href="#2-1-虚拟机软件VMware的应用" class="headerlink" title="2.1 虚拟机软件VMware的应用"></a>2.1 虚拟机软件VMware的应用</h3><p>VMware 提供的网络连接有 5 种，分别是“桥接模式”“NAT 模式”“仅主机模式”“自定义”和“LAN 区段”。</p><ul><li>桥接模式：相当于虚拟机的网卡和宿主机的物理网卡均连接到虚拟机软件所提供的 VMnet0 虚拟交换机上，因此虚拟机和宿主机是平等的，相当于一个网络中的两台计算机。这种设置<strong>既可以保证虚拟机和宿主机通信，也可以和局域网内的其他主机通信，还可以连接 Internet</strong>，是限制少的连接方式，推荐新手使用。</li><li>NAT 模式：相当于虚拟机的网卡和宿主机的虚拟网卡 VMnet8 连接到虚拟机软件所提供的 VMnet8 虚拟交换机上，因此本机是通过 VMnet8 虚拟网卡通信的。在这种网络结构中，VMware 为虚拟机提供了一个虚拟的 NAT 服务器和一个虚拟的 DHCP 服务器， 虚拟机利用这两个服务器可以连接到 Internet。所以，在正常情况下，<strong>虚拟机系统只要设定自动获取 IP 地址，就能既和宿主机通信，又能连接到 Internet</strong> 了。但是这种设置<strong>不能连接局域网内的其他主机</strong>。</li><li>仅主机模式：宿主机和虚拟机通信使用的是 VMware 的虚拟网卡 VMnet1，但是这种连接没有 NAT 服务器为虚拟机提供路由功能，所以仅主机网络<strong>只能连接宿主机</strong>，不能连接局域网，也不能连接 Internet 网络。</li><li>自定义网络：可以手工选择使用哪块虚拟机网卡。如果选择 Vmnet1，就相当于桥接网络；如果选择 VMnet8，就相当于 NAT 网络。</li><li>LAN 区段：这是新版 VMware 新增的功能，类似于交换机中的 VLAN（虚拟局域网），可以在多台虚拟机中<strong>划分不同的虚拟网络</strong>。 </li></ul><h3 id="2-5-dd命令复制安装Linux"><a href="#2-5-dd命令复制安装Linux" class="headerlink" title="2.5 dd命令复制安装Linux"></a>2.5 dd命令复制安装Linux</h3><h4 id="2-5-1-dd命令是什么"><a href="#2-5-1-dd命令是什么" class="headerlink" title="2.5.1 dd命令是什么"></a>2.5.1 dd命令是什么</h4><pre class="line-numbers language-none"><code class="language-none">[root@localhost ~]# dd if&#x3D;输入文件 of&#x3D;输出文件 bs&#x3D;字节数 count&#x3D;个数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>if=输入文件，指定源文件或原设备</p><p>of=输出文件，指定目标文件或目标设备</p><p>bs=字节数，指定依次输入/输出多少字节，几把这些字节看做一个数据库</p><p>count=个数，指定输入/输出多少个数据块</p></blockquote><pre class="line-numbers language-none"><code class="language-none">[root@localhost ~]# dd if&#x3D;&#x2F;dev&#x2F;zero&#x2F; of&#x3D;&#x2F;root&#x2F;testfile&#x2F; bs&#x3D;1k count&#x3D;100000#向testfile中不停写0，直到写满100MB[root@localhost ~]# dd if&#x3D;&#x2F;dev&#x2F;sda of&#x3D;&#x2F;dev&#x2F;sdb#把第一块硬盘中的数据复制到第二款硬盘中[root@localhost ~]# dd if&#x3D;&#x2F;dev&#x2F;hda of&#x3D;&#x2F;root&#x2F;image<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-远程管理工具"><a href="#2-6-远程管理工具" class="headerlink" title="2.6 远程管理工具"></a>2.6 远程管理工具</h3><h4 id="2-6-2-功能强大的SecureCRT"><a href="#2-6-2-功能强大的SecureCRT" class="headerlink" title="2.6.2 功能强大的SecureCRT"></a>2.6.2 功能强大的SecureCRT</h4><p>将SSH（Secure Shell）的安全登录、数据传送性能与Windows终端仿真提供的可靠性、可用性和可配置性结合在一起。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 读书 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 兄弟连 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用RCLONE自动备份Typecho网站和数据库</title>
      <link href="2020/02/22/RCLONE-backup-Typecho-site-and-database/"/>
      <url>2020/02/22/RCLONE-backup-Typecho-site-and-database/</url>
      
        <content type="html"><![CDATA[<h2 id="一些准备工作：rclone和网盘授权"><a href="#一些准备工作：rclone和网盘授权" class="headerlink" title="一些准备工作：rclone和网盘授权"></a>一些准备工作：rclone和网盘授权</h2><hr><p>rclone的安装见<a href="https://rclone.org/install/">官方安装文档</a>。<br>各种网盘配置见官方配置文档，博主这里用的是坚果云的<a href="https://rclone.org/webdav/">WebDAV</a>，按照文档操作即可。</p><h2 id="备份脚本编写及授权"><a href="#备份脚本编写及授权" class="headerlink" title="备份脚本编写及授权"></a>备份脚本编写及授权</h2><h3 id="创建脚本文件："><a href="#创建脚本文件：" class="headerlink" title="创建脚本文件："></a>创建脚本文件：</h3><pre class="line-numbers language-none"><code class="language-none">mkdir &#x2F;home&#x2F;typechoBackuptouch &#x2F;home&#x2F;typechoBackup&#x2F;backup.shvi &#x2F;home&#x2F;typechoBackup&#x2F;backup.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>脚本文件内容示例如下，不需要的功能自行在前方加上#号注释掉，删除几天前的备份，数字自行修改即可。其他内容自行按需修改成自己的即可：</p><p>[collapse status=”false” title=”备份脚本文档实例”]</p><pre class="line-numbers language-none"><code class="language-none">#!&#x2F;bin&#x2F;bash# 定义坚果云WebDAV的备份目录WebDAV_PATH&#x3D;&quot;jianguoyun:Typecho&quot;# 定义备份的目录及文件，不同的目录用空格分开BACKUP_SRC&#x3D;&quot;&#x2F;you&#x2F;wwwroot&#x2F;666.zhuomu.xyz&quot;# 定义临时文件存放目录BACKUP_DST&#x3D;&quot;&#x2F;home&#x2F;typechoBackup&#x2F;tmp&quot;# 设置MYSQL基本信息 MYSQL_SERVER&#x3D;&quot;localhost&quot;MYSQL_USER&#x3D;&quot;user&quot;MYSQL_PASS&#x3D;&quot;passwd&quot;# 定义想要备份的数据库，多个数据库用空格分开BACKUP_DATABASE&#x3D;&quot;user&quot;# 定义文件前缀名NOW&#x3D;$(date +&quot;%Y-%m-%d&quot;)TIME&#x3D;$(date +&quot;%Y-%m-%d-%H-%M-%S&quot;)OLD&#x3D;$(date -d -7day +&quot;%Y-%m-%d&quot;)# 备份网站数据文件tar -zcvf $BACKUP_DST&#x2F;$NOW-website.tar.gz $BACKUP_SRCmv $BACKUP_DST&#x2F;$NOW-website.tar.gz $BACKUP_DST&#x2F;$TIME-website.tar.gz# 备份mysql数据库mysqldump -u $MYSQL_USER -h $MYSQL_SERVER -p$MYSQL_PASS --databases $BACKUP_DATABASE &gt; $BACKUP_DST&#x2F;$NOW-database.sqlmv $BACKUP_DST&#x2F;$NOW-database.sql $BACKUP_DST&#x2F;$TIME-database.sql# 使用rclone上传到WebDAVrclone copy -v --stats 15s --bwlimit 1M $BACKUP_DST&#x2F; --include &quot;*.sql&quot; --include &quot;*.tar.gz&quot; $WebDAV_PATH# 删除本地的临时文件rm -f $BACKUP_DST&#x2F;*.sql $BACKUP_DST&#x2F;*.tar.gz# 删除7天前的备份rclone delete $WebDAV_PATH&#x2F; --include &quot;$OLD*&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[/collapse]</p><h3 id="使用chmod指令赋予执行权限："><a href="#使用chmod指令赋予执行权限：" class="headerlink" title="使用chmod指令赋予执行权限："></a>使用chmod指令赋予执行权限：</h3><pre class="line-numbers language-none"><code class="language-none">chmod +x &#x2F;home&#x2F;typechoBackup&#x2F;backup.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="创建自动备份任务并测试"><a href="#创建自动备份任务并测试" class="headerlink" title="创建自动备份任务并测试"></a>创建自动备份任务并测试</h3><p><strong>使用 crontab 每天4点定时执行自动备份脚本：</strong></p><pre class="line-numbers language-none"><code class="language-none">crontab -e<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>复制以下内容粘贴并输入<code>:wq</code>保存：</strong></p><pre class="line-numbers language-none"><code class="language-none">0 4 * * * &#x2F;bin&#x2F;bash &#x2F;home&#x2F;backup&#x2F;backup.sh &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>手动测试看看脚本是否正确运行：</strong></p><pre class="line-numbers language-none"><code class="language-none">bash &#x2F;home&#x2F;typechoBackup&#x2F;backup.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>时区设置为东八区：</strong></p><pre class="line-numbers language-none"><code class="language-none">timedatectl set-timezone Asia&#x2F;Shanghai<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>重启定时任务：</strong></p><pre class="line-numbers language-none"><code class="language-none">service crond restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>重启系统日志：</strong></p><pre class="line-numbers language-none"><code class="language-none">service rsyslog restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>最后观察下系统日志尾巴状态，是否时区已经调整成功：</strong></p><pre class="line-numbers language-none"><code class="language-none">tail -f &#x2F;var&#x2F;log&#x2F;cron<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="关于crontab格式详细说明，感兴趣的可以查阅："><a href="#关于crontab格式详细说明，感兴趣的可以查阅：" class="headerlink" title="关于crontab格式详细说明，感兴趣的可以查阅："></a>关于crontab格式详细说明，感兴趣的可以查阅：</h2><p>crontab 格式详解</p><p>或者使用在线生成工具生成需要的定时任务：<a href="https://crontab-generator.org/">online crontab</a></p><p>最后查看你的坚果云确认下运转是否正常。</p>]]></content>
      
      
      <categories>
          
          <category> 技术博文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rclone </tag>
            
            <tag> 备份 </tag>
            
            <tag> 坚果云 </tag>
            
            <tag> crontab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OLAINDEX单服务器多域名SSL</title>
      <link href="2020/02/21/OLAINDEX-use-two-SSL/"/>
      <url>2020/02/21/OLAINDEX-use-two-SSL/</url>
      
        <content type="html"><![CDATA[<p>新建站点<br>img.zhuomu.xyz:666<br>按照教程部署</p><p>修改配置文件</p><pre class="line-numbers language-none"><code class="language-none">location ~ \.php$ &#123;        fastcgi_split_path_info ^(.+\.php)(&#x2F;.+)$;        fastcgi_pass 127.0.0.1:666;        fastcgi_index index.php;        fastcgi_param  SCRIPT_FILENAME &#x2F;you&#x2F;app&#x2F;img.zhuomu.xyz&#x2F;public&#x2F;index.php; # 注意这里根据目录填写        include fastcgi_params;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存</p><p>测试访问</p><p>如果可以访问</p><p>添加SSL证书</p><p>大功告成</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PDF批量解密</title>
      <link href="2020/02/19/PDF-unlock/"/>
      <url>2020/02/19/PDF-unlock/</url>
      
        <content type="html"><![CDATA[<h1 id="PDF批量解密"><a href="#PDF批量解密" class="headerlink" title="PDF批量解密"></a>PDF批量解密</h1><h1 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h1><p>下载了一堆单页pdf文件，开开心心地去合并，不料竟然每一页都有密码，约1000+个文件，一个一个去用smallpdf解密也不现实，于是就有了下边的这些操作！</p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>我有个朋友……</p><p>帮朋友下一本书(<a href="!%5Bimg%5D(file:///C:%5CUsers%5Czhuom%5CAppData%5CRoaming%5CTencent%5CQQTempSys%25W@GJ$ACOF(TYDYECOKVDYB.png)https://kawajun.meclib.jp/store_deve_catalog/book/#target/page_no=1)">链接</a>，朋友告诉我单页pdf可以下载，能不能写个脚本批量下载了，我想既然单页可以下载，那分析一波下载url，或许有解，然后合并一下可能就完事，工作量不大。爽快答应！</p><p>打开网站，发现单页pdf的url长这个样子<code>https://kawajun.meclib.jp/store_deve_catalog/book/pdf/0005.pdf</code>，改了个页数，用IDM试了一下，可以下载，简直太好了，不得不感叹网站的友好，于是，用py把链接打出来，在IDM上从剪切板导入链接批量下载。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># https:&#x2F;&#x2F;kawajun.meclib.jp&#x2F;store_deve_catalog&#x2F;book&#x2F;pdf&#x2F;0005.pdffor i in range(1, 1153):    print(&quot;https:&#x2F;&#x2F;kawajun.meclib.jp&#x2F;store_deve_catalog&#x2F;book&#x2F;pdf&#x2F;&quot;+ str(i).zfill(4)+&#39;.pdf&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h1><h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><p>合并时候遇到了有加密口令的问题，于是乎开始Google解决方案，最终在github上找到了dalao的<code>unlock-pdf</code>项目。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!&#x2F;bin&#x2F;bashif [[ $# &#x3D;&#x3D; 1 ]]; theninput_dir&#x3D;$1elseecho &quot;Usage: $0 &#123;input_dir&#125;&quot;exit 255fioutput_dir&#x3D;&quot;$&#123;input_dir&#125;.decrypted&quot;mkdir -p $output_dirfor fn in &#96;ls -1 $input_dir&#96;doqpdf --decrypt $&#123;input_dir&#125;&#x2F;$fn $&#123;output_dir&#125;&#x2F;$fndone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将下列代码保存为.sh文件，windows平台打开的话，需要用WSL或者下载一个Git，就可以支持shell脚本。</p><h2 id="安装qpdf"><a href="#安装qpdf" class="headerlink" title="安装qpdf"></a>安装qpdf</h2><p>当然，这个脚本是依赖于一个软件<code>qpdf</code>，如果采用brew安装的话，因为网络的原因，速度可能要慢一点，所以直接去<a href="http://qpdf.sourceforge.net/">官网</a>下载。</p><p>Windows平台：将<code>D:\qpdf-9.1.1\bin</code>添加到环境变量，即可安装成功。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>将所有pdf文件放入inputfile目录下。</p><p>此时的目录结构应该为</p><pre class="line-numbers language-none"><code class="language-none">----unlock-pdf.sh----inputfile-------test1.pdf-------test2.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>打开Git bash</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">.&#x2F;unlock-pdf.sh inputfile&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样，就开始自动解密。</p><p>解密完成后，会生成一个<code>.decrypted</code>文件夹，每个解密后的pdf文件都会在这里。</p>]]></content>
      
      
      <categories>
          
          <category> 技术博文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF </tag>
            
            <tag> 解密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OneDrive E5 更改容量为5TB</title>
      <link href="2020/02/17/OneDrive-E5-change-storage-5TB/"/>
      <url>2020/02/17/OneDrive-E5-change-storage-5TB/</url>
      
        <content type="html"><![CDATA[<p>Office E5账号的OneDrive默认容量为1TB，可以修改为5TB，如果容量使用超过90%，可以联系客服修改为25TB。<br>下面介绍修改为5TB的方法<br>用<code>管理员账号</code>登录<a href="https://portal.office.com/AdminPortal/Home#/users">管理页面</a>，按照如下提示修改。<br><img src="https://img.zhuomu.xyz/view/img/2020/02/17/GcoDWW9u/Snipaste_2020-02-17_16-52-29.png" alt="Snipaste_2020-02-17_16-52-29.png"></p><p><img src="https://img.zhuomu.xyz/view/img/2020/02/17/noEzGv7h/Snipaste_2020-02-17_16-51-12.png" alt="Snipaste_2020-02-17_16-51-12.png"></p>]]></content>
      
      
      <categories>
          
          <category> 技术博文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OneDrive </tag>
            
            <tag> 5TB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OLAINDEX搭建OneDrive文件索引系统（类似OneIndex，PyOne）</title>
      <link href="2020/02/16/olaindex-onedrive-fileindex-system(OneIndex%EF%BC%8CPyOne)/"/>
      <url>2020/02/16/olaindex-onedrive-fileindex-system(OneIndex%EF%BC%8CPyOne)/</url>
      
        <content type="html"><![CDATA[<p>OLAINDEX部署文档资料<br>OLAINDEX <a href="https://github.com/WangNingkai/OLAINDEX">Github仓库</a><br>作者<a href="https://wangningkai.github.io/OLAINDEX/#/README">官方文档</a><br><strong>BT 面板安装 OLAINDEX 全方位指南</strong><br>@&gt; 全文摘自<a href="https://imwnk.cn/archives/bt-olaindex">作者</a>文章，略做修改。</p><p>!&gt; 如果你的VPS内存不足1G，可能导致PHP脚本无法安装。可以给VPS增加swap。宝塔内置工具里边有这个功能，可以直接修改，一般为物理内存的2倍.具体方法，百度很多，这里也提供一个<a href="https://www.moerats.com/archives/722/">脚本</a>，如果链接失效，直接百度即可。</p><p>出现错误，百度有可能解决不了问题，那么一定要翻阅issue，记住，是先翻阅，而不是直接提交一个issue，有些问题已经提供解决方案了，如果没用你的问题，再在github上提issue。<br>github issue<br><a href="https://github.com/WangNingkai/OLAINDEX/issues">https://github.com/WangNingkai/OLAINDEX/issues</a><br>closed issue<br><a href="https://github.com/WangNingkai/OLAINDEX/issues?q=is:issue+is:closed">https://github.com/WangNingkai/OLAINDEX/issues?q=is%3Aissue+is%3Aclosed</a><br><strong>oauth账号申请的坑</strong></p><ul><li>无法申请<blockquote><p>请一定要按照以下格式输入 <a href="https://example.com/oauth%EF%BC%8C%E4%B8%8D%E8%A6%81%E5%BF%98%E8%AE%B0%E6%B7%BB%E5%8A%A0https">https://example.com/oauth，不要忘记添加https</a></p></blockquote></li><li>填入client id 和 client secret 后字段空<blockquote><p>给storage文件夹777权限</p></blockquote></li><li>关于绑定的建议<blockquote><p>建议oauth账号用自己的onedrive，绑定的client id 和client secret用企业账号</p></blockquote></li></ul><p><strong>安装详细步骤</strong></p><h2 id="安装要求："><a href="#安装要求：" class="headerlink" title="安装要求："></a>安装要求：</h2><ul><li>内存： 512M以上，推荐768M以上（纯面板约占系统60M内存）</li><li>硬盘： 100M以上可用硬盘空间（纯面板约占20M磁盘空间）</li><li>系统： CentOS 6.x / 7.x (Ubuntu、Debian)，确保是干净的操作系统，没有安装过其它环境带的Apache/Nginx/php/MySQL（已有环境不可安装）</li></ul><p>宝塔linux6.0版本是基于centos7开发的，强烈建议使用centos7.x 系统 提示：Centos官方已宣布在2020年停止对Centos6的维护更新，各大软件开发商也逐渐停止对Centos6的兼容，新服务器不建议使用Centos6</p><p>以下主机商必看（开端口教程，不开不能用）：</p><ul><li>腾讯云：<a href="https://www.bt.cn/bbs/thread-1229-1-1.html">https://www.bt.cn/bbs/thread-1229-1-1.html</a></li><li>阿里云：<a href="https://www.bt.cn/bbs/thread-2897-1-1.html">https://www.bt.cn/bbs/thread-2897-1-1.html</a></li><li>华为云：<a href="https://www.bt.cn/bbs/thread-3923-1-1.html">https://www.bt.cn/bbs/thread-3923-1-1.html</a></li></ul><h4 id="下面安装默认以达到以上要求。"><a href="#下面安装默认以达到以上要求。" class="headerlink" title="下面安装默认以达到以上要求。"></a>下面安装默认以达到以上要求。</h4><h2 id="宝塔安装"><a href="#宝塔安装" class="headerlink" title="宝塔安装"></a>宝塔安装</h2><h3 id="安装面板命令："><a href="#安装面板命令：" class="headerlink" title="安装面板命令："></a>安装面板命令：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Centos安装命令：yum install -y wget &amp;&amp; wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install_6.0.sh &amp;&amp; sh install.shUbuntu&#x2F;Deepin安装命令：wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install-ubuntu_6.0.sh &amp;&amp; sudo bash install.shDebian安装命令：wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install-ubuntu_6.0.sh &amp;&amp; bash install.shFedora安装命令:wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install_6.0.sh &amp;&amp; bash install.shLinux面板6.9.6升级命令：curl http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;update6.sh|bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他系统安装查看</p><p>安装完毕，根据返回信息登陆宝塔面板：</p><p><img src="https://img.zhuomu.xyz/view/img/2020/02/16/AtDA0M7y/5d1e034a3a9fc70357.png" alt="cmd-bt"></p><h3 id="安装PHP环境"><a href="#安装PHP环境" class="headerlink" title="安装PHP环境"></a>安装PHP环境</h3><p><img src="https://img.zhuomu.xyz/view/img/2020/02/16/AtDA0M7y/5d1e02ff8446c13305.png" alt="php环境"></p><p>注意： <code>PHP</code> 环境选择 <code>7.1</code> 以上，这里选择 <code>7.2</code></p><p><img src="https://img.zhuomu.xyz/view/img/2020/02/16/AtDA0M7y/5d1e03aa1896470876.png" alt="开始安装"></p><p>开始安装等待环境安装完毕，我们开始安装扩展</p><h3 id="安装PHP扩展"><a href="#安装PHP扩展" class="headerlink" title="安装PHP扩展"></a>安装PHP扩展</h3><p>点击 <code>设置</code> 安装扩展</p><p>这里安装 <code>fileinfo</code> 扩展 并附带安装 <code>opcache</code> 扩展 以加速php运行，也可以安装 redis 和memcached 扩展。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/02/16/AtDA0M7y/5d1e047f2ddcc58142.png" alt="设置"></p><p><img src="https://img.zhuomu.xyz/view/img/2020/02/16/AtDA0M7y/5d1e047f1a3b788678.png" alt="扩展"></p><h3 id="修改-php-ini-文件"><a href="#修改-php-ini-文件" class="headerlink" title="修改 php.ini 文件"></a>修改 php.ini 文件</h3><p>修改 <code>PHP</code> 配置，需要关闭几个禁用的函数</p><p>分别是 <code>putenv</code>、<code>exec</code>、<code>shell_exec</code>、<code>proc_open</code>、<code>proc_get_status</code> （这个可以先不管，如果有报错，再处理）这四个函数。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/02/16/AtDA0M7y/5d1e047f2ddcc58142.png" alt="禁用函数"></p><h3 id="修改-composer-源（国外服务器请忽略）"><a href="#修改-composer-源（国外服务器请忽略）" class="headerlink" title="修改 composer 源（国外服务器请忽略）"></a>修改 composer 源（国外服务器请忽略）</h3><p>宝塔面板默认安装了 Composer 包管理器</p><p>进入命令行Console，执行以下命令更换为国内源</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">composer config -g repo.packagist composer https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;composer&#x2F; # 更换源为国内源，国外服务器可忽略此步骤<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>到此基本的PHP环境准备完毕</p><h2 id="安装配置-OLAINDEX"><a href="#安装配置-OLAINDEX" class="headerlink" title="安装配置 OLAINDEX"></a>安装配置 OLAINDEX</h2><h3 id="新建站点"><a href="#新建站点" class="headerlink" title="新建站点"></a>新建站点</h3><p>这里选择新建站点，填写域名后，保持默认配置。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/02/16/AtDA0M7y/5d1e053115bf622627.png" alt="新建站点"></p><p>站点的具体配置，我们到后面再配置。</p><h3 id="初始化-OLAINDEX"><a href="#初始化-OLAINDEX" class="headerlink" title="初始化 OLAINDEX"></a>初始化 OLAINDEX</h3><p>首先打开宝塔ssh</p><p><img src="https://img.zhuomu.xyz/view/img/2020/02/16/AtDA0M7y/5d1e06619bf1057358.png" alt="img"></p><p>按照一下步骤执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd web目录 # 刚才新建站点的目录 这里是 &#x2F;www&#x2F;wwwroot&#x2F;t_ningkai_wanggit clone https:&#x2F;&#x2F;github.com&#x2F;WangNingkai&#x2F;OLAINDEX.git tmp mv tmp&#x2F;.git . rm -rf tmp git reset --hard cp database&#x2F;database.sample.sqlite database&#x2F;database.sqlite  # 数据库文件composer install -vvv # 这里确保已经安装composer成功  # 如果报权限问题，建议先执行权限命令chmod -R 755 storage&#x2F;chown -R www:www *php artisan od:install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到此我们安装好了OLAINDEX</p><h3 id="配置站点信息"><a href="#配置站点信息" class="headerlink" title="配置站点信息"></a>配置站点信息</h3><p><img src="https://img.zhuomu.xyz/view/img/2020/02/16/AtDA0M7y/5d1e05b23a26f53416.png" alt="设置"></p><h4 id="首先站点目录"><a href="#首先站点目录" class="headerlink" title="首先站点目录"></a>首先站点目录</h4><p><img src="https://img.zhuomu.xyz/view/img/2020/02/16/AtDA0M7y/5d1e05f97706e99358.png" alt="目录设置"></p><p>如图：勾选取消 <code>防跨站攻击(open_basedir)</code> 将站点的运行目录改为 <code>public</code> 别忘了保存</p><h4 id="修改伪静态"><a href="#修改伪静态" class="headerlink" title="修改伪静态"></a>修改伪静态</h4><p>选择 <code>Laravel 5</code>，保存</p><p><img src="https://img.zhuomu.xyz/view/img/2020/02/16/AtDA0M7y/5d1e060ccede896247.png" alt="rewrite"></p><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>注释选定内容，防止图片出现404</p><p><img src="https://img.zhuomu.xyz/view/img/2020/02/16/AtDA0M7y/5d1e062d0f3f228677.png" alt="conf"></p><h4 id="配置SSL"><a href="#配置SSL" class="headerlink" title="配置SSL"></a>配置SSL</h4><p>选择 Let’s Encrypt 申请，按要求填写申请</p><p><img src="https://img.zhuomu.xyz/view/img/2020/02/16/AtDA0M7y/5d1e062e26b6144906.png" alt="SSL"></p><p>开启 SSL 后，选择强制 HTTPS</p><p><img src="https://img.zhuomu.xyz/view/img/2020/02/16/AtDA0M7y/5d1e064c0824516445.png" alt="SSL2"></p><h4 id="保存后，打开网站即可配置"><a href="#保存后，打开网站即可配置" class="headerlink" title="保存后，打开网站即可配置"></a>保存后，打开网站即可配置</h4><p><img src="https://img.zhuomu.xyz/view/img/2020/02/16/AtDA0M7y/5d1e064c1a74c94151.png" alt="install"></p><h2 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h2><p>剩下的配置按照常规操作即可，这里不再详细说明了。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OneDrive </tag>
            
            <tag> OLAINDEX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typecho更换MySQL数据库</title>
      <link href="2020/02/16/Typecho-change-MySQL-database/"/>
      <url>2020/02/16/Typecho-change-MySQL-database/</url>
      
        <content type="html"><![CDATA[<p>由于最初的版本是在百度虚拟主机BCH上安装部署的，里边还有一些资料，所以打算尝试一下可不可以转移数据。</p>]]></content>
      
      
      <categories>
          
          <category> 技术博文 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>给Typecho的handsome主题添加Google Analytics统计</title>
      <link href="2020/02/16/Typecho-handsome-theme-Google-Analytics/"/>
      <url>2020/02/16/Typecho-handsome-theme-Google-Analytics/</url>
      
        <content type="html"><![CDATA[<p>给网站添加Google Analytics分析<br>主题：handsome<br>Google Analytics <a href="https://zh.wikipedia.org/wiki/Google%E5%88%86%E6%9E%90">wiki</a><br>Google分析（Google Analytics）是一个由Google所提供的网站流量统计服务。Google 分析（Analytics）现在是互联网上使用最广泛的网络分析服务。Google Analytics还提供了一个SDK，允许从iOS和Android应用程序收集使用数据，称为Google Analytics for Mobile Apps。</p><a id="more"></a><p>注册<a href="https://analytics.google.com/analytics/web/">Google Analytics</a><br>获取统计代码<br>如果找不到代码，可以在图中的位置找到。<br><img src="https://img.zhuomu.xyz/view/img/2020/02/16/LIU9K0rC/Snipaste_2020-02-16_21-26-50.png" alt="Snipaste_2020-02-16_21-26-50.png"><br>获取到的大致格式如下：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;!-- Global site tag (gtag.js) - Google Analytics --&gt;&lt;script async src&#x3D;&quot;https:&#x2F;&#x2F;www.googletagmanager.com&#x2F;gtag&#x2F;js?id&#x3D;UA-XXXX&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;  window.dataLayer &#x3D; window.dataLayer || [];  function gtag()&#123;dataLayer.push(arguments);&#125;  gtag(&#39;js&#39;, new Date());  gtag(&#39;config&#39;, &#39;UA-XXXX&#39;);&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后将本代码粘贴进入网站目录下<code>/usr/themes/handsome/component/footer.php</code>文件中<br>具体粘在尾部<code>&lt;/body&gt;</code>之前</p><blockquote><p>参考<a href="https://limbopro.github.io/archives/396.html">博客</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术博文 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sublime Text 3 ClangFormat格式化</title>
      <link href="2020/02/15/Sublime-Text-3-ClangFormat/"/>
      <url>2020/02/15/Sublime-Text-3-ClangFormat/</url>
      
        <content type="html"><![CDATA[<h1 id="Sublime-Text-3-ClangFormat格式化"><a href="#Sublime-Text-3-ClangFormat格式化" class="headerlink" title="Sublime Text 3 ClangFormat格式化"></a>Sublime Text 3 ClangFormat格式化</h1><h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><p><code>ctrl+shift+p</code>找到<code>Package Control: Install Package</code><br>搜索<code>ClangFormat</code>，等待安装即可</p><h3 id="编译配置"><a href="#编译配置" class="headerlink" title="编译配置"></a>编译配置</h3><p><code>Tool</code> -&gt; <code>Build System</code> -&gt; <code>New Build System</code><br>保存文件名：myc++.build</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;&quot;path&quot;: &quot;C:&#x2F;MinGW&#x2F;bin&quot;,&quot;shell_cmd&quot;: &quot;g++ \&quot;$&#123;file&#125;\&quot; -o \&quot;$&#123;file_path&#125;&#x2F;$&#123;file_base_name&#125;\&quot;&quot;,&quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,&quot;working_dir&quot;: &quot;$&#123;file_path&#125;&quot;,&quot;selector&quot;: &quot;source.c, source.c++&quot;,&quot;variants&quot;:[&#123;&quot;name&quot;: &quot;Run&quot;,&quot;shell_cmd&quot;: &quot;g++ \&quot;$&#123;file&#125;\&quot; -o \&quot;$&#123;file_path&#125;&#x2F;$&#123;file_base_name&#125;\&quot; &amp;&amp; \&quot;$&#123;file_path&#125;&#x2F;$&#123;file_base_name&#125;\&quot; &lt; in.txt &gt; out.txt&quot;&#125;]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译选项配置好后</p><p>按<code>F7</code>，然后选择第二个<code>xxx Run</code>，以后直接按<code>F7</code>即可编译运行</p><p>关于编译选项的一些解释：</p><ul><li>sublime官方：<a href="http://sublimetext.info/docs/en/reference/build_systems.html">http://sublimetext.info/docs/en/reference/build_systems.html</a></li><li>中文：<a href="http://sublimetext.info/docs/en/reference/build_systems.html">https://www.cnblogs.com/jacen789/p/7801977.html</a></li></ul><h3 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h3><p>安装<code>llvm</code>，一般装过vs后都会有的，直接Everything搜一波，我找到我的路径在<code>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\Llvm\\bin\\clang-format.exe</code></p><p>或者</p><p>下载地址为<a href="http://releases.llvm.org/">http://releases.llvm.org/</a> 。在Windows系统下，直接下载<code>binary</code>版本并安装即可。</p><h4 id="Settings-User"><a href="#Settings-User" class="headerlink" title="Settings-User"></a>Settings-User</h4><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;    &#x2F;&#x2F; This is the path to the binary for clang-format. If it is in your path,    &#x2F;&#x2F; it should just work out-of-the-box. Otherwise, you can set the full path,    &#x2F;&#x2F; which will look like this:     &#x2F;&#x2F;    &quot;binary&quot;: &quot;&#x2F;path&#x2F;to&#x2F;clang&#x2F;bin&#x2F;clang-format&quot;    &#x2F;&#x2F; Note that you can set this from within ST directly through the Command    &#x2F;&#x2F; Palette.     &quot;binary&quot;: &quot;C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\Llvm\\bin\\clang-format.exe&quot;,    &#x2F;&#x2F; We use the Google style by default. This can be selected from ST using    &#x2F;&#x2F; the Command Palette. Choosing &#39;Custom&#39; means that the settings will    &#x2F;&#x2F; be loaded from the Sublime Text settings file (which is accessed    &#x2F;&#x2F; from within ST through preferences. Choosing &#39;File&#39; will look in the     &#x2F;&#x2F; local directories from a clang-format settings file. See the clang-format    &#x2F;&#x2F; documentation to see how this works.     &quot;style&quot;: &quot;Custom&quot;,    &#x2F;&#x2F; Setting this to true will run the formatter on every save. If you want to    &#x2F;&#x2F; only enable this for a given project, try checking out the package    &#x2F;&#x2F; &quot;Project-Specific&quot;.        &quot;format_on_save&quot;: true,    &#x2F;&#x2F; If format_on_save is set to true, ClangFormat checks if the current file    &#x2F;&#x2F; has its syntax set to a language in the list below. If it is in the list,    &#x2F;&#x2F; then the file will be formatted by ClangFormat.    &quot;languages&quot;: [&quot;C&quot;, &quot;C++&quot;, &quot;C++11&quot;, &quot;JavaScript&quot;, &quot;Objective-C&quot;, &quot;Objective-C++&quot;]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Custom-Style-User"><a href="#Custom-Style-User" class="headerlink" title="Custom Style-User"></a>Custom Style-User</h4><p>具体样式，可以参考<a href="http://clang.llvm.org/docs/ClangFormatStyleOptions.html">官方</a>给出的说明。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;    &quot;BasedOnStyle&quot;: &quot;Google&quot;,    &quot;IndentWidth&quot;: 4,    &quot;AlignAfterOpenBracket&quot;: true,    &quot;AlignConsecutiveAssignments&quot;: true,    &#x2F;&#x2F;# 连续声明时，对齐所有声明的变量名    &quot;AlignConsecutiveDeclarations&quot;: false,    &quot;MaxEmptyLinesToKeep&quot;: 4,    &quot;BreakBeforeBraces&quot;: &quot;Attach&quot;,    &quot;AllowShortIfStatementsOnASingleLine&quot;: true,    &quot;IndentCaseLabels&quot;: true,    &quot;ObjCBlockIndentWidth&quot;: 4,    &quot;ObjCSpaceAfterProperty&quot;: true,    &quot;ColumnLimit&quot;: 0,    &quot;AlignTrailingComments&quot;: true,    &quot;SpaceAfterCStyleCast&quot;: true,    &quot;SpacesInParentheses&quot;: false,    &quot;SpacesInSquareBrackets&quot;: false,    &quot;TabWidth&quot;: 4,    &quot;UseTab&quot;: &quot;Never&quot;,    &quot;AllowShortBlocksOnASingleLine&quot;: true,    &quot;AllowShortIfStatementsOnASingleLine&quot;: true,    &quot;AllowShortLoopsOnASingleLine&quot;: true,    &quot;BraceWrapping&quot;:&#123;        &quot;AfterClass&quot;:             false,        &quot;AfterControlStatement&quot;:  false,        &quot;AfterEnum&quot;:              false,        &quot;AfterFunction&quot;:          false,        &quot;AfterNamespace&quot;:         false,        &quot;AfterObjCDeclaration&quot;:   false,        &quot;AfterStruct&quot;:            false,        &quot;AfterUnion&quot;:             false,        &quot;BeforeCatch&quot;:            false,        &quot;BeforeElse&quot;:             false,        &quot;IndentBraces&quot;:           false,        &quot;SplitEmptyFunction&quot;:     true,        &quot;SplitEmptyRecord&quot;:       true,        &quot;SplitEmptyNamespace&quot;:    true    &#125;,    &quot;Cpp11BracedListStyle&quot;: true,    &quot;ColumnLimit&quot;: 80,&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>当然也可以看这里对每个选项的中文解释</strong></p><pre class="line-numbers language-none"><code class="language-none">---# 语言: None, Cpp, Java, JavaScript, ObjC, Proto, TableGen, TextProtoLanguage:Cpp# BasedOnStyle:LLVM# 访问说明符(public、private等)的偏移AccessModifierOffset:-4# 开括号(开圆括号、开尖括号、开方括号)后的对齐: Align, DontAlign, AlwaysBreak(总是在开括号后换行)AlignAfterOpenBracket:Align# 连续赋值时，对齐所有等号AlignConsecutiveAssignments:true# 连续声明时，对齐所有声明的变量名AlignConsecutiveDeclarations:true# 左对齐逃脱换行(使用反斜杠换行)的反斜杠AlignEscapedNewlinesLeft:true# 水平对齐二元和三元表达式的操作数AlignOperands:true# 对齐连续的尾随的注释AlignTrailingComments:true# 允许函数声明的所有参数在放在下一行AllowAllParametersOfDeclarationOnNextLine:true# 允许短的块放在同一行AllowShortBlocksOnASingleLine:false# 允许短的case标签放在同一行AllowShortCaseLabelsOnASingleLine:false# 允许短的函数放在同一行: None, InlineOnly(定义在类中), Empty(空函数), Inline(定义在类中，空函数), AllAllowShortFunctionsOnASingleLine:Empty# 允许短的if语句保持在同一行AllowShortIfStatementsOnASingleLine:false# 允许短的循环保持在同一行AllowShortLoopsOnASingleLine:false# 总是在定义返回类型后换行(deprecated)AlwaysBreakAfterDefinitionReturnType:None# 总是在返回类型后换行: None, All, TopLevel(顶级函数，不包括在类中的函数), #   AllDefinitions(所有的定义，不包括声明), TopLevelDefinitions(所有的顶级函数的定义)AlwaysBreakAfterReturnType:None# 总是在多行string字面量前换行AlwaysBreakBeforeMultilineStrings:false# 总是在template声明后换行AlwaysBreakTemplateDeclarations:false# false表示函数实参要么都在同一行，要么都各自一行BinPackArguments:true# false表示所有形参要么都在同一行，要么都各自一行BinPackParameters:true# 大括号换行，只有当BreakBeforeBraces设置为Custom时才有效BraceWrapping:     # class定义后面  AfterClass:false  # 控制语句后面  AfterControlStatement:false  # enum定义后面  AfterEnum:false  # 函数定义后面  AfterFunction:false  # 命名空间定义后面  AfterNamespace:false  # ObjC定义后面  AfterObjCDeclaration:false  # struct定义后面  AfterStruct:false  # union定义后面  AfterUnion:false  # catch之前  BeforeCatch:true  # else之前  BeforeElse:true  # 缩进大括号  IndentBraces:false# 在二元运算符前换行: None(在操作符后换行), NonAssignment(在非赋值的操作符前换行), All(在操作符前换行)BreakBeforeBinaryOperators:NonAssignment# 在大括号前换行: Attach(始终将大括号附加到周围的上下文), Linux(除函数、命名空间和类定义，与Attach类似), #   Mozilla(除枚举、函数、记录定义，与Attach类似), Stroustrup(除函数定义、catch、else，与Attach类似), #   Allman(总是在大括号前换行), GNU(总是在大括号前换行，并对于控制语句的大括号增加额外的缩进), WebKit(在函数前换行), Custom#   注：这里认为语句块也属于函数BreakBeforeBraces:Custom# 在三元运算符前换行BreakBeforeTernaryOperators:true# 在构造函数的初始化列表的逗号前换行BreakConstructorInitializersBeforeComma:false# 每行字符的限制，0表示没有限制ColumnLimit:200# 描述具有特殊意义的注释的正则表达式，它不应该被分割为多行或以其它方式改变CommentPragmas:&#39;^ IWYU pragma:&#39;# 构造函数的初始化列表要么都在同一行，要么都各自一行ConstructorInitializerAllOnOneLineOrOnePerLine:false# 构造函数的初始化列表的缩进宽度ConstructorInitializerIndentWidth:4# 延续的行的缩进宽度ContinuationIndentWidth:4# 去除C++11的列表初始化的大括号&#123;后和&#125;前的空格Cpp11BracedListStyle:false# 继承最常用的指针和引用的对齐方式DerivePointerAlignment:false# 关闭格式化DisableFormat:false# 自动检测函数的调用和定义是否被格式为每行一个参数(Experimental)ExperimentalAutoDetectBinPacking:false# 需要被解读为foreach循环而不是函数调用的宏ForEachMacros:[ foreach, Q_FOREACH, BOOST_FOREACH ]# 对#include进行排序，匹配了某正则表达式的#include拥有对应的优先级，匹配不到的则默认优先级为INT_MAX(优先级越小排序越靠前)，#   可以定义负数优先级从而保证某些#include永远在最前面IncludeCategories:   - Regex:&#39;^&quot;(llvm|llvm-c|clang|clang-c)&#x2F;&#39;    Priority:2  - Regex:&#39;^(&lt;|&quot;(gtest|isl|json)&#x2F;)&#39;    Priority:3  - Regex:&#39;.*&#39;    Priority:1# 缩进case标签IndentCaseLabels:false# 缩进宽度IndentWidth:4# 函数返回类型换行时，缩进函数声明或函数定义的函数名IndentWrappedFunctionNames:false# 保留在块开始处的空行KeepEmptyLinesAtTheStartOfBlocks:true# 开始一个块的宏的正则表达式MacroBlockBegin:&#39;&#39;# 结束一个块的宏的正则表达式MacroBlockEnd:&#39;&#39;# 连续空行的最大数量MaxEmptyLinesToKeep:1# 命名空间的缩进: None, Inner(缩进嵌套的命名空间中的内容), AllNamespaceIndentation:Inner# 使用ObjC块时缩进宽度ObjCBlockIndentWidth:4# 在ObjC的@property后添加一个空格ObjCSpaceAfterProperty:false# 在ObjC的protocol列表前添加一个空格ObjCSpaceBeforeProtocolList:true# 在call(后对函数调用换行的penaltyPenaltyBreakBeforeFirstCallParameter:19# 在一个注释中引入换行的penaltyPenaltyBreakComment:300# 第一次在&lt;&lt;前换行的penaltyPenaltyBreakFirstLessLess:120# 在一个字符串字面量中引入换行的penaltyPenaltyBreakString:1000# 对于每个在行字符数限制之外的字符的penaltyPenaltyExcessCharacter:1000000# 将函数的返回类型放到它自己的行的penaltyPenaltyReturnTypeOnItsOwnLine:60# 指针和引用的对齐: Left, Right, MiddlePointerAlignment:Left# 允许重新排版注释ReflowComments:true# 允许排序#includeSortIncludes:true# 在C风格类型转换后添加空格SpaceAfterCStyleCast:false# 在赋值运算符之前添加空格SpaceBeforeAssignmentOperators:true# 开圆括号之前添加一个空格: Never, ControlStatements, AlwaysSpaceBeforeParens:ControlStatements# 在空的圆括号中添加空格SpaceInEmptyParentheses:false# 在尾随的评论前添加的空格数(只适用于&#x2F;&#x2F;)SpacesBeforeTrailingComments:2# 在尖括号的&lt;后和&gt;前添加空格SpacesInAngles:true# 在容器(ObjC和JavaScript的数组和字典等)字面量中添加空格SpacesInContainerLiterals:true# 在C风格类型转换的括号中添加空格SpacesInCStyleCastParentheses:true# 在圆括号的(后和)前添加空格SpacesInParentheses:true# 在方括号的[后和]前添加空格，lamda表达式和未指明大小的数组的声明不受影响SpacesInSquareBrackets:true# 标准: Cpp03, Cpp11, AutoStandard:Cpp11# tab宽度TabWidth:4# 使用tab字符: Never, ForIndentation, ForContinuationAndIndentation, AlwaysUseTab:Never<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>参考文档：</p><ul><li>github官方文档：<a href="https://github.com/rosshemsley/SublimeClangFormat">https://github.com/rosshemsley/SublimeClangFormat</a></li><li>ClangFormatStyleOptions官方注释解释：<a href="http://clang.llvm.org/docs/ClangFormatStyleOptions.html">http://clang.llvm.org/docs/ClangFormatStyleOptions.html</a></li><li>clang format插件配置：<a href="https://yjiang.coding.me/20180918-wei-sublime-text-pei-zhi-clang-format/">https://yjiang.coding.me/20180918-wei-sublime-text-pei-zhi-clang-format/</a></li><li>一个还算完整的博客：<a href="https://blog.csdn.net/laojiu_/article/details/70169781">https://blog.csdn.net/laojiu_/article/details/70169781</a></li><li>Clang-Format格式化选项介绍：<a href="https://blog.csdn.net/softimite_zifeng/article/details/78357898">https://blog.csdn.net/softimite_zifeng/article/details/78357898</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术博文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> Sublime Text 3 </tag>
            
            <tag> ClangFormat </tag>
            
            <tag> 格式化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员面试宝典-基础知识总结</title>
      <link href="2020/02/12/offer/"/>
      <url>2020/02/12/offer/</url>
      
        <content type="html"><![CDATA[<h3 id="程序员面试宝典"><a href="#程序员面试宝典" class="headerlink" title="程序员面试宝典"></a>程序员面试宝典</h3><h5 id="const-位置"><a href="#const-位置" class="headerlink" title="const 位置"></a>const 位置</h5><p>  const位于星号左侧，则const就是被用来修饰指针指向的变量， 如果位于右侧，则就是修饰指针本身。</p><h5 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h5><p>  在const成员函数中，用mutable修饰成员变量</p><h5 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h5><pre class="line-numbers language-none"><code class="language-none">  class A｛  ​    int a；  ​    static int b；  ｝<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  静态变量是存放在全局数据区的，sizeof只计算栈中分配的大小，所以sizeof（A）不包括b</p><h5 id="const与-define区别"><a href="#const与-define区别" class="headerlink" title="const与#define区别"></a>const与#define区别</h5><p>  const常量有数据类型，宏没有数据类型；编译器可以对const进行类型安全检查，对后者只进行字符替换</p><h5 id="内存中的数据对齐"><a href="#内存中的数据对齐" class="headerlink" title="内存中的数据对齐"></a>内存中的数据对齐</h5><p>  一般按照4字节进行对齐</p><h5 id="sizeof和strlen的区别"><a href="#sizeof和strlen的区别" class="headerlink" title="sizeof和strlen的区别"></a>sizeof和strlen的区别</h5><ul><li><p>sizeof是运算符，strlen是函数</p></li><li><p>sizeof可以用类型做参数，strlen只能用char*做参数，且必须以”\0”结尾</p></li></ul><p>    * sizeof在编译的时候就已经计算了，strlen在运行的时候才计算</p><p>    * 返回结果不一样</p><h5 id="类空间"><a href="#类空间" class="headerlink" title="类空间"></a>类空间</h5><p>  空类所占空间为1，单一和多重继承还是1，虚继承和只含有虚函数的类为4</p><h5 id="内联函数和宏的区别"><a href="#内联函数和宏的区别" class="headerlink" title="内联函数和宏的区别"></a>内联函数和宏的区别</h5><ul><li><p>内联函数要做参数类型检查</p></li><li><p>宏不能调试</p></li><li><p>宏容易出错，（边际效应）</p></li><li><p>内联函数不能有循环</p></li><li><p>inline关键字必须和函数体定义放在一起才可以实现内联</p></li></ul><h5 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h5><ul><li>指针与引用</li></ul><p>  * 非空区别：引用必须指向某些对象</p><p>  * 合法性区别：在使用引用之前不需要测试其合法性，相反，指针则应该总是被测试</p><p>  * 可修改性区：指针可以重新赋值以指向另一个不同的对象，但是引用则总是指向在初始化时被指定的对象，以后不能改变</p><ul><li>指针的声明</li></ul><p>  * float(**def)[10]  def是一个二级指针，它指向的是一个一维数组的指针，数组元素是float</p><p>  * double* (* gh)[10]  gh是一个指针，它指向一个一维数组，数组元素都是double*</p><p>  * double(* f[10])()  f是一个数组，f有10个元素，元素都是函数指针，指向的函数都是没有参数且返回double</p><p>  * int* ((* b)[10])  与（2）相同</p><p>  * Int (*( *F)(int ,int))(int)  F是一个函数的指针，指向的类型是一个有两个int参数，并且返回一个函数指针的函数，返回的函数指针指向一个有一个int参数且返回int的函数</p><ul><li>指针和句柄</li></ul><p>  句柄和指针其实是两个截然不同的概念，Windows系统用句柄标记系统资源，隐藏系统的信息，你只要知道有这个东西，然后去调用就行，指针则是标记某个物理内存地址。</p><ul><li>this在成员函数的开始执行前构造的，在成员的执行结束后清除。</li></ul><h5 id="malloc-free-new-delete"><a href="#malloc-free-new-delete" class="headerlink" title="malloc/free new/delete"></a>malloc/free new/delete</h5><ul><li><p>malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。对于非内部数据类型的对象而言，光用malloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能把执行构造函数和析构函数的任务强加于malloc/free。</p></li><li><p><strong>运算符</strong>是语言自身的特性，它有固定的语义，而且编译器也知道意味着什么。就像 +-*/ 一样，由编译器解释语义，生成相应的代码。 <strong>库函数</strong>是依赖于库的，没有库就没有它，也就是一定程度上独立于语言的。理论上，编译器不知道也不关心函数的作用，编译器只保证编译函数，以及调用该函数时参数和返回值符合语法，并生成相应 call 函数的代码。但实际中一些高级点的编译器，都会对标准库自带的一些函数进行特别处理。</p></li></ul><h5 id="Struct和class"><a href="#Struct和class" class="headerlink" title="Struct和class"></a>Struct和class</h5><ul><li><h5 id="默认成员权限区别"><a href="#默认成员权限区别" class="headerlink" title="默认成员权限区别"></a>默认成员权限区别</h5></li></ul><p>  struct的成员默认权限是public，而class的成员默认权限是private。</p><ul><li><h5 id="默认继承方式"><a href="#默认继承方式" class="headerlink" title="默认继承方式"></a>默认继承方式</h5></li></ul><p>  ， struct的默认继承方式为public，而class的默认继承为private</p><ul><li><h5 id="用于定义模板参数"><a href="#用于定义模板参数" class="headerlink" title="用于定义模板参数"></a>用于定义模板参数</h5></li></ul><p>  模板为C++语言新增特性，C语言没有，只有class可用于定义参数，而struct不可以</p><h5 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h5><ul><li><p>容器（Container），是一种数据结构，如list，vector，和deques ，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器；</p></li><li><p>迭代器（Iterator），提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象；</p></li><li><p>算法（Algorithm），是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用；</p></li><li><p>仿函数（Function object，仿函数(functor)又称之为函数对象（function object），其实就是重载了()操作符的struct，没有什么特别的地方</p></li><li><p>迭代适配器（Adaptor）</p></li><li><p>空间配制器（allocator）其中主要工作包括两部分1.对象的创建与销毁    2.内存的获取与释放</p></li></ul><h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><ul><li><p>对于一个空类，编译器会默认产生4个成员函数，默认构造，析构，复制构造，赋值函数</p></li><li><p>静态成员变量一定要初始化，常量必须在构造函数里初始化。</p></li><li><p>虚析构函数</p></li></ul><p>  如果将基类的析构函数声明为虚函数时，由该基类所派生的所有派生类的析构函数也都自动成为虚函数</p><p>  析构函数可以是纯虚函数，但是此时析构函数必须要有实现</p><ul><li><p>虚函数表在构造函数调用后才建立，因而构造函数不可能成为虚函数，虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。</p></li><li><p>友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend。调用方式与普通函数一样。</p></li><li><p>has a关系可以由组合实现</p></li><li><p>拥有纯虚函数的类是抽象类，不能实例化</p></li></ul><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><ul><li>多态可以简单的理解为”一个接口，多种方法”，在程序运行的时候才决定调用的函数。</li></ul><p>  a、编译时多态性：通过重载函数实现   b、运行时多态性：通过虚函数实现。 </p><h5 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h5><p>C++ 中的虚函数的作用主要是实现了多态机制，即父类类别的指针（或者引用）指向其子类的实例，然后通过父类的指针（或者引用）调用实际子类的成员函数。多态机制可以简单地概括为”一个接口，多种方法”。</p><p>虚函数 是通过一张虚函数表（ Virtual Table ）来实现的，简称为 V-Table 。在这个表中，主要是一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得极为重要了，它就像一个地图一样，指明了实际所应该调用的函数。</p><h5 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h5><p>通过<code>#define NDEBUG #include &lt;assert.h&gt;</code>可以开启关闭assert</p><h5 id="进程线程"><a href="#进程线程" class="headerlink" title="进程线程"></a>进程线程</h5><ul><li>进程的三种基本状态</li></ul><p>  * 就绪状态：进程以分配道处CPU之外的其他资源</p><p>  * 执行状态：获得CPU，正在执行</p><p>  * 阻塞状态：正在执行的进程，由于等待某个事件发生而无法执行时，放弃CPU而处于阻塞状态</p><p>    （I/O, 申请缓冲区不能满足，等待信号）</p><h5 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h5><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">char * strcpy( char *strDest, const char *strSrc ) &#123; assert( (strDest !&#x3D; NULL) &amp;&amp; (strSrc !&#x3D; NULL) ); char *address &#x3D; strDest;  while( (*strDest++ &#x3D; * strSrc++) !&#x3D; &#39;\0&#39; );  return address;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="static"><a href="#static" class="headerlink" title="static"></a>static</h5><p>static关键字至少有下列n个作用：   </p><p>（1）函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；  </p><p>（2）在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；   </p><p>（3）在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；   </p><p>（4）在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；   </p><p>（5）在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。  </p><h5 id="const"><a href="#const" class="headerlink" title="const"></a>const</h5><p>const关键字至少有下列n个作用：   </p><p>（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；   </p><p>（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；   </p><p>（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；   </p><p>（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的 成员变量；   </p><p>（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为”左值”</p><h5 id="不可以同时用const和static修饰成员函数。"><a href="#不可以同时用const和static修饰成员函数。" class="headerlink" title="不可以同时用const和static修饰成员函数。"></a>不可以同时用const和static修饰成员函数。</h5><p>C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this*。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突</p><h5 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h5><ul><li>可以阻止不应该允许的经过转换构造函数进行的隐式转换的发生,声明为explicit的构造函数不能在隐式转换中使用</li></ul><h5 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h5><p>线性表分为顺序表和链表</p><ul><li>链表</li></ul><p>  链表的curr指针一般指向当前元素的前一个元素，这样可以方便插入新元素</p><p>  增加表头节点可以解决当链表为空时的特殊情况，表头节点不被当做实际元素</p><h5 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h5><ul><li>递归版本</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template &lt;typename E&gt;    void preorder(BinNode&lt;E&gt;* root) &#123;          if (root &#x3D;&#x3D; NULL)        visit(root);        preorder(roor-&gt;left());        preorder(roor-&gt;right());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>非递归版本</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void preorderTraversalNew(TreeNode *root, vector&lt;int&gt; &amp;path) &#123;    stack&lt;pair&lt;TreeNode *, bool&gt;&gt; s;    s.push(root, false);    bool visited;    while (!s.empty()) &#123;        root    &#x3D; s.top().first;        visited &#x3D; s.top().second;        s.pop() if (root &#x3D;&#x3D; NULL) continue;        if (visited) &#123;            path.push_back(root-&gt;val);        &#125; else &#123;            s.push(make_pair(root-&gt;right(), false));            s.push(make_pair(root-&gt;left(), false));            s.push(make_pair(root, true));        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h5><ul><li>插入排序</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void insSort(E A[], int n) &#123;    for (int i &#x3D; 1; i &lt; n; ++i) &#123;        for (int j &#x3D; i; j &gt; 0 &amp;&amp; (A[j] &lt; A[j - 1]); --j) swap(A, j, j - 1);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>冒泡排序<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void bubSort(E A[], int n) &#123;    for (int i &#x3D; 0; i &lt; n - 1; ++i) &#123;        for (int j &#x3D; n - 1; j &gt; i &amp;&amp; A[j] &lt; A[j - 1]; --j) &#123;            swap(A, j, j - 1);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>选择排序<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void selectSort(E A[], int n) &#123;    int lowIndex;    for (int i &#x3D; 0; i &lt; n; ++i) &#123;        lowIndex &#x3D; i;        for (int j &#x3D; n - 1; j &gt; i; --j) &#123;            if (Comp::prior(A[j], A[lowIndex])) lowIndex &#x3D; j;            swap(A, i, lowIndex);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>Shell排序<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void insSort2(E A[], int n, in incr) &#123;    for (int i &#x3D; incr; i &lt; n; i +&#x3D; incr) &#123;        for (int j &#x3D; i; (j &gt;&#x3D; incr) &amp;&amp; (A[j] &gt; A[j - incr]); j -&#x3D; incr) &#123;            swap(A, j, j - incr);        &#125;    &#125;&#125;void shellSort(E A[], int n) &#123;    for (int i &#x3D; n &#x2F; 2; i &gt; 2; i &#x2F;&#x3D; 2) &#123;        for (int j &#x3D; 0; j &lt; i; j++) insSort2(&amp;A[j], n - j, i);    &#125;    insSort2(A, n, 1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>归并排序</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void mergeSort(E A[], E temp[], int left, int right) &#123;    if (left &#x3D;&#x3D; right) return;    int mid &#x3D; (left + right) &#x2F; 2;    mergeSort&lt;E, Comp&gt;(A, temp, left, mid);    mergeSort&lt;E, Comp&gt;(A, temp, mid + 1, right);    for (int i &#x3D; left; i &lt;&#x3D; right; ++i) &#123; temp[i] &#x3D; A[i]; &#125;    int i1 &#x3D; left;    int i2 &#x3D; mid + 1;    for (int curr &#x3D; left; curr &lt;&#x3D; right; curr++) &#123;        if (i1 &#x3D;&#x3D; mid + 1)            A[curr] &#x3D; temp[i2++];        else if (i2 &gt; right)            A[curr] &#x3D; temp[i1++];        else if (Comp::prior(temp[i1], temp[i2]))            A[curr] &#x3D; temp[i1++];        else            A[curr] &#x3D; temp[i2++];    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>快速排序</p></li><li><p>归并排序</p></li></ul><h5 id="图遍历"><a href="#图遍历" class="headerlink" title="图遍历"></a>图遍历</h5><ul><li>DFS（栈）</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void DFS(Graph* G, int v) &#123;    PreVisit(G, v);    G-&gt;setMark(v, VISITED);    for (int w &#x3D; G-&gt;first(v); w &lt; G-&gt;n; w &#x3D; G-&gt;next(v, w)) &#123;        if (G-&gt;getMark(w) &#x3D;&#x3D; UNVISITED) &#123; DFS(G, w); &#125;    &#125;    PostVisit(G, v);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>BFS</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void BFS(Graph* G, int start, Queue&lt;int&gt;* Q) &#123;    int v, w;    Q-&gt;enqueue(start);    G-&gt;setMark(start, VISITED);    while (Q-&gt;length() !&#x3D; 0) &#123;        v &#x3D; Q-&gt;dequeue();        PreVisit(G, v);        for (w &#x3D; G-&gt;first(v); w &lt; G - n(); w &#x3D; G-&gt;next(v, w))            if (G-&gt;getMark(w) &#x3D;&#x3D; VISITED) &#123;                G-&gt;setMark(w, VISIED);                Q-&gt;enqueue(w);            &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h5><ul><li><strong>在浏览器中输入<a href="http://www.baidu.com后执行的全部过程/">www.baidu.com后执行的全部过程</a></strong></li></ul><p>  现在假设如果我们在客户端（客户端）浏览器中输入<a href="http://www.baidu.com,而baidu.com为要访问的服务器（服务器），下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作：">http://www.baidu.com,而baidu.com为要访问的服务器（服务器），下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作：</a></p><p>    1、客户端浏览器通过DNS解析到<a href="http://www.baidu.com的ip地址220.181.27.48,通过这个ip地址找到客户端到服务器的路径.客户端浏览器发起一个http会话到220.161.27.48,然后通过tcp进行封装数据包,输入到网络层./">www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。</a></p><p>    2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。</p><p>    3、客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</p><p>    4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</p><ul><li><strong>TCP三次握手和四次挥手的全过程</strong></li></ul><p>    <strong>三次握手：</strong></p><p>    第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认； </p><p>    第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； </p><p>    第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 </p><p>    握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 </p><p>    <strong>四次挥手</strong></p><p>    与建立连接的”三次握手”类似，断开一个TCP连接则需要”四次握手”。 </p><p>    第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不</p><p>    会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可</p><p>    以接受数据。 </p><p>    第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。</p><p>    第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p><p>    第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p><h5 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h5><ul><li>进程线程区别</li></ul><p>    进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位. </p><p>    线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. </p><p>    一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行 </p><p>        进程是死的，只是一些资源的集合，真正的程序执行都是线程来完成的，程序启动的时候操作系统就帮你创建了一个主线程。每个线程有自己的堆栈。 </p><ul><li>进程通信的方式</li></ul><p>  **管道( pipe )**：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p><p>  有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p><p>  <strong>信号量( semophore )</strong> ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><p>  <strong>消息队列( message queue )</strong> ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p><p>  <strong>信号 ( signal ) ：</strong> 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><p>  <strong>共享内存( shared memory )</strong> ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p><p>  <strong>套接字( socket ) ：</strong> 套解字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信</p><ul><li>线程同步几种方式</li></ul><p>  临界区（CCriticalSection）：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。</p><p>  事件（CEvent）：为协调共同对一个共享资源的单独访问而设计的。</p><p>  互斥量（CMutex）：为控制一个具有有限数量用户资源而设计。</p><p>  信号量（CSemaphore）：用来通知线程有一些事件已发生，从而启动后继任务的开始。</p><h5 id="海量不重复数据的查找和排序"><a href="#海量不重复数据的查找和排序" class="headerlink" title="海量不重复数据的查找和排序"></a>海量不重复数据的查找和排序</h5><p>采用bitmap <a href="http://blog.csdn.net/lingess/article/details/8128133">http://blog.csdn.net/lingess/article/details/8128133</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>v2ray WS TLS Cloudflare节点“加”速</title>
      <link href="2020/02/09/v2ray-WS-TLS-Cloudflare/"/>
      <url>2020/02/09/v2ray-WS-TLS-Cloudflare/</url>
      
        <content type="html"><![CDATA[<p>v2ray WS TLS Cloudflare节点加速</p><p>请通读完整篇文章再开始操作。</p><h1 id="0x00-注册vps"><a href="#0x00-注册vps" class="headerlink" title="0x00 注册vps"></a>0x00 注册vps</h1><p><a href="http://www.vultr.com/">www.vultr.com</a></p><p>通过xshell连接，把默认密码粘贴过来，立即修改密码，并保留。</p><h1 id="0x01-安装并配置宝塔面板"><a href="#0x01-安装并配置宝塔面板" class="headerlink" title="0x01 安装并配置宝塔面板"></a>0x01 安装并配置宝塔面板</h1><h2 id="选择面板版本"><a href="#选择面板版本" class="headerlink" title="选择面板版本"></a>选择面板版本</h2><p>进入宝塔<a href="https://www.bt.cn/bbs/thread-19376-1-1.html">官网</a>，根据Linux发行版，安装对应的面板。宝塔linux7.0版本是基于centos7开发的，务必使用centos7.x 系统</p><p>提示：Centos官方已宣布在2020年停止对Centos6的维护更新，各大软件开发商也逐渐停止对Centos6的兼容，新服务器不建议使用Centos6</p><h2 id="下载安装："><a href="#下载安装：" class="headerlink" title="下载安装："></a>下载安装：</h2><p>CentOS 7参考如下命令：</p><pre class="line-numbers language-none"><code class="language-none">yum install -y wget &amp;&amp; wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install_6.0.sh &amp;&amp; sh install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 安装时，一路默认即可，该输入Y的输入Y。</p><p> 安装完成，会出现面板地址及默认账号与密码，如下图。（注意新版本在端口号后面还有一个字符串，<strong>一定要全部保存</strong>）。</p><pre class="line-numbers language-none"><code class="language-none">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Bt-Panel: http:&#x2F;&#x2F;your_ip:port&#x2F;xxxxxxusername: default_useanamepassword: default_passwd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>完成到这里时，可以用vultr自带的snapshot功能打一个快照，毕竟宝塔安装过程挺枯燥的。</p><h2 id="配置宝塔"><a href="#配置宝塔" class="headerlink" title="配置宝塔"></a>配置宝塔</h2><ul><li>访问<code>Bt-Panel-URL</code>地址，输入账号密码</li><li>安装环境，任选一种即可<ul><li>安装 LNMP 环境+Nignx 配置（可以后期搭建网站做转发）</li><li>只安装 nginx（不做网站转发，只做 ws）</li></ul></li><li>添加站点。这个站点就是你 v2ray 软件里要填的代理地址。推荐使用二级域名，如：<code>ss.example.com</code>。</li></ul><p>下面开始配置过程。</p><p><strong>安装Nignx</strong></p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/03/9LIzKL58/installNginx.png" alt="installNginx"></p><p><strong>添加站点</strong></p><p>添加一个域名，域名的话可以自己购买，或者去找一下免费域名，注册一个，比如<code>.tk</code>、<code>.cf</code>、<code>.ml</code>。当然，还有对域名解析，这里我们暂时先把域名填进去。关于解析，后边会说。</p><p>这里我们添加的是子域名，也就是二级域名。比如你的域名是<code>example.com</code>，随便填上一个二级域名<code>*.example.com</code>，例如，我填入<code>ss.example</code>。</p><p>接下来其他默认就好，直接提交。</p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/03/Iw8kthoc/addSite.png" alt="添加站点"></p><h1 id="0x03-安装V2ray"><a href="#0x03-安装V2ray" class="headerlink" title="0x03 安装V2ray"></a>0x03 安装V2ray</h1><p>这次使用官方脚本来安装 v2ray，不再使用第三方脚本，第三方脚本有不稳定或安全因素。 当然，第三方脚本用起来确实方便许多。使用官方脚本是因为我试过一个第三方脚本，搞了半天没装上去。</p><p><strong>V2ray 官方脚本：</strong></p><pre class="line-numbers language-none"><code class="language-none">bash &lt;(curl -L -s https:&#x2F;&#x2F;install.direct&#x2F;go.sh)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 安装完成后会得到<code>端口</code>和 <code>UUID</code>，这两个都是随机生成的，但是有一定的规则性，不要自己随便修改。<strong>哦，对，这个东西也要记下来。</strong></p><pre class="line-numbers language-none"><code class="language-none">PORT:12345UUID:3dc8036b-c83a-4537-90d2-0d72a017ce09<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>到这里 ，我们已经完成大部分的工作了。当我第一次用官方脚本的时候也发现，竟然如此轻松。</p><h1 id="0x04-配置SSL"><a href="#0x04-配置SSL" class="headerlink" title="0x04 配置SSL"></a>0x04 配置SSL</h1><p>选择 Let’s Encrypt ，推荐使用文件方式验证，输入你的邮箱，如果你的域名 ip 解析正确的话直接点提交就申请 SSL成功了，成功后如图：</p><p><img src="https://img.zhuomu.xyz/view/img/2020/03/03/KLYLUZMP/SSL.png" alt="SSL"> </p><p><strong>修改配置文件</strong></p><p> 修改网站的配置文件，还是这个页面，点击左边的<code>配置文件</code>，找到 <code>#SSL-END</code>注释的地方，大概在 22 行左右，在其下面添加如下代码： </p><pre class="line-numbers language-none"><code class="language-none">location &#x2F;cs&#123;    proxy_pass http:&#x2F;&#x2F;127.0.0.1:你的端口号;    proxy_redirect off;    proxy_http_version 1.1;    proxy_set_header Upgrade $http_upgrade;    proxy_set_header Connection &quot;upgrade&quot;;    proxy_set_header Host $http_host;    proxy_read_timeout 300s;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>第一行的<code>cs</code>是你自己<code>ws</code>的<code>path</code>路径，<code>斜杠</code>不要删除，可以自己修改，也可以不改；</li><li> 还记得用官方脚本安装v2ray后出现的<code>PORT</code>吗，这个<code>PORT</code>后面的就是你的端口号。修改上面代码后保存。</li></ol><p><img src="https://img.zhuomu.xyz/view/img/2020/03/03/Q6uftb3P/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="配置文件"></p><h1 id="0x05-配置V2ray"><a href="#0x05-配置V2ray" class="headerlink" title="0x05 配置V2ray"></a>0x05 配置V2ray</h1><p> 编辑 <code>/etc/v2ray/config.json</code>文件，将里面全部代码改为：</p><p>[collapse status=”false” title=”vim的全选和删除的方法”]</p><ol><li> <strong>全选（高亮显示</strong>）：按esc后，然后ggvG或者ggVG </li><li> <strong>全部删除：</strong>按esc后，然后dG </li></ol><p> <strong>gg：</strong>是让光标移到首行，在<strong>vim</strong>才有效，vi中无效 </p><p> <strong>v ：</strong> 是进入Visual(可视）模式 </p><p> <strong>G ：</strong>光标移到最后一行 </p><p> <strong>选</strong>中内容以后就可以其他的操作了，比如：<br> <strong>d</strong> 删除<strong>选</strong>中内容<br> <strong>y</strong> 复制<strong>选</strong>中内容到0号寄存器<br> <strong>“+y</strong> 复制<strong>选</strong>中内容到＋寄存器，也就是系统的剪贴板，供其他程序用<br>[/collapse]</p><p>[collapse status=”false” title=”config.json”]</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;policy&quot;: &#123;    &quot;levels&quot;: &#123;      &quot;0&quot;: &#123;        &quot;uplinkOnly&quot;: 0,        &quot;downlinkOnly&quot;: 0,        &quot;connIdle&quot;: 150,        &quot;handshake&quot;: 4      &#125;    &#125;  &#125;,  &quot;inbound&quot;: &#123;    &quot;listen&quot;: &quot;127.0.0.1&quot;,    &quot;port&quot;: 31914,    # 这里填写你的 v2ray 端口号，复制脚本请产出这句注释    &quot;protocol&quot;: &quot;vmess&quot;,    &quot;settings&quot;: &#123;      &quot;clients&quot;: [        &#123;          &quot;id&quot;: &quot;e1bc89df-c245-4da6-90cc-2d20ad80a611&quot;,    # 这里填写你的 v2ray UUID，复制脚本请删除这句注释          &quot;level&quot;: 1,          &quot;alterId&quot;: 32        &#125;      ]    &#125;,    &quot;streamSettings&quot;: &#123;      &quot;network&quot;: &quot;ws&quot;,      &quot;security&quot;: &quot;auto&quot;,      &quot;wsSettings&quot;: &#123;        &quot;path&quot;: &quot;&#x2F;cs&quot;,   # 这里填是你自己 ws 的 path,如果修改配置文件的时候没有修改过就不管，复制脚本请删除这句注释        &quot;headers&quot;: &#123;          &quot;Host&quot;: &quot;ss.example.com&quot;  # 这里填写你的域名，复制脚本请删除这句注释        &#125;      &#125;    &#125;  &#125;,  &quot;outbound&quot;: &#123;    &quot;protocol&quot;: &quot;freedom&quot;,    &quot;settings&quot;: &#123; &#125;  &#125;,  &quot;outboundDetour&quot;: [    &#123;      &quot;protocol&quot;: &quot;blackhole&quot;,      &quot;settings&quot;: &#123; &#125;,      &quot;tag&quot;: &quot;blocked&quot;    &#125;  ],  &quot;routing&quot;: &#123;    &quot;strategy&quot;: &quot;rules&quot;,    &quot;settings&quot;: &#123;      &quot;rules&quot;: [        &#123;          &quot;type&quot;: &quot;field&quot;,          &quot;ip&quot;: [            &quot;0.0.0.0&#x2F;8&quot;,            &quot;10.0.0.0&#x2F;8&quot;,            &quot;100.64.0.0&#x2F;10&quot;,            &quot;127.0.0.0&#x2F;8&quot;,            &quot;169.254.0.0&#x2F;16&quot;,            &quot;172.16.0.0&#x2F;12&quot;,            &quot;192.0.0.0&#x2F;24&quot;,            &quot;192.0.2.0&#x2F;24&quot;,            &quot;192.168.0.0&#x2F;16&quot;,            &quot;198.18.0.0&#x2F;15&quot;,            &quot;198.51.100.0&#x2F;24&quot;,            &quot;203.0.113.0&#x2F;24&quot;,            &quot;::1&#x2F;128&quot;,            &quot;fc00::&#x2F;7&quot;,            &quot;fe80::&#x2F;10&quot;          ],          &quot;outboundTag&quot;: &quot;blocked&quot;        &#125;      ]    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[/collapse]</p>]]></content>
      
      
      <categories>
          
          <category> 技术博文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CDN </tag>
            
            <tag> CloudFlare </tag>
            
            <tag> ws </tag>
            
            <tag> tls </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动化工具配置华为云镜像源(x86_64)</title>
      <link href="2019/12/10/auto-huaweicloud-mirros(x86_64)/"/>
      <url>2019/12/10/auto-huaweicloud-mirros(x86_64)/</url>
      
        <content type="html"><![CDATA[<h1 id="操作场景"><a href="#操作场景" class="headerlink" title="操作场景"></a>操作场景</h1><p>更新弹性云服务器的系统或者软件时，可以连接Internet，通过外部镜像源提供相关服务。但是，如果弹性云服务器无法访问Internet，或者外部镜像源提供的服务不稳定时，可以使用华为云提供的一键配置脚本完成镜像源配置并进行更新。</p><h1 id="约束与限制"><a href="#约束与限制" class="headerlink" title="约束与限制"></a>约束与限制</h1><ul><li>请确认已经配置了华为云提供的内网DNS服务器地址。华为云内网DNS地址，请参见<a href="https://support.huaweicloud.com/dns_faq/dns_faq_002.html">华为云提供的内网DNS地址是多少</a>。</li><li>本节操作适用于x86_64架构操作系统的云服务器。</li><li>本节操作适用于x86_64架构操作系统的云服务器。</li><li>当前支持的操作系统版本包括：EulerOS、CentOS、Debian、Ubuntu、openSUSE</li></ul><p><strong>操作步骤</strong></p><ol><li>登录弹性云服务器。</li><li>执行以下命令，一键完成操作系统镜像源的配置。<br><code>wget http://mirrors.myhuaweicloud.com/repo/mirrors_source.sh &amp;&amp; sh mirrors_source.sh</code></li></ol><blockquote><p>参考链接：<a href="https://support.huaweicloud.com/ecs_faq/zh-cn_topic_0118948562.html">https://support.huaweicloud.com/ecs_faq/zh-cn_topic_0118948562.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言运算符优先级</title>
      <link href="2019/10/16/c-operator_precedence/"/>
      <url>2019/10/16/c-operator_precedence/</url>
      
        <content type="html"><![CDATA[<p>我是一个搬运工…<br>@&gt; 参考<a href="https://zh.cppreference.com/w/c/language/operator_precedence">链接</a><br>conver方式：网页复制到word，word复制到excel，excel复制到<a href="http://pressbin.com/tools/excel_to_html_table/index.html">这里</a><br>方法来自<a href="https://www.zhihu.com/question/50267650">知乎</a></p><table>   <tr>      <td>优先级</td>      <td>运算符</td>      <td>描述</td>      <td>结合性</td>   </tr>   <tr>      <td>1</td>      <td>++, --</td>      <td>后缀自增与自减</td>      <td>从左到右</td>   </tr>   <tr>      <td></td>      <td>()</td>      <td>函数调用</td>      <td></td>   </tr>   <tr>      <td></td>      <td>[]</td>      <td>数组下标</td>      <td></td>   </tr>   <tr>      <td></td>      <td>.</td>      <td>结构体与联合体成员访问</td>      <td></td>   </tr>   <tr>      <td></td>      <td>-></td>      <td>结构体与联合体成员通过指针访问</td>      <td></td>   </tr>   <tr>      <td></td>      <td>(type){list}</td>      <td>复合字面量(C99)</td>      <td></td>   </tr>   <tr>      <td>2</td>      <td>++, --</td>      <td>前缀自增与自减[注 1]</td>      <td>从右到左</td>   </tr>   <tr>      <td></td>      <td>+, -</td>      <td>一元加与减</td>      <td></td>   </tr>   <tr>      <td></td>      <td>!, ~</td>      <td>逻辑非与逐位非</td>      <td></td>   </tr>   <tr>      <td></td>      <td>(type)</td>      <td>类型转型</td>      <td></td>   </tr>   <tr>      <td></td>      <td>*</td>      <td>间接（解引用）</td>      <td></td>   </tr>   <tr>      <td></td>      <td>&</td>      <td>取址</td>      <td></td>   </tr>   <tr>      <td></td>      <td>sizeof</td>      <td>取大小[注 2]</td>      <td></td>   </tr>   <tr>      <td></td>      <td>_Alignof</td>      <td>对齐要求(C11)</td>      <td></td>   </tr>   <tr>      <td>3</td>      <td>*, /, %</td>      <td>乘法、除法及余数</td>      <td>从左到右</td>   </tr>   <tr>      <td>4</td>      <td>+, -</td>      <td>加法及减法</td>      <td></td>   </tr>   <tr>      <td>5</td>      <td><<, >></td>      <td>逐位左移及右移</td>      <td></td>   </tr>   <tr>      <td>6</td>      <td>< <=</td>      <td>分别为 < 与 ≤ 的关系运算符</td>      <td></td>   </tr>   <tr>      <td></td>      <td>>, >=</td>      <td>分别为 > 与 ≥ 的关系运算符</td>      <td></td>   </tr>   <tr>      <td>7</td>      <td>==, !=</td>      <td>分别为 = 与 ≠ 关系</td>      <td></td>   </tr>   <tr>      <td>8</td>      <td>&</td>      <td>逐位与</td>      <td></td>   </tr>   <tr>      <td>9</td>      <td>^</td>      <td>逐位异或（排除或）</td>      <td></td>   </tr>   <tr>      <td>10</td>      <td>|</td>      <td>逐位或（包含或）</td>      <td></td>   </tr>   <tr>      <td>11</td>      <td>&&</td>      <td>逻辑与</td>      <td></td>   </tr>   <tr>      <td>12</td>      <td>||</td>      <td>逻辑或</td>      <td></td>   </tr>   <tr>      <td>13</td>      <td>?:</td>      <td>三元条件[注 3]</td>      <td>从右到左</td>   </tr>   <tr>      <td>14</td>      <td>=</td>      <td>简单赋值</td>      <td></td>   </tr>   <tr>      <td></td>      <td>+=, -=</td>      <td>以和及差赋值</td>      <td></td>   </tr>   <tr>      <td></td>      <td>*=, /=, %=</td>      <td>以积、商及余数赋值</td>      <td></td>   </tr>   <tr>      <td></td>      <td><<= >>=</td>      <td>以逐位左移及右移赋值</td>      <td></td>   </tr>   <tr>      <td></td>      <td>&=, ^=, |=</td>      <td>以逐位与、异或及或赋值</td>      <td></td>   </tr>   <tr>      <td>15</td>      <td>,</td>      <td>逗号</td>      <td>从左到右</td>   </tr></table>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【完全版】线段树</title>
      <link href="2019/09/18/full-segment-tree/"/>
      <url>2019/09/18/full-segment-tree/</url>
      
        <content type="html"><![CDATA[<p><strong>转载自：NotOnlySuccess的博客</strong><br>很早前写的那篇线段树专辑至今一直是本博客阅读点击量最大的一片文章,当时觉得挺自豪的,还去pku打广告,但是现在我自己都不太好意思去看那篇文章了,觉得当时的代码风格实在是太丑了,很多线段树的初学者可能就是看着这篇文章来练习的,如果不小心被我培养出了这么糟糕的风格,实在是过意不去,正好过几天又要给集训队讲解线段树,所以决定把这些题目重新写一遍,顺便把近年我接触到的一些新题更新上去~;并且学习了splay等更高级的数据结构后对线段树的体会有更深了一层,线段树的写法也就比以前飘逸,简洁且方便多了.</p><a id="more"></a><p>在代码前先介绍一些我的线段树风格:</p><p>maxn是题目给的最大区间,而节点数要开4倍,确切的来说节点数要开大于maxn的最小2x的两倍</p><p>lson和rson分辨表示结点的左儿子和右儿子,由于每次传参数的时候都固定是这几个变量,所以可以用预定于比较方便的表示</p><p>以前的写法是另外开两个个数组记录每个结点所表示的区间,其实这个区间不必保存,一边算一边传下去就行,只需要写函数的时候多两个参数,结合lson和rson的预定义可以很方便</p><p>PushUP(int rt)是把当前结点的信息更新到父结点</p><p>PushDown(int rt)是把当前结点的信息更新给儿子结点</p><p>rt表示当前子树的根(root),也就是当前所在的结点</p><p>整理这些题目后我觉得线段树的题目整体上可以分成以下四个部分:</p><p>单点更新:最最基础的线段树,只更新叶子节点,然后把信息用PushUP(int r)这个函数更新上来</p><h1 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h1><h2 id="hdu1166-敌兵布阵"><a href="#hdu1166-敌兵布阵" class="headerlink" title="hdu1166 敌兵布阵"></a>hdu1166 敌兵布阵</h2><p>题意:O(-1)</p><p>思路:O(-1)</p><p>线段树功能:update:单点增减 query:区间求和</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;#define lson l , m , rt &lt;&lt; 1#define rson m + 1 , r , rt &lt;&lt; 1 | 1const int maxn &#x3D; 55555;int sum[maxn &lt;&lt; 2];void PushUP(int rt) &#123;    sum[rt] &#x3D; sum[rt &lt;&lt; 1] + sum[rt &lt;&lt; 1 | 1];&#125;void build(int l, int r, int rt) &#123;    if (l &#x3D;&#x3D; r) &#123;        scanf(&quot;%d&quot;, &amp;sum[rt]);        return ;    &#125;    int m &#x3D; (l + r) &gt;&gt; 1;    build(lson);    build(rson);    PushUP(rt);&#125;void update(int p, int add, int l, int r, int rt) &#123;    if (l &#x3D;&#x3D; r) &#123;        sum[rt] +&#x3D; add;        return ;    &#125;    int m &#x3D; (l + r) &gt;&gt; 1;    if (p &lt;&#x3D; m) update(p , add , lson);    else update(p , add , rson);    PushUP(rt);&#125;int query(int L, int R, int l, int r, int rt) &#123;    if (L &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; R) &#123;        return sum[rt];    &#125;    int m &#x3D; (l + r) &gt;&gt; 1;    int ret &#x3D; 0;    if (L &lt;&#x3D; m) ret +&#x3D; query(L , R , lson);    if (R &gt; m) ret +&#x3D; query(L , R , rson);    return ret;&#125;int main() &#123;    int T , n;    scanf(&quot;%d&quot;, &amp;T);    for (int cas &#x3D; 1 ; cas &lt;&#x3D; T ; cas ++) &#123;        printf(&quot;Case %d:\n&quot;, cas);        scanf(&quot;%d&quot;, &amp;n);        build(1 , n , 1);        char op[10];        while (scanf(&quot;%s&quot;, op)) &#123;            if (op[0] &#x3D;&#x3D; &#39;E&#39;) break;            int a , b;            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);            if (op[0] &#x3D;&#x3D; &#39;Q&#39;) printf(&quot;%d\n&quot;, query(a , b , 1 , n , 1));            else if (op[0] &#x3D;&#x3D; &#39;S&#39;) update(a , -b , 1 , n , 1);            else update(a , b , 1 , n , 1);        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="hdu1754-I-Hate-It"><a href="#hdu1754-I-Hate-It" class="headerlink" title="hdu1754 I Hate It"></a>hdu1754 I Hate It</h2><p>题意:O(-1)</p><p>思路:O(-1)</p><p>线段树功能:update:单点替换 query:区间最值</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define lson l , m , rt &lt;&lt; 1#define rson m + 1 , r , rt &lt;&lt; 1 | 1const int maxn &#x3D; 222222;int MAX[maxn &lt;&lt; 2];void PushUP(int rt) &#123;    MAX[rt] &#x3D; max(MAX[rt &lt;&lt; 1] , MAX[rt &lt;&lt; 1 | 1]);&#125;void build(int l, int r, int rt) &#123;    if (l &#x3D;&#x3D; r) &#123;        scanf(&quot;%d&quot;, &amp;MAX[rt]);        return ;    &#125;    int m &#x3D; (l + r) &gt;&gt; 1;    build(lson);    build(rson);    PushUP(rt);&#125;void update(int p, int sc, int l, int r, int rt) &#123;    if (l &#x3D;&#x3D; r) &#123;        MAX[rt] &#x3D; sc;        return ;    &#125;    int m &#x3D; (l + r) &gt;&gt; 1;    if (p &lt;&#x3D; m) update(p , sc , lson);    else update(p , sc , rson);    PushUP(rt);&#125;int query(int L, int R, int l, int r, int rt) &#123;    if (L &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; R) &#123;        return MAX[rt];    &#125;    int m &#x3D; (l + r) &gt;&gt; 1;    int ret &#x3D; 0;    if (L &lt;&#x3D; m) ret &#x3D; max(ret , query(L , R , lson));    if (R &gt; m) ret &#x3D; max(ret , query(L , R , rson));    return ret;&#125;int main() &#123;    int n , m;    while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) &#123;        build(1 , n , 1);        while (m --) &#123;            char op[2];            int a , b;            scanf(&quot;%s%d%d&quot;, op, &amp;a, &amp;b);            if (op[0] &#x3D;&#x3D; &#39;Q&#39;) printf(&quot;%d\n&quot;, query(a , b , 1 , n , 1));            else update(a , b , 1 , n , 1);        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="hdu1394-Minimum-Inversion-Number"><a href="#hdu1394-Minimum-Inversion-Number" class="headerlink" title="hdu1394 Minimum Inversion Number"></a>hdu1394 Minimum Inversion Number</h2><p>题意:求Inversion后的最小逆序数</p><p>思路:用O(nlogn)复杂度求出最初逆序数后,就可以用O(1)的复杂度分别递推出其他解</p><p>线段树功能:update:单点增减 query:区间求和</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define lson l , m , rt &lt;&lt; 1#define rson m + 1 , r , rt &lt;&lt; 1 | 1const int maxn &#x3D; 5555;int sum[maxn &lt;&lt; 2];void PushUP(int rt) &#123;    sum[rt] &#x3D; sum[rt &lt;&lt; 1] + sum[rt &lt;&lt; 1 | 1];&#125;void build(int l, int r, int rt) &#123;    sum[rt] &#x3D; 0;    if (l &#x3D;&#x3D; r) return ;    int m &#x3D; (l + r) &gt;&gt; 1;    build(lson);    build(rson);&#125;void update(int p, int l, int r, int rt) &#123;    if (l &#x3D;&#x3D; r) &#123;        sum[rt] ++;        return ;    &#125;    int m &#x3D; (l + r) &gt;&gt; 1;    if (p &lt;&#x3D; m) update(p , lson);    else update(p , rson);    PushUP(rt);&#125;int query(int L, int R, int l, int r, int rt) &#123;    if (L &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; R) &#123;        return sum[rt];    &#125;    int m &#x3D; (l + r) &gt;&gt; 1;    int ret &#x3D; 0;    if (L &lt;&#x3D; m) ret +&#x3D; query(L , R , lson);    if (R &gt; m) ret +&#x3D; query(L , R , rson);    return ret;&#125;int x[maxn];int main() &#123;    int n;    while (~scanf(&quot;%d&quot;, &amp;n)) &#123;        build(0 , n - 1 , 1);        int sum &#x3D; 0;        for (int i &#x3D; 0 ; i &lt; n ; i ++) &#123;            scanf(&quot;%d&quot;, &amp;x[i]);            sum +&#x3D; query(x[i] , n - 1 , 0 , n - 1 , 1);            update(x[i] , 0 , n - 1 , 1);        &#125;        int ret &#x3D; sum;        for (int i &#x3D; 0 ; i &lt; n ; i ++) &#123;            sum +&#x3D; n - x[i] - x[i] - 1;            ret &#x3D; min(ret , sum);        &#125;        printf(&quot;%d\n&quot;, ret);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="hdu2795-Billboard"><a href="#hdu2795-Billboard" class="headerlink" title="hdu2795 Billboard"></a>hdu2795 Billboard</h2><p>题意:h<em>w的木板,放进一些1</em>L的物品,求每次放空间能容纳且最上边的位子</p><p>思路:每次找到最大值的位子,然后减去L</p><p>线段树功能:query:区间求最大值的位子(直接把update的操作在query里做了)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define lson l , m , rt &lt;&lt; 1#define rson m + 1 , r , rt &lt;&lt; 1 | 1const int maxn &#x3D; 222222;int h , w , n;int MAX[maxn &lt;&lt; 2];void PushUP(int rt) &#123;    MAX[rt] &#x3D; max(MAX[rt &lt;&lt; 1] , MAX[rt &lt;&lt; 1 | 1]);&#125;void build(int l, int r, int rt) &#123;    MAX[rt] &#x3D; w;    if (l &#x3D;&#x3D; r) return ;    int m &#x3D; (l + r) &gt;&gt; 1;    build(lson);    build(rson);&#125;int query(int x, int l, int r, int rt) &#123;    if (l &#x3D;&#x3D; r) &#123;        MAX[rt] -&#x3D; x;        return l;    &#125;    int m &#x3D; (l + r) &gt;&gt; 1;    int ret &#x3D; (MAX[rt &lt;&lt; 1] &gt;&#x3D; x) ? query(x , lson) : query(x , rson);    PushUP(rt);    return ret;&#125;int main() &#123;    while (~scanf(&quot;%d%d%d&quot;, &amp;h, &amp;w, &amp;n)) &#123;        if (h &gt; n) h &#x3D; n;        build(1 , h , 1);        while (n --) &#123;            int x;            scanf(&quot;%d&quot;, &amp;x);            if (MAX[1] &lt; x) puts(&quot;-1&quot;);            else printf(&quot;%d\n&quot;, query(x , 1 , h , 1));        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="练习"><a href="#练习" class="headerlink" title="练习:"></a>练习:</h2><p>poj2828 Buy Tickets</p><p>poj2886 Who Gets the Most Candies?</p><p>/*<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p><h1 id="成段更新"><a href="#成段更新" class="headerlink" title="成段更新"></a>成段更新</h1><p>(通常这对初学者来说是一道坎),需要用到延迟标记(或者说懒惰标记),简单来说就是每次更新的时候不要更新到底,用延迟标记使得更新延迟到下次需要更新or询问到的时候</p><h2 id="hdu1698-Just-a-Hook"><a href="#hdu1698-Just-a-Hook" class="headerlink" title="hdu1698 Just a Hook"></a>hdu1698 Just a Hook</h2><p>题意:O(-1)</p><p>思路:O(-1)</p><p>线段树功能:update:成段替换 (由于只query一次总区间,所以可以直接输出1结点的信息)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define lson l , m , rt &lt;&lt; 1#define rson m + 1 , r , rt &lt;&lt; 1 | 1const int maxn &#x3D; 111111;int h , w , n;int col[maxn &lt;&lt; 2];int sum[maxn &lt;&lt; 2];void PushUp(int rt) &#123;    sum[rt] &#x3D; sum[rt &lt;&lt; 1] + sum[rt &lt;&lt; 1 | 1];&#125;void PushDown(int rt, int m) &#123;    if (col[rt]) &#123;        col[rt &lt;&lt; 1] &#x3D; col[rt &lt;&lt; 1 | 1] &#x3D; col[rt];        sum[rt &lt;&lt; 1] &#x3D; (m - (m &gt;&gt; 1)) * col[rt];        sum[rt &lt;&lt; 1 | 1] &#x3D; (m &gt;&gt; 1) * col[rt];        col[rt] &#x3D; 0;    &#125;&#125;void build(int l, int r, int rt) &#123;    col[rt] &#x3D; 0;    sum[rt] &#x3D; 1;    if (l &#x3D;&#x3D; r) return ;    int m &#x3D; (l + r) &gt;&gt; 1;    build(lson);    build(rson);    PushUp(rt);&#125;void update(int L, int R, int c, int l, int r, int rt) &#123;    if (L &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; R) &#123;        col[rt] &#x3D; c;        sum[rt] &#x3D; c * (r - l + 1);        return ;    &#125;    PushDown(rt , r - l + 1);    int m &#x3D; (l + r) &gt;&gt; 1;    if (L &lt;&#x3D; m) update(L , R , c , lson);    if (R &gt; m) update(L , R , c , rson);    PushUp(rt);&#125;int main() &#123;    int T , n , m;    scanf(&quot;%d&quot;, &amp;T);    for (int cas &#x3D; 1 ; cas &lt;&#x3D; T ; cas ++) &#123;        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        build(1 , n , 1);        while (m --) &#123;            int a , b , c;            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);            update(a , b , c , 1 , n , 1);        &#125;        printf(&quot;Case %d: The total value of the hook is %d.\n&quot;, cas , sum[1]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="poj3468-A-Simple-Problem-with-Integers"><a href="#poj3468-A-Simple-Problem-with-Integers" class="headerlink" title="poj3468 A Simple Problem with Integers"></a>poj3468 A Simple Problem with Integers</h2><p>题意:O(-1)</p><p>思路:O(-1)</p><p>线段树功能:update:成段增减 query:区间求和</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define lson l , m , rt &lt;&lt; 1#define rson m + 1 , r , rt &lt;&lt; 1 | 1#define LL long longconst int maxn &#x3D; 111111;LL add[maxn &lt;&lt; 2];LL sum[maxn &lt;&lt; 2];void PushUp(int rt) &#123;    sum[rt] &#x3D; sum[rt &lt;&lt; 1] + sum[rt &lt;&lt; 1 | 1];&#125;void PushDown(int rt, int m) &#123;    if (add[rt]) &#123;        add[rt &lt;&lt; 1] +&#x3D; add[rt];        add[rt &lt;&lt; 1 | 1] +&#x3D; add[rt];        sum[rt &lt;&lt; 1] +&#x3D; add[rt] * (m - (m &gt;&gt; 1));        sum[rt &lt;&lt; 1 | 1] +&#x3D; add[rt] * (m &gt;&gt; 1);        add[rt] &#x3D; 0;    &#125;&#125;void build(int l, int r, int rt) &#123;    add[rt] &#x3D; 0;    if (l &#x3D;&#x3D; r) &#123;        scanf(&quot;%lld&quot;, &amp;sum[rt]);        return ;    &#125;    int m &#x3D; (l + r) &gt;&gt; 1;    build(lson);    build(rson);    PushUp(rt);&#125;void update(int L, int R, int c, int l, int r, int rt) &#123;    if (L &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; R) &#123;        add[rt] +&#x3D; c;        sum[rt] +&#x3D; (LL)c * (r - l + 1);        return ;    &#125;    PushDown(rt , r - l + 1);    int m &#x3D; (l + r) &gt;&gt; 1;    if (L &lt;&#x3D; m) update(L , R , c , lson);    if (m &lt; R) update(L , R , c , rson);    PushUp(rt);&#125;LL query(int L, int R, int l, int r, int rt) &#123;    if (L &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; R) &#123;        return sum[rt];    &#125;    PushDown(rt , r - l + 1);    int m &#x3D; (l + r) &gt;&gt; 1;    LL ret &#x3D; 0;    if (L &lt;&#x3D; m) ret +&#x3D; query(L , R , lson);    if (m &lt; R) ret +&#x3D; query(L , R , rson);    return ret;&#125;int main() &#123;    int N , Q;    scanf(&quot;%d%d&quot;, &amp;N, &amp;Q);    build(1 , N , 1);    while (Q --) &#123;        char op[2];        int a , b , c;        scanf(&quot;%s&quot;, op);        if (op[0] &#x3D;&#x3D; &#39;Q&#39;) &#123;            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);            printf(&quot;%lld\n&quot;, query(a , b , 1 , N , 1));        &#125; else &#123;            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);            update(a , b , c , 1 , N , 1);        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="poj2528-Mayor’s-posters"><a href="#poj2528-Mayor’s-posters" class="headerlink" title="poj2528 Mayor’s posters"></a>poj2528 Mayor’s posters</h2><p>题意:在墙上贴海报,海报可以互相覆盖,问最后可以看见几张海报</p><p>思路:这题数据范围很大,直接搞超时+超内存,需要离散化:</p><p>离散化简单的来说就是只取我们需要的值来用,比如说区间[1000,2000],[1990,2012] 我们用不到[-∞,999][1001,1989][1991,1999][2001,2011][2013,+∞]这些值,所以我只需要1000,1990,2000,2012就够了,将其分别映射到0,1,2,3,在于复杂度就大大的降下来了</p><p>所以离散化要保存所有需要用到的值,排序后,分别映射到1~n,这样复杂度就会小很多很多</p><p>而这题的难点在于每个数字其实表示的是一个单位长度(并且一个点),这样普通的离散化会造成许多错误(包括我以前的代码,poj这题数据奇弱)</p><p>给出下面两个简单的例子应该能体现普通离散化的缺陷:</p><p>1-10 1-4 5-10</p><p>1-10 1-4 6-10</p><p>为了解决这种缺陷,我们可以在排序后的数组上加些处理,比如说[1,2,6,10]</p><p>如果相邻数字间距大于1的话,在其中加上任意一个数字,比如加成[1,2,3,6,7,10],然后再做线段树就好了.</p><p>线段树功能:update:成段替换 query:简单hash</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define lson l , m , rt &lt;&lt; 1#define rson m + 1 , r , rt &lt;&lt; 1 | 1const int maxn &#x3D; 11111;bool hash[maxn];int li[maxn] , ri[maxn];int X[maxn * 3];int col[maxn &lt;&lt; 4];int cnt;void PushDown(int rt) &#123;    if (col[rt] !&#x3D; -1) &#123;        col[rt &lt;&lt; 1] &#x3D; col[rt &lt;&lt; 1 | 1] &#x3D; col[rt];        col[rt] &#x3D; -1;    &#125;&#125;void update(int L, int R, int c, int l, int r, int rt) &#123;    if (L &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; R) &#123;        col[rt] &#x3D; c;        return ;    &#125;    PushDown(rt);    int m &#x3D; (l + r) &gt;&gt; 1;    if (L &lt;&#x3D; m) update(L , R , c , lson);    if (m &lt; R) update(L , R , c , rson);&#125;void query(int l, int r, int rt) &#123;    if (col[rt] !&#x3D; -1) &#123;        if (!hash[col[rt]]) cnt ++;        hash[ col[rt] ] &#x3D; true;        return ;    &#125;    if (l &#x3D;&#x3D; r) return ;    int m &#x3D; (l + r) &gt;&gt; 1;    query(lson);    query(rson);&#125;int Bin(int key, int n, int X[]) &#123;    int l &#x3D; 0 , r &#x3D; n - 1;    while (l &lt;&#x3D; r) &#123;        int m &#x3D; (l + r) &gt;&gt; 1;        if (X[m] &#x3D;&#x3D; key) return m;        if (X[m] &lt; key) l &#x3D; m + 1;        else r &#x3D; m - 1;    &#125;    return -1;&#125;int main() &#123;    int T , n;    scanf(&quot;%d&quot;, &amp;T);    while (T --) &#123;        scanf(&quot;%d&quot;, &amp;n);        int nn &#x3D; 0;        for (int i &#x3D; 0 ; i &lt; n ; i ++) &#123;            scanf(&quot;%d%d&quot;, &amp;li[i] , &amp;ri[i]);            X[nn++] &#x3D; li[i];            X[nn++] &#x3D; ri[i];        &#125;        sort(X , X + nn);        int m &#x3D; 1;        for (int i &#x3D; 1 ; i &lt; nn; i ++) &#123;            if (X[i] !&#x3D; X[i - 1]) X[m ++] &#x3D; X[i];        &#125;        for (int i &#x3D; m - 1 ; i &gt; 0 ; i --) &#123;            if (X[i] !&#x3D; X[i - 1] + 1) X[m ++] &#x3D; X[i] + 1;        &#125;        sort(X , X + m);        memset(col , -1 , sizeof(col));        for (int i &#x3D; 0 ; i &lt; n ; i ++) &#123;            int l &#x3D; Bin(li[i] , m , X);            int r &#x3D; Bin(ri[i] , m , X);            update(l , r , i , 0 , m , 1);        &#125;        cnt &#x3D; 0;        memset(hash , false , sizeof(hash));        query(0 , m , 1);        printf(&quot;%d\n&quot;, cnt);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>poj3225 Help with Intervals</p><p>题意:区间操作,交,并,补等</p><p>思路:</p><p>我们一个一个操作来分析:(用0和1表示是否包含区间,-1表示该区间内既有包含又有不包含)</p><p>U:把区间[l,r]覆盖成1</p><p>I:把[-∞,l)(r,∞]覆盖成0</p><p>D:把区间[l,r]覆盖成0</p><p>C:把[-∞,l)(r,∞]覆盖成0 , 且[l,r]区间0/1互换</p><p>S:[l,r]区间0/1互换</p><p>成段覆盖的操作很简单,比较特殊的就是区间0/1互换这个操作,我们可以称之为异或操作</p><p>很明显我们可以知道这个性质:当一个区间被覆盖后,不管之前有没有异或标记都没有意义了</p><p>所以当一个节点得到覆盖标记时把异或标记清空</p><p>而当一个节点得到异或标记的时候,先判断覆盖标记,如果是0或1,直接改变一下覆盖标记,不然的话改变异或标记</p><p>开区间闭区间只要数字乘以2就可以处理(偶数表示端点,奇数表示两端点间的区间)</p><p>线段树功能:update:成段替换,区间异或 query:简单hash</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;#define lson l , m , rt &lt;&lt; 1#define rson m + 1 , r , rt &lt;&lt; 1 | 1const int maxn &#x3D; 131072;bool hash[maxn];int cover[maxn &lt;&lt; 2];int XOR[maxn &lt;&lt; 2];void FXOR(int rt) &#123;    if (cover[rt] !&#x3D; -1) cover[rt] ^&#x3D; 1;    else XOR[rt] ^&#x3D; 1;&#125;void PushDown(int rt) &#123;    if (cover[rt] !&#x3D; -1) &#123;        cover[rt &lt;&lt; 1] &#x3D; cover[rt &lt;&lt; 1 | 1] &#x3D; cover[rt];        XOR[rt &lt;&lt; 1] &#x3D; XOR[rt &lt;&lt; 1 | 1] &#x3D; 0;        cover[rt] &#x3D; -1;    &#125;    if (XOR[rt]) &#123;        FXOR(rt &lt;&lt; 1);        FXOR(rt &lt;&lt; 1 | 1);        XOR[rt] &#x3D; 0;    &#125;&#125;void update(char op, int L, int R, int l, int r, int rt) &#123;    if (L &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; R) &#123;        if (op &#x3D;&#x3D; &#39;U&#39;) &#123;            cover[rt] &#x3D; 1;            XOR[rt] &#x3D; 0;        &#125; else if (op &#x3D;&#x3D; &#39;D&#39;) &#123;            cover[rt] &#x3D; 0;            XOR[rt] &#x3D; 0;        &#125; else if (op &#x3D;&#x3D; &#39;C&#39; || op &#x3D;&#x3D; &#39;S&#39;) &#123;            FXOR(rt);        &#125;        return ;    &#125;    PushDown(rt);    int m &#x3D; (l + r) &gt;&gt; 1;    if (L &lt;&#x3D; m) update(op , L , R , lson);    else if (op &#x3D;&#x3D; &#39;I&#39; || op &#x3D;&#x3D; &#39;C&#39;) &#123;        XOR[rt &lt;&lt; 1] &#x3D; cover[rt &lt;&lt; 1] &#x3D; 0;    &#125;    if (m &lt; R) update(op , L , R , rson);    else if (op &#x3D;&#x3D; &#39;I&#39; || op &#x3D;&#x3D; &#39;C&#39;) &#123;        XOR[rt &lt;&lt; 1 | 1] &#x3D; cover[rt &lt;&lt; 1 | 1] &#x3D; 0;    &#125;&#125;void query(int l, int r, int rt) &#123;    if (cover[rt] &#x3D;&#x3D; 1) &#123;        for (int it &#x3D; l ; it &lt;&#x3D; r ; it ++) &#123;            hash[it] &#x3D; true;        &#125;        return ;    &#125; else if (cover[rt] &#x3D;&#x3D; 0) return ;    if (l &#x3D;&#x3D; r) return ;    PushDown(rt);    int m &#x3D; (l + r) &gt;&gt; 1;    query(lson);    query(rson);&#125;int main() &#123;    cover[1] &#x3D; XOR[1] &#x3D; 0;    char op , l , r;    int a , b;    while ( ~scanf(&quot;%c %c%d,%d%c\n&quot;, &amp;op , &amp;l , &amp;a , &amp;b , &amp;r) ) &#123;        a &lt;&lt;&#x3D; 1 , b &lt;&lt;&#x3D; 1;        if (l &#x3D;&#x3D; &#39;(&#39;) a ++;        if (r &#x3D;&#x3D; &#39;)&#39;) b --;        if (a &gt; b) &#123;            if (op &#x3D;&#x3D; &#39;C&#39; || op &#x3D;&#x3D; &#39;I&#39;) &#123;                cover[1] &#x3D; XOR[1] &#x3D; 0;            &#125;        &#125; else update(op , a , b , 0 , maxn , 1);    &#125;    query(0 , maxn , 1);    bool flag &#x3D; false;    int s &#x3D; -1 , e;    for (int i &#x3D; 0 ; i &lt;&#x3D; maxn ; i ++) &#123;        if (hash[i]) &#123;            if (s &#x3D;&#x3D; -1) s &#x3D; i;            e &#x3D; i;        &#125; else &#123;            if (s !&#x3D; -1) &#123;                if (flag) printf(&quot; &quot;);                flag &#x3D; true;                printf(&quot;%c%d,%d%c&quot;, s &amp; 1 ? &#39;(&#39; : &#39;[&#39; , s &gt;&gt; 1 , (e + 1) &gt;&gt; 1 , e &amp; 1 ? &#39;)&#39; : &#39;]&#39;);                s &#x3D; -1;            &#125;        &#125;    &#125;    if (!flag) printf(&quot;empty set&quot;);    puts(&quot;&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习:"></a>练习:</h2><p>poj1436 Horizontally Visible Segments</p><p>poj2991 Crane</p><p>Another LCIS</p><p>Bracket Sequence</p><h1 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h1><p>这类题目会询问区间中满足条件的连续最长区间,所以PushUp的时候需要对左右儿子的区间进行合并</p><h2 id="poj3667-Hotel"><a href="#poj3667-Hotel" class="headerlink" title="poj3667 Hotel"></a>poj3667 Hotel</h2><p>题意:1 a:询问是不是有连续长度为a的空房间,有的话住进最左边</p><p>2 a b:将[a,a+b-1]的房间清空</p><p>思路:记录区间中最长的空房间</p><p>线段树操作:update:区间替换 query:询问满足条件的最左断点</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;#define lson l , m , rt &lt;&lt; 1#define rson m + 1 , r , rt &lt;&lt; 1 | 1const int maxn &#x3D; 55555;int lsum[maxn &lt;&lt; 2] , rsum[maxn &lt;&lt; 2] , msum[maxn &lt;&lt; 2];int cover[maxn &lt;&lt; 2];void PushDown(int rt, int m) &#123;    if (cover[rt] !&#x3D; -1) &#123;        cover[rt &lt;&lt; 1] &#x3D; cover[rt &lt;&lt; 1 | 1] &#x3D; cover[rt];        msum[rt &lt;&lt; 1] &#x3D; lsum[rt &lt;&lt; 1] &#x3D; rsum[rt &lt;&lt; 1] &#x3D; cover[rt] ? 0 : m - (m &gt;&gt; 1);        msum[rt &lt;&lt; 1 | 1] &#x3D; lsum[rt &lt;&lt; 1 | 1] &#x3D; rsum[rt &lt;&lt; 1 | 1] &#x3D; cover[rt] ? 0 : (m &gt;&gt; 1);        cover[rt] &#x3D; -1;    &#125;&#125;void PushUp(int rt, int m) &#123;    lsum[rt] &#x3D; lsum[rt &lt;&lt; 1];    rsum[rt] &#x3D; rsum[rt &lt;&lt; 1 | 1];    if (lsum[rt] &#x3D;&#x3D; m - (m &gt;&gt; 1)) lsum[rt] +&#x3D; lsum[rt &lt;&lt; 1 | 1];    if (rsum[rt] &#x3D;&#x3D; (m &gt;&gt; 1)) rsum[rt] +&#x3D; rsum[rt &lt;&lt; 1];    msum[rt] &#x3D; max(lsum[rt &lt;&lt; 1 | 1] + rsum[rt &lt;&lt; 1] , max(msum[rt &lt;&lt; 1] , msum[rt &lt;&lt; 1 | 1]));&#125;void build(int l, int r, int rt) &#123;    msum[rt] &#x3D; lsum[rt] &#x3D; rsum[rt] &#x3D; r - l + 1;    cover[rt] &#x3D; -1;    if (l &#x3D;&#x3D; r) return ;    int m &#x3D; (l + r) &gt;&gt; 1;    build(lson);    build(rson);&#125;void update(int L, int R, int c, int l, int r, int rt) &#123;    if (L &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; R) &#123;        msum[rt] &#x3D; lsum[rt] &#x3D; rsum[rt] &#x3D; c ? 0 : r - l + 1;        cover[rt] &#x3D; c;        return ;    &#125;    PushDown(rt , r - l + 1);    int m &#x3D; (l + r) &gt;&gt; 1;    if (L &lt;&#x3D; m) update(L , R , c , lson);    if (m &lt; R) update(L , R , c , rson);    PushUp(rt , r - l + 1);&#125;int query(int w, int l, int r, int rt) &#123;    if (l &#x3D;&#x3D; r) return l;    PushDown(rt , r - l + 1);    int m &#x3D; (l + r) &gt;&gt; 1;    if (msum[rt &lt;&lt; 1] &gt;&#x3D; w) return query(w , lson);    else if (rsum[rt &lt;&lt; 1] + lsum[rt &lt;&lt; 1 | 1] &gt;&#x3D; w) return m - rsum[rt &lt;&lt; 1] + 1;    return query(w , rson);&#125;int main() &#123;    int n , m;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    build(1 , n , 1);    while (m --) &#123;        int op , a , b;        scanf(&quot;%d&quot;, &amp;op);        if (op &#x3D;&#x3D; 1) &#123;            scanf(&quot;%d&quot;, &amp;a);            if (msum[1] &lt; a) puts(&quot;0&quot;);            else &#123;                int p &#x3D; query(a , 1 , n , 1);                printf(&quot;%d\n&quot;, p);                update(p , p + a - 1 , 1 , 1 , n , 1);            &#125;        &#125; else &#123;            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);            update(a , a + b - 1 , 0 , 1 , n , 1);        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习:"></a>练习:</h2><p>hdu3308 LCIS</p><p>hdu3397 Sequence operation</p><p>hdu2871 Memory Control</p><p>hdu1540 Tunnel Warfare</p><p>CF46-D Parking Lot</p><h1 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h1><p>这类题目需要将一些操作排序,然后从左到右用一根扫描线(当然是在我们脑子里)扫过去</p><p>最典型的就是矩形面积并,周长并等题</p><h2 id="hdu1542-Atlantis"><a href="#hdu1542-Atlantis" class="headerlink" title="hdu1542 Atlantis"></a>hdu1542 Atlantis</h2><p>题意:矩形面积并</p><p>思路:浮点数先要离散化;然后把矩形分成两条边,上边和下边,对横轴建树,然后从下到上扫描上去,用cnt表示该区间下边比上边多几个</p><p>线段树操作:update:区间增减 query:直接取根节点的值</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;#define lson l , m , rt &lt;&lt; 1#define rson m + 1 , r , rt &lt;&lt; 1 | 1const int maxn &#x3D; 2222;int cnt[maxn &lt;&lt; 2];double sum[maxn &lt;&lt; 2];double X[maxn];struct Seg &#123;    double h , l , r;    int s;    Seg() &#123;&#125;    Seg(double a, double b, double c, int d) : l(a) , r(b) , h(c) , s(d) &#123;&#125;    bool operator &lt; (const Seg &amp;cmp) const &#123;        return h &lt; cmp.h;    &#125;&#125; ss[maxn];void PushUp(int rt, int l, int r) &#123;    if (cnt[rt]) sum[rt] &#x3D; X[r + 1] - X[l];    else if (l &#x3D;&#x3D; r) sum[rt] &#x3D; 0;    else sum[rt] &#x3D; sum[rt &lt;&lt; 1] + sum[rt &lt;&lt; 1 | 1];&#125;void update(int L, int R, int c, int l, int r, int rt) &#123;    if (L &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; R) &#123;        cnt[rt] +&#x3D; c;        PushUp(rt , l , r);        return ;    &#125;    int m &#x3D; (l + r) &gt;&gt; 1;    if (L &lt;&#x3D; m) update(L , R , c , lson);    if (m &lt; R) update(L , R , c , rson);    PushUp(rt , l , r);&#125;int Bin(double key, int n, double X[]) &#123;    int l &#x3D; 0 , r &#x3D; n - 1;    while (l &lt;&#x3D; r) &#123;        int m &#x3D; (l + r) &gt;&gt; 1;        if (X[m] &#x3D;&#x3D; key) return m;        if (X[m] &lt; key) l &#x3D; m + 1;        else r &#x3D; m - 1;    &#125;    return -1;&#125;int main() &#123;    int n , cas &#x3D; 1;    while (~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) &#123;        int m &#x3D; 0;        while (n --) &#123;            double a , b , c , d;            scanf(&quot;%lf%lf%lf%lf&quot;, &amp;a, &amp;b, &amp;c, &amp;d);            X[m] &#x3D; a;            ss[m++] &#x3D; Seg(a , c , b , 1);            X[m] &#x3D; c;            ss[m++] &#x3D; Seg(a , c , d , -1);        &#125;        sort(X , X + m);        sort(ss , ss + m);        int k &#x3D; 1;        for (int i &#x3D; 1 ; i &lt; m ; i ++) &#123;            if (X[i] !&#x3D; X[i - 1]) X[k++] &#x3D; X[i];        &#125;        memset(cnt , 0 , sizeof(cnt));        memset(sum , 0 , sizeof(sum));        double ret &#x3D; 0;        for (int i &#x3D; 0 ; i &lt; m - 1 ; i ++) &#123;            int l &#x3D; Bin(ss[i].l , k , X);            int r &#x3D; Bin(ss[i].r , k , X) - 1;            if (l &lt;&#x3D; r) update(l , r , ss[i].s , 0 , k - 1, 1);            ret +&#x3D; sum[1] * (ss[i + 1].h - ss[i].h);        &#125;        printf(&quot;Test case #%d\nTotal explored area: %.2lf\n\n&quot;, cas++ , ret);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="hdu1828-Picture"><a href="#hdu1828-Picture" class="headerlink" title="hdu1828 Picture"></a>hdu1828 Picture</h2><p>题意:矩形周长并</p><p>思路:与面积不同的地方是还要记录竖的边有几个(numseg记录),并且当边界重合的时候需要合并(用lbd和rbd表示边界来辅助)</p><p>线段树操作:update:区间增减 query:直接取根节点的值</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;#define lson l , m , rt &lt;&lt; 1#define rson m + 1 , r , rt &lt;&lt; 1 | 1const int maxn &#x3D; 22222;struct Seg &#123;    int l , r , h , s;    Seg() &#123;&#125;    Seg(int a, int b, int c, int d): l(a) , r(b) , h(c) , s(d) &#123;&#125;    bool operator &lt; (const Seg &amp;cmp) const &#123;        return h &lt; cmp.h;    &#125;&#125; ss[maxn];bool lbd[maxn &lt;&lt; 2] , rbd[maxn &lt;&lt; 2];int numseg[maxn &lt;&lt; 2];int cnt[maxn &lt;&lt; 2];int len[maxn &lt;&lt; 2];void PushUP(int rt, int l, int r) &#123;    if (cnt[rt]) &#123;        lbd[rt] &#x3D; rbd[rt] &#x3D; 1;        len[rt] &#x3D; r - l + 1;        numseg[rt] &#x3D; 2;    &#125; else if (l &#x3D;&#x3D; r) &#123;        len[rt] &#x3D; numseg[rt] &#x3D; lbd[rt] &#x3D; rbd[rt] &#x3D; 0;    &#125; else &#123;        lbd[rt] &#x3D; lbd[rt &lt;&lt; 1];        rbd[rt] &#x3D; rbd[rt &lt;&lt; 1 | 1];        len[rt] &#x3D; len[rt &lt;&lt; 1] + len[rt &lt;&lt; 1 | 1];        numseg[rt] &#x3D; numseg[rt &lt;&lt; 1] + numseg[rt &lt;&lt; 1 | 1];        if (lbd[rt &lt;&lt; 1 | 1] &amp;&amp; rbd[rt &lt;&lt; 1]) numseg[rt] -&#x3D; 2; &#x2F;&#x2F;两条线重合    &#125;&#125;void update(int L, int R, int c, int l, int r, int rt) &#123;    if (L &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; R) &#123;        cnt[rt] +&#x3D; c;        PushUP(rt , l , r);        return ;    &#125;    int m &#x3D; (l + r) &gt;&gt; 1;    if (L &lt;&#x3D; m) update(L , R , c , lson);    if (m &lt; R) update(L , R , c , rson);    PushUP(rt , l , r);&#125;int main() &#123;    int n;    while (~scanf(&quot;%d&quot;, &amp;n)) &#123;        int m &#x3D; 0;        int lbd &#x3D; 10000, rbd &#x3D; -10000;        for (int i &#x3D; 0 ; i &lt; n ; i ++) &#123;            int a , b , c , d;            scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d);            lbd &#x3D; min(lbd , a);            rbd &#x3D; max(rbd , c);            ss[m++] &#x3D; Seg(a , c , b , 1);            ss[m++] &#x3D; Seg(a , c , d , -1);        &#125;        sort(ss , ss + m);        int ret &#x3D; 0 , last &#x3D; 0;        for (int i &#x3D; 0 ; i &lt; m ; i ++) &#123;            if (ss[i].l &lt; ss[i].r) update(ss[i].l , ss[i].r - 1 , ss[i].s , lbd , rbd - 1 , 1);            ret +&#x3D; numseg[1] * (ss[i + 1].h - ss[i].h);            ret +&#x3D; abs(len[1] - last);            last &#x3D; len[1];        &#125;        printf(&quot;%d\n&quot;, ret);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h2><p>hdu3265 Posters</p><p>hdu3642 Get The Treasury</p><p>poj2482 Stars in Your Window</p><p>poj2464 Brownie Points II</p><p>hdu3255 Farming</p><p>ural1707 Hypnotoad’s Secret</p><p>uva11983 Weird Advertisement</p><h1 id="线段树与其他结合练习-欢迎大家补充"><a href="#线段树与其他结合练习-欢迎大家补充" class="headerlink" title="线段树与其他结合练习(欢迎大家补充):"></a>线段树与其他结合练习(欢迎大家补充):</h1><p>hdu3333 Turing Tree</p><p>hdu3874 Necklace</p><p>hdu3016 Man Down</p><p>hdu3340 Rain in ACStar</p><p>zju3511 Cake Robbery</p><p>UESTC1558 Charitable Exchange</p><p>CF85-D Sum of Medians</p><p>spojGSS2 Can you answer these queries II</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nowcoder_contest_992F</title>
      <link href="2019/07/21/Nowcoder-contest-992F/"/>
      <url>2019/07/21/Nowcoder-contest-992F/</url>
      
        <content type="html"><![CDATA[<h1 id="吉首大学2019年程序设计竞赛"><a href="#吉首大学2019年程序设计竞赛" class="headerlink" title="吉首大学2019年程序设计竞赛"></a>吉首大学2019年程序设计竞赛</h1><h2 id="F-天花乱坠"><a href="#F-天花乱坠" class="headerlink" title="F 天花乱坠"></a>F 天花乱坠</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>某年某月某日，琪仔get到了一款十分精美的天花板图案的设计图纸。</p><p>图案的框架最初是一个正n边形，之后以它的n条边的中点为顶点构成一个新的正n变形。如此重复多次后，就能得到天花板图案的框架了。</p><p>不要问重复多少次，问就是无限重复。。。</p><p><img src="https://uploadfiles.nowcoder.com/images/20190613/313957_1560420537785_7AC7B87D93F460C1B85D8C851AD70EF9" alt="img"></p><p>给定n，求生成的图案的框架所有边的长度总和(最初正n边形每条边的边长均为100)。</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><blockquote><p>多组测试(不多于100组)，每组一行一个整数n( 2 &lt; n &lt;= 100),表示正多边形的边数。</p></blockquote><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><blockquote><p>对于每组测试，输出一行一个结果，四舍五入保留两位小数。(请用较为简洁的计算方式，以减少误差)</p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>3<br>4<br>50</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>600.00<br>1365.69<br>2533863.09</p></blockquote><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>水题</p><p>这道题需要根据图形来找规律。</p><table><thead><tr><th>n</th><th>第$i$个$n$边形和第$i+1$个$n$边形的边长关系($a_i，a_{i+1}$为边长)</th><th>$\theta$</th></tr></thead><tbody><tr><td>3</td><td>$a_{i+1} = 2*\frac{1}{2}<em>a_i</em>\cos{\theta}$</td><td>$\theta = \frac{\pi}{2} -  \frac{(3-2) \times\pi}{3}\times\frac{1}{2} = \frac{\pi}{3}$</td></tr><tr><td>4</td><td>$a_{i+1} = 2*\frac{1}{2}<em>a_i</em>\cos{\theta}$</td><td>$\theta = \frac{\pi}{2} -  \frac{(4-2) \times\pi}{4}\times\frac{1}{2} = \frac{\pi}{4}$</td></tr><tr><td>5</td><td>$a_{i+1} = 2*\frac{1}{2}<em>a_i</em>\cos{\theta}$</td><td>$\theta = \frac{\pi}{2} -  \frac{(5-2) \times\pi}{5}\times\frac{1}{2} = \frac{\pi}{5}$</td></tr><tr><td>6</td><td>$a_{i+1} = 2*\frac{1}{2}<em>a_i</em> \cos{\theta}$</td><td>$\theta = \frac{\pi}{2} -  \frac{(6-2) \times\pi}{6}\times\frac{1}{2} = \frac{\pi}{6}$</td></tr></tbody></table><p>我们把每条边都写出来，这样就得到了一个等比数列，首项$a_1 = 100$，公比$q = cos\theta$。</p><p>$S_n = a_1 + a_2  + a_3 + \ldots + a_n$</p><p>$S_n = a_1 + a_1 \times q + a_1 \times q^2 + \ldots + a_1 \times q^{n-1}$</p><p>两遍同时乘$q$得</p><p>$q \times S_n = a_1 \times q + a_1 \times q^2 + a_1 \times q^3 + \ldots + a_1 \times q^{n }$</p><p>两式相减，化简得</p><p>$S_n = \frac{a_1 \times (1-q^n)}{1-q}$</p><p>${\lim\limits_{n \to \infty }} S_n = \lim\limits_{n \to \infty}\frac{a_1 \times (1-q^n)}{1-q} = \frac{a_1}{1-q}$</p><p>当然，我们前边求的是边长，要求周长，再乘上$n$即可</p><p>所以结果为：$n \times \frac{a_1}{1-q}$</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;bits&#x2F;stdc++.h&gt;&#x2F;&#x2F;#define LOCALusing namespace std;const int maxn &#x3D; 1e5 + 10;typedef long long LL;const double pi &#x3D; acos(-1);void solve()&#123;    int n;    while (cin &gt;&gt; n)    &#123;        double arc &#x3D; pi &#x2F; n;        double a1 &#x3D; 100, q &#x3D; cos(arc);        &#x2F;&#x2F;cout &lt;&lt; &quot;q &#x3D; &quot; &lt;&lt; q &lt;&lt; endl;        double ans &#x3D; a1 &#x2F; (1 - q);        printf(&quot;%.2f\n&quot;, ans * n);    &#125;&#125;int main()&#123;#ifdef LOCAL    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);#endif    solve();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hihoCoder 1103 Colorful Lecture Note</title>
      <link href="2019/03/15/hihoCoder-1103/"/>
      <url>2019/03/15/hihoCoder-1103/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://hihocoder.com/problemset/problem/1103">https://hihocoder.com/problemset/problem/1103</a></p><table><thead><tr><th align="left">时间限制</th><th align="left">单点时限</th><th align="left">内存限制</th></tr></thead><tbody><tr><td align="left">10000ms</td><td align="left">1000ms</td><td align="left">256MB</td></tr></tbody></table><h1 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h1><p>Little Hi is writing an algorithm lecture note for Little Ho. To make the note more comprehensible, Little Hi tries to color some of the text. Unfortunately Little Hi is using a plain(black and white) text editor. So he decides to tag the text which should be colored for now and color them later when he has a more powerful software such as Microsoft Word.</p><p>There are only lowercase letters and spaces in the lecture text. To mark the color of a piece of text, Little Hi add a pair of tags surrounding the text, <code>&lt;COLOR&gt;</code> at the beginning and <code>&lt;/COLOR&gt;</code> at the end where <code>COLOR</code> is one of “<code>red</code>“, “<code>yellow</code>“ or “<code>blue</code>“.</p><p>Two tag pairs may be overlapped only if one pair is completely inside the other pair. Text is colored by the nearest surrounding tag. For example, Little Hi would not write something like “<code>&lt;blue&gt;aaa&lt;yellow&gt;bbb&lt;/blue&gt;ccc&lt;/yellow&gt;</code>“. However “<code>&lt;yellow&gt;aaa&lt;blue&gt;bbb&lt;/blue&gt;ccc&lt;/yellow&gt;</code>“ is possible and “bbb” is colored blue.</p><p>Given such a text, you need to calculate how many letters(spaces are not counted) are colored red, yellow and blue.</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>Input contains one line: the text with color tags. The length is no more than 1000 characters.</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>Output three numbers count_red, count_yellow, count_blue, indicating the numbers of characters colored by red, yellow and blue.</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><pre class="line-numbers language-none"><code class="language-none">&lt;yellow&gt;aaa&lt;blue&gt;bbb&lt;&#x2F;blue&gt;ccc&lt;&#x2F;yellow&gt;dddd&lt;red&gt;abc&lt;&#x2F;red&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><pre class="line-numbers language-none"><code class="language-none">3 6 3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>这是一道练习赛的题目，刚开始看到这道题的时候，没读懂题意，错把<code>letter</code>译为<code>单词</code>，半天没读懂样例，后来重新读题意，发现是单词的意思，瞬间恍然大悟，后来想用搜索dfs来写，因为正好每一次输入都可以分解为若干个子问题，正好符合dfs的套路，但是写了半天后发现，代码不太好写。突然，灵光一现，想到用栈应该是可以处理的(其实最开始就想用栈，但是觉得dfs可能好写，后来发现有些难度)，其实想到用栈大概是因为最近在学数据结构，看到什么东西都想往栈上凑一凑！</p><p>我们可以用栈来存储每种颜色，对于<code>&lt;yellow&gt;aaa&lt;/yellow&gt;</code>这样的表示，我们姑且称左边为<code>左颜色</code>，右边称为<code>右颜色</code>。</p><ul><li>遇到是左颜色格式的，我们入栈，然后用map来映射每种颜色的字母个数，每读到一个字母，就增加对应map的键值。</li><li>读到右颜色的时候，进行出栈操作。</li><li>当栈为空的时候，不做任何操作。</li></ul><h1 id="AC-Code"><a href="#AC-Code" class="headerlink" title="AC Code"></a>AC Code</h1><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxn &#x3D; 1e5+10;typedef long long ll;int main()&#123;    string s;    getline(cin, s);    int len &#x3D; s.length();    map&lt;string, int&gt; mp;    stack&lt;string&gt; st;    for(int i&#x3D;0;i&lt;len;i++)    &#123;        if(isalpha(s[i]) &amp;&amp; !st.empty())            mp[st.top()]++;        if(s[i]&#x3D;&#x3D;&#39;&lt;&#39; &amp;&amp; s[i+1]!&#x3D;&#39;&#x2F;&#39;)        &#123;            i++;            string temp;            while(s[i]!&#x3D;&#39;&gt;&#39;)                temp +&#x3D; s[i++];            &#x2F;&#x2F;cout&lt;&lt;temp&lt;&lt;endl;            st.push(temp);            while(s[i]!&#x3D;&#39;&lt;&#39;)            &#123;                if(isalpha(s[i]))                    mp[st.top()]++;                i++;            &#125;            i--;        &#125;        if(s[i]&#x3D;&#x3D;&#39;&lt;&#39; &amp;&amp; s[i+1]&#x3D;&#x3D;&#39;&#x2F;&#39;)        &#123;            i +&#x3D; st.top().length()+1;            st.pop();        &#125;    &#125;    printf(&quot;%d %d %d\n&quot;, mp[&quot;red&quot;], mp[&quot;yellow&quot;], mp[&quot;blue&quot;]);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FPGA Quartus Prime 17.0 安装破解</title>
      <link href="2019/03/09/FPGA-install-pojie/"/>
      <url>2019/03/09/FPGA-install-pojie/</url>
      
        <content type="html"><![CDATA[<p>请先通读一遍全文后再开始安装，熟悉步骤，防止误操作。</p><a id="more"></a><h1 id="安装文件准备"><a href="#安装文件准备" class="headerlink" title="安装文件准备"></a>安装文件准备</h1><ul><li>由于安装文件过大，本文直接提供官网下载地址（实测官网下载不用翻墙，可以满速下载），官网提供“直接下载”和“工具下载”两种下载方式，本文使用<code>直接下载</code>方式；</li><li>单独安装<code>Quartus Prime</code>后仍无法使用，需要安装至少一个<code>器件支持包</code>，根据各个人需要下载。<code>课本上用到了Cylone IV</code>。（原博主用到了<code>Cylone IV</code>和<code>Cylone V</code>，所以可以选两个，也可以直选一个，够用就是了)；</li><li>可选“组合下载”和“独立文件”，由于组合文件体积太大，而且实际并不需要用到所有的器件支持包，推荐“<code>独立下载</code>”；</li><li>下载地址：<a href="http://fpgasoftware.intel.com/?edition=standard">http://fpgasoftware.intel.com/?edition=standard</a> //选择<code>Standard</code>、<code>17.0</code>，毕竟国外的网站，打开可能会有点慢。</li></ul><p><img src="/images/all_Image/FPGA_QuartusPrime17.0_install/Intel.png" alt="sum"></p><blockquote><p>注：图片中红线标注的为需要注意的地方，红色框选的为需要下载的文件(Cyclone V可不选)</p></blockquote><h1 id="破解工具准备"><a href="#破解工具准备" class="headerlink" title="破解工具准备"></a>破解工具准备</h1><p><strong>根据个人 Quartus 版本选择对应的破解软件</strong></p><ul><li><a href="https://download.csdn.net/download/ixunmo/10394504">Crack_Quartus_Prime_Standard_Pro_17.0_Windows</a> </li><li><a href="https://download.csdn.net/download/ixunmo/10634824">Modelsim_crack</a></li></ul><h1 id="其他下载方式"><a href="#其他下载方式" class="headerlink" title="其他下载方式"></a>其他下载方式</h1><p>如果不想在<code>Intel</code>官网注册账号(下载安装文件是需要注册Intel账号的)和消耗CSDN积分(下载破解文件是需要CSDN上的C币的)，可以使用我分享的百度网盘链接下载：</p><ul><li>链接：<a href="https://pan.baidu.com/s/11ZzuIlxQBvSIjOkLyvtIZw">https://pan.baidu.com/s/11ZzuIlxQBvSIjOkLyvtIZw</a> </li><li>提取码：w95d </li></ul><p>或者直接把下面链接粘到迅雷等下载器里</p><ul><li>ModelSimSetup-17.0.0.595-windows.exe 大小：1.11GB 链接：<a href="http://download.altera.com/akdlm/software/acdsinst/17.0std/595/ib_installers/ModelSimSetup-17.0.0.595-windows.exe">http://download.altera.com/akdlm/software/acdsinst/17.0std/595/ib_installers/ModelSimSetup-17.0.0.595-windows.exe</a></li><li>QuartusSetup-17.0.0.595-windows.exe 大小：2.19GB 链接：<a href="http://download.altera.com/akdlm/software/acdsinst/17.0std/595/ib_installers/QuartusSetup-17.0.0.595-windows.exe">http://download.altera.com/akdlm/software/acdsinst/17.0std/595/ib_installers/QuartusSetup-17.0.0.595-windows.exe</a><blockquote><p>以上破解资源均是从其他网站得到的，时间较久忘记从何处而来，若有侵犯，联系删除。</p></blockquote></li></ul><h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><p>  若将 <code>Quartus的安装文件</code>、<code>器件包</code>、<code>ModelSim-Intel FPGA的安装文件</code>放在<strong>同一个文件夹内</strong>，则“<code>QuartusSetup-17.0.0.595-windows.exe”</code>会<strong>自动识别</strong>到“<code>ModelSimSetup-17.0.0.595-windows.exe</code>”和“<code>cyclonev-17.0.0.595.qdz</code>”，即<strong>只需双击“QuartusSetup-17.0.0.595-windows.exe”进行安装</strong>，在安装过程中勾选附加安装选项便可（列表中的ModelSim-Intel FPGA Starter Edition是免费版本的ModelSim-IntelFPGA，若不想费力破解ModelSim，则勾选此项，否则<strong>勾选ModelSim-Intel FPGA Edition</strong>）</p><p><strong>注意：安装时，默认的安装路径为<code>C:\intelFPGA\17.0\ </code>，只需要把<code>C</code>改为<code>D</code>即可，也就是改成<code>D:\intelFPGA\17.0\ </code>。</strong></p><blockquote><p>推荐勾选ModelSim-Intel FPGA Edition，既然选择了破解版，就一条路走到底吧。</p></blockquote><h1 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h1><h2 id="Quartus-Prime破解"><a href="#Quartus-Prime破解" class="headerlink" title="Quartus Prime破解"></a>Quartus Prime破解</h2><p>这一步破解，请参考破解文件夹的<code>读我.txt</code>，并结合下文。</p><p>本文以<code>Windows Quartus Prime Standard 17.0.0.595</code>，安装路径 <code>D:\intelFPGA\17.0\ </code>为例： </p><ol><li>用<code>Quartus_Prime_Standard_17.0_破解器.exe</code>破解<code>D:\intelFPGA\17.0\quartus\bin64下</code>的<code>sys_cpt.dll</code>文件； </li><li>把<code>license.dat</code>里的<code>XXXXXXXXXXXX </code>用自己的<strong>网卡号</strong>替换(后文有网卡号获取方式)； </li><li>接下来的步骤参考下文的<strong>网卡号获取方式</strong>。</li><li>至此结束。</li></ol><blockquote><p>注意：license.dat文件存放的路径名称不能包含汉字和空格，空格可以用下划线代替。</p></blockquote><p>常见破解问题：<br>- 破解器被禁止访问dll文件或者找不到dll文件<br>Quartus没有被关闭或者没有被彻底关闭，解决方法是关闭之或者杀死还在运行的和Quartus有关的进程</p><h3 id="网卡号获取方式"><a href="#网卡号获取方式" class="headerlink" title="网卡号获取方式"></a>网卡号获取方式</h3><ul><li>在破解之前，安装好之后，打开桌面上的<code>Quartus (Quartus Prime 17.0) Standard Edition</code>，然后他会让你选择<code>License</code>，选择最后一项<code>if you have a valid license file ，specify  the location of you license file</code>。</li><li>进入License Setup界面，复制 <code>NIC id</code>，图中红框部分，右键，全选，复制即可。<img src="/images/all_Image/FPGA_QuartusPrime17.0_install/NIC_ID.png" alt="NIC_ID"></li><li>记事本方式打开crakc内的license.dat,记录好6个<code>HOSTID=XXXXXXXXXXXX</code>，将复制好的<code>NIC id</code>替换<code>XXXXXXXXXXXX</code>，并保存。(替换的快捷键为<code>Ctrl</code>+<code>H</code>)<img src="/images/all_Image/FPGA_QuartusPrime17.0_install/license_dat.png"></li><li>在license file 选项框，选择刚刚修改好的<code>license.dat</code>文件。（<strong>license文件存放的路径名称不能包含汉字和空格，空格可以用下划线代替）</strong><img src="/images/all_Image/FPGA_QuartusPrime17.0_install/license_file.png"></li><li>确认选择好后，点ok，这样就好了。</li></ul><h2 id="ModelSim-IntelFpga-破解"><a href="#ModelSim-IntelFpga-破解" class="headerlink" title="ModelSim - IntelFpga 破解"></a>ModelSim - IntelFpga 破解</h2><p>这一步不用参考<code>modlsim破解.docx</code>这个文档，按照以下步骤即可，如果下边的步骤失败，再查看<code>modlsim破解.docx</code>文档查错。</p><p>本文<code>ModelSim</code>安装路径为 <code>D:\intelFPGA\17.0\</code> . </p><ol><li>解压破解工具，将解压的文件<code>MentorKG.exe</code>和<code>patch_dll.bat</code> 一起拷贝到<code>D:\intelFPGA\17.0\modelsim_ae\win32aloem</code>下； </li><li>双击批处理文件<code>patch_dll.bat</code>，大概5秒后，将生成的TXT文本文件直接另存为，命名为<code>LICENSE.TXT</code>，保存路径自选，本文完整路径为 <code>D:\intelFPGA\17.0\modelsim_ae\LICENSE.TXT</code>； </li><li>添加系统变量： <br>桌面上的计算机(Win10为此电脑)右键:<code>属性</code>–<code>高级系统设置</code>–<code>环境变量</code>，上面的是用户变量，我们只需要在下面的<code>系统变量</code>添加即可。 点击<code>新建</code>，出现对话框，变量名为<code>MGLS_LICENSE_FILE</code>，变量值为<code>D:\intelFPGA\17.0\modelsim_ae\LICENSE.TXT</code>(就是你的LICENSE.TXT存放路径)； </li><li>至此结束；</li></ol><blockquote><p>注意：Modelsim的安装路径不能有中文，需全是英文<br>设置环境变量时，注意拼写，license文件的路径最好复制，以免出错</p></blockquote><h2 id="更新：ModelSim无法使用的问题"><a href="#更新：ModelSim无法使用的问题" class="headerlink" title="更新：ModelSim无法使用的问题"></a>更新：ModelSim无法使用的问题</h2><p>  在<code>Quartus</code>中调用<code>ModelSim</code>仿真时，需为<code>Quartus</code>指定<code>ModelSim的</code>安装位置，设置方法如下图：</p><p><img src="/images/all_Image/FPGA_QuartusPrime17.0_install/Tools_Options.png" alt="set1"></p><p><img src="/images/all_Image/FPGA_QuartusPrime17.0_install/ModelSim_Altera.png" alt="set2"></p><blockquote><p>参考资料：</p><ul><li><a href="https://blog.csdn.net/ixunmo/article/details/79338650">Quartus17.0 + ModelSim - IntelFpga安装及破解</a></li><li><a href="https://www.jb51.net/softjc/629957.html">Quartus Prime 18 Pro专业破解版安装+许可证文件激活图文详细教程</a></li></ul><p>如有侵权，请联系我删除。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> FPGA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPGA Quartus Prime 17.0 安装破解</title>
      <link href="2019/03/09/FPGA-Quartus-Prime-17_0-install-crack/"/>
      <url>2019/03/09/FPGA-Quartus-Prime-17_0-install-crack/</url>
      
        <content type="html"><![CDATA[<p>请先通读一遍全文后再开始安装，熟悉步骤，防止误操作。</p><a id="more"></a><h1 id="安装文件准备"><a href="#安装文件准备" class="headerlink" title="安装文件准备"></a>安装文件准备</h1><ul><li>由于安装文件过大，本文直接提供官网下载地址（实测官网下载不用翻墙，可以满速下载），官网提供“直接下载”和“工具下载”两种下载方式，本文使用<code>直接下载</code>方式；</li><li>单独安装<code>Quartus Prime</code>后仍无法使用，需要安装至少一个<code>器件支持包</code>，根据各个人需要下载。<code>课本上用到了Cylone IV</code>。（原博主用到了<code>Cylone IV</code>和<code>Cylone V</code>，所以可以选两个，也可以直选一个，够用就是了)；</li><li>可选“组合下载”和“独立文件”，由于组合文件体积太大，而且实际并不需要用到所有的器件支持包，推荐“<code>独立下载</code>”；</li><li>下载地址：<a href="http://fpgasoftware.intel.com/?edition=standard">http://fpgasoftware.intel.com/?edition=standard</a> //选择<code>Standard</code>、<code>17.0</code>，毕竟国外的网站，打开可能会有点慢。</li></ul><p><img src="https://img2.zhuomu.xyz/view/img/2020/03/17/XkFGwP8o/Intel.png" alt="sum"></p><blockquote><p>注：图片中红线标注的为需要注意的地方，红色框选的为需要下载的文件(Cyclone V可不选)</p></blockquote><h1 id="破解工具准备"><a href="#破解工具准备" class="headerlink" title="破解工具准备"></a>破解工具准备</h1><p><strong>根据个人 Quartus 版本选择对应的破解软件</strong></p><ul><li><a href="https://download.csdn.net/download/ixunmo/10394504">Crack_Quartus_Prime_Standard_Pro_17.0_Windows</a> </li><li><a href="https://download.csdn.net/download/ixunmo/10634824">Modelsim_crack</a></li></ul><h1 id="其他下载方式"><a href="#其他下载方式" class="headerlink" title="其他下载方式"></a>其他下载方式</h1><p>如果不想在<code>Intel</code>官网注册账号(下载安装文件是需要注册Intel账号的)和消耗CSDN积分(下载破解文件是需要CSDN上的C币的)，可以使用我分享的百度网盘链接下载：</p><ul><li>链接：<a href="https://pan.baidu.com/s/11ZzuIlxQBvSIjOkLyvtIZw">https://pan.baidu.com/s/11ZzuIlxQBvSIjOkLyvtIZw</a> </li><li>提取码：w95d </li></ul><p>或者直接把下面链接粘到迅雷等下载器里</p><ul><li>ModelSimSetup-17.0.0.595-windows.exe 大小：1.11GB 链接：<a href="http://download.altera.com/akdlm/software/acdsinst/17.0std/595/ib_installers/ModelSimSetup-17.0.0.595-windows.exe">http://download.altera.com/akdlm/software/acdsinst/17.0std/595/ib_installers/ModelSimSetup-17.0.0.595-windows.exe</a></li><li>QuartusSetup-17.0.0.595-windows.exe 大小：2.19GB 链接：<a href="http://download.altera.com/akdlm/software/acdsinst/17.0std/595/ib_installers/QuartusSetup-17.0.0.595-windows.exe">http://download.altera.com/akdlm/software/acdsinst/17.0std/595/ib_installers/QuartusSetup-17.0.0.595-windows.exe</a><blockquote><p>以上破解资源均是从其他网站得到的，时间较久忘记从何处而来，若有侵犯，联系删除。</p></blockquote></li></ul><h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><p>  若将 <code>Quartus的安装文件</code>、<code>器件包</code>、<code>ModelSim-Intel FPGA的安装文件</code>放在<strong>同一个文件夹内</strong>，则“<code>QuartusSetup-17.0.0.595-windows.exe”</code>会<strong>自动识别</strong>到“<code>ModelSimSetup-17.0.0.595-windows.exe</code>”和“<code>cyclonev-17.0.0.595.qdz</code>”，即<strong>只需双击“QuartusSetup-17.0.0.595-windows.exe”进行安装</strong>，在安装过程中勾选附加安装选项便可（列表中的ModelSim-Intel FPGA Starter Edition是免费版本的ModelSim-IntelFPGA，若不想费力破解ModelSim，则勾选此项，否则<strong>勾选ModelSim-Intel FPGA Edition</strong>）</p><p><strong>注意：安装时，默认的安装路径为<code>C:\intelFPGA\17.0\ </code>，只需要把<code>C</code>改为<code>D</code>即可，也就是改成<code>D:\intelFPGA\17.0\ </code>。</strong></p><blockquote><p>推荐勾选ModelSim-Intel FPGA Edition，既然选择了破解版，就一条路走到底吧。</p></blockquote><h1 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h1><h2 id="Quartus-Prime破解"><a href="#Quartus-Prime破解" class="headerlink" title="Quartus Prime破解"></a>Quartus Prime破解</h2><p>这一步破解，请参考破解文件夹的<code>读我.txt</code>，并结合下文。</p><p>本文以<code>Windows Quartus Prime Standard 17.0.0.595</code>，安装路径 <code>D:\intelFPGA\17.0\ </code>为例： </p><ol><li>用<code>Quartus_Prime_Standard_17.0_破解器.exe</code>破解<code>D:\intelFPGA\17.0\quartus\bin64下</code>的<code>sys_cpt.dll</code>文件； </li><li>把<code>license.dat</code>里的<code>XXXXXXXXXXXX </code>用自己的<strong>网卡号</strong>替换(后文有网卡号获取方式)； </li><li>接下来的步骤参考下文的<strong>网卡号获取方式</strong>。</li><li>至此结束。</li></ol><blockquote><p>注意：license.dat文件存放的路径名称不能包含汉字和空格，空格可以用下划线代替。</p></blockquote><p>常见破解问题：<br>- 破解器被禁止访问dll文件或者找不到dll文件<br>Quartus没有被关闭或者没有被彻底关闭，解决方法是关闭之或者杀死还在运行的和Quartus有关的进程</p><h3 id="网卡号获取方式"><a href="#网卡号获取方式" class="headerlink" title="网卡号获取方式"></a>网卡号获取方式</h3><ul><li>在破解之前，安装好之后，打开桌面上的<code>Quartus (Quartus Prime 17.0) Standard Edition</code>，然后他会让你选择<code>License</code>，选择最后一项<code>if you have a valid license file ，specify  the location of you license file</code>。</li><li>进入License Setup界面，复制 <code>NIC id</code>，图中红框部分，右键，全选，复制即可。<img src="https://img2.zhuomu.xyz/view/img/2020/03/17/XkFGwP8o/NIC_ID.png" alt="NIC_ID"></li><li>记事本方式打开crakc内的license.dat,记录好6个<code>HOSTID=XXXXXXXXXXXX</code>，将复制好的<code>NIC id</code>替换<code>XXXXXXXXXXXX</code>，并保存。(替换的快捷键为<code>Ctrl</code>+<code>H</code>)<img src="https://img2.zhuomu.xyz/view/img/2020/03/17/XkFGwP8o/license_dat.png"></li><li>在license file 选项框，选择刚刚修改好的<code>license.dat</code>文件。（<strong>license文件存放的路径名称不能包含汉字和空格，空格可以用下划线代替）</strong><img src="https://img2.zhuomu.xyz/view/img/2020/03/17/XkFGwP8o/license_file.png"></li><li>确认选择好后，点ok，这样就好了。</li></ul><h2 id="ModelSim-IntelFpga-破解"><a href="#ModelSim-IntelFpga-破解" class="headerlink" title="ModelSim - IntelFpga 破解"></a>ModelSim - IntelFpga 破解</h2><p>这一步不用参考<code>modlsim破解.docx</code>这个文档，按照以下步骤即可，如果下边的步骤失败，再查看<code>modlsim破解.docx</code>文档查错。</p><p>本文<code>ModelSim</code>安装路径为 <code>D:\intelFPGA\17.0\</code> . </p><ol><li>解压破解工具，将解压的文件<code>MentorKG.exe</code>和<code>patch_dll.bat</code> 一起拷贝到<code>D:\intelFPGA\17.0\modelsim_ae\win32aloem</code>下； </li><li>双击批处理文件<code>patch_dll.bat</code>，大概5秒后，将生成的TXT文本文件直接另存为，命名为<code>LICENSE.TXT</code>，保存路径自选，本文完整路径为 <code>D:\intelFPGA\17.0\modelsim_ae\LICENSE.TXT</code>； </li><li>添加系统变量： <br>桌面上的计算机(Win10为此电脑)右键:<code>属性</code>–<code>高级系统设置</code>–<code>环境变量</code>，上面的是用户变量，我们只需要在下面的<code>系统变量</code>添加即可。 点击<code>新建</code>，出现对话框，变量名为<code>MGLS_LICENSE_FILE</code>，变量值为<code>D:\intelFPGA\17.0\modelsim_ae\LICENSE.TXT</code>(就是你的LICENSE.TXT存放路径)； </li><li>至此结束；</li></ol><blockquote><p>注意：Modelsim的安装路径不能有中文，需全是英文<br>设置环境变量时，注意拼写，license文件的路径最好复制，以免出错</p></blockquote><h2 id="更新：ModelSim无法使用的问题"><a href="#更新：ModelSim无法使用的问题" class="headerlink" title="更新：ModelSim无法使用的问题"></a>更新：ModelSim无法使用的问题</h2><p>  在<code>Quartus</code>中调用<code>ModelSim</code>仿真时，需为<code>Quartus</code>指定<code>ModelSim的</code>安装位置，设置方法如下图：</p><p><img src="https://img2.zhuomu.xyz/view/img/2020/03/17/XkFGwP8o/Tools_Options.png" alt="set1"></p><p><img src="https://img2.zhuomu.xyz/view/img/2020/03/17/XkFGwP8o/ModelSim_Altera.png" alt="set2"></p><blockquote><p>参考资料：</p><ul><li><a href="https://blog.csdn.net/ixunmo/article/details/79338650">Quartus17.0 + ModelSim - IntelFpga安装及破解</a></li><li><a href="https://www.jb51.net/softjc/629957.html">Quartus Prime 18 Pro专业破解版安装+许可证文件激活图文详细教程</a></li></ul><p>如有侵权，请联系我删除。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> Quartus Prime </tag>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux VPS Speedtest</title>
      <link href="2019/02/20/Linux-VPS-Speedtest/"/>
      <url>2019/02/20/Linux-VPS-Speedtest/</url>
      
        <content type="html"><![CDATA[<p>VPS一键检测IO、配置信息等问题检测脚本改良，丰富配置信息的展现、IO速度、以及下载速度检测点也是国内节点。同时可以生成<code>speedtest.net</code>的测速报告和<code>ubuntu paste</code>结果。</p><h1 id="脚本下载地址"><a href="#脚本下载地址" class="headerlink" title="脚本下载地址"></a>脚本下载地址</h1><ul><li>官方地址<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;oooldking&#x2F;script&#x2F;master&#x2F;superbench.shchmod +x superbench.sh.&#x2F;superbench.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><ol start="2"><li>备用地址<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget https:&#x2F;&#x2F;soft.laozuo.org&#x2F;scripts&#x2F;superbench.shchmod +x superbench.sh.&#x2F;superbench.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>之后再想测速的话，直接在<code>root</code>目录运行<code>superbench.sh</code>这个脚本即可，命令如下：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sh superbench.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>建议先用官方的地址，因为可能会存在更新或者其他功能升级问题。</li></ol><p>从测试结果我们可以看到比teddysun提供的丰富一些，可以测试到架构、IO分三个等级测试、以及测速下载节点是用的随机国内节点。</p><blockquote><p>参考链接：<a href="http://www.laozuo.org/11138.html">http://www.laozuo.org/11138.html</a></p></blockquote><p>如果只需要测速的话，可以参考如下链接：<a href="http://www.laozuo.org/11078.html">http://www.laozuo.org/11078.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术博文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> speedtest </tag>
            
            <tag> VPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+Github搭建博客和美化</title>
      <link href="2019/02/17/Hexo-Github-Blog-Help/"/>
      <url>2019/02/17/Hexo-Github-Blog-Help/</url>
      
        <content type="html"><![CDATA[<p>本站配置：//Date: 2019-02-17</p><ul><li><p><a href="https://hexo.io/">Hexo</a> v3.8.0</p></li><li><p>Theme – <a href="https://theme-next.org/">NexT.Pisces</a> v6.7.0</p></li><li><p>Scheme - Pisces</p></li></ul><p>hexo+Github搭建博客的教程网上有很多了，初次搭建，可参考知乎上的一篇教程</p><p><a href="https://zhuanlan.zhihu.com/p/26625249">GitHub+Hexo 搭建个人网站详细教程</a> //<strong>强烈推荐！！！</strong></p><a id="more"></a><p>本文主要记录我在使用hexo的时候，从网上搜集的一些方法，整理了一下，写成博客，内容大多从网络上转载过来的，有些图省事，直接搬了过来，大多数都标记了出处，如有侵权，请<a href="mailto:yourname@gmail.com">联系</a>我删除。</p><h1 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h1><h2 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h2><h3 id="主页文章添加阴影效果"><a href="#主页文章添加阴影效果" class="headerlink" title="主页文章添加阴影效果"></a>主页文章添加阴影效果</h3><p>修改<code>custom.styl</code> 文件，添加以下代码。位置：<code>themes/next/source/css/_custom/custom.styl</code></p><pre class="line-numbers language-stylus" data-language="stylus"><code class="language-stylus">&#x2F;&#x2F; 主页文章添加阴影效果 .post &#123;   margin-top: 60px;   margin-bottom: 60px;   padding: 25px;   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="首页不显示全文-只显示预览"><a href="#首页不显示全文-只显示预览" class="headerlink" title="首页不显示全文(只显示预览)"></a>首页不显示全文(只显示预览)</h3><ul><li><p>打开主题配置文件<code>/themes/next/_config.yml</code>，将<code>auto_excerpt</code>下面的<code>enable:</code>的值，改成<code>true</code></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt:enable: truelength: 150<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>除了这个方法，还有一个更灵活的方法，直接在编辑的文章中添加<code>&lt;!--more--&gt;</code>标记。这样只会显示<code>&lt;!--more--&gt;</code>标记之前的那部份。</p></blockquote></li></ul><h3 id="显示阅读百分比"><a href="#显示阅读百分比" class="headerlink" title="显示阅读百分比"></a>显示阅读百分比</h3><ul><li><p>打开<code>themes/next/_config.yml</code>主题配置文件,找到<code># Scroll percent label in b2t button</code>将<code>scrollpercent:</code>的值,改成<code>true</code></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># Scroll percent label in b2t button  scrollpercent: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="设置「阅读全文」"><a href="#设置「阅读全文」" class="headerlink" title="设置「阅读全文」"></a>设置「阅读全文」</h3></li></ul><p>NexT 提供三种方式来控制文章在首页的显示方式。 也就是说，在首页显示文章的摘录并显示 <strong>阅读全文</strong> 按钮，可以通过以下方法：</p><ol><li><p>在文章中使用 <code>&lt;!-- more --&gt;</code> 手动进行截断，Hexo 提供的方式 推荐</p></li><li><p>在文章的 <a href="https://hexo.io/docs/front-matter.html">front-matter</a> 中添加 <code>description</code>，并提供文章摘录</p></li><li><p>自动形成摘要，在 主题配置文件 中添加：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">auto_excerpt:  enable: true  length: 150<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>默认截取的长度为 <code>150</code> 字符，可以根据需要自行设定</p></li></ol><p>建议使用 <code>&lt;!-- more --&gt;</code>（即第一种方式），除了可以精确控制需要显示的摘录内容以外， 这种方式也可以让 Hexo 中的插件更好的识别。</p><h3 id="如何更改内容区域的宽度？Scheme-Pisces专用"><a href="#如何更改内容区域的宽度？Scheme-Pisces专用" class="headerlink" title="如何更改内容区域的宽度？Scheme Pisces专用"></a>如何更改内容区域的宽度？Scheme Pisces专用</h3><p>对于 Pisces Scheme，需要同时修改 <code>header</code> 的宽度、<code>.main-inner</code> 的宽度以及 <code>.content-wrap</code> 的宽度。例如，使用百分比（Pisces 的布局定义在 <code>source/css/_schemes/Picses/_layout.styl</code> 中）：</p><pre class="line-numbers language-stylus" data-language="stylus"><code class="language-stylus">header&#123; width: 90%; &#125;.container .main-inner &#123; width: 90%; &#125;.content-wrap &#123; width: calc(100% - 260px); &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我并未对这个布局进行测试，自定义修改需要自己进行测试。另外，我觉得超过一定宽度后（一行内文字太多导致换行跨度太大），阅读体验都不怎么样。</p><h2 id="顶部"><a href="#顶部" class="headerlink" title="顶部"></a>顶部</h2><h3 id="添加顶部加载条"><a href="#添加顶部加载条" class="headerlink" title="添加顶部加载条"></a>添加顶部加载条</h3><ul><li>打开<code>themes/next/_config.yml</code>主题配置文件，将<code>pace:</code>的值,改成<code>true</code></li></ul><p>还可以将<code>pace_theme:</code>的值，改成相应的名字,变更不同样式的加载条。</p><h3 id="实现fork-me-on-github"><a href="#实现fork-me-on-github" class="headerlink" title="实现fork me on github"></a>实现fork me on github</h3><ul><li><p>点击<a href="https://github.com/blog/273-github-ribbons">这里</a>或者<a href="http://tholman.com/github-corners">这里</a>挑选自己喜欢的样式， 复制代码</p></li><li><p>在<a href="http://tool.oschina.net/codeformat/html">这里</a>把代码格式化</p></li><li><p>粘贴刚才复制的代码到<code>themes/next/layout/_layout.swig</code>文件中，放在<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>的下面，并把<code>href</code>改为你的github地址，当然，也可以是其他地址。</p></li></ul><h2 id="底部"><a href="#底部" class="headerlink" title="底部"></a>底部</h2><h3 id="站点建立时间"><a href="#站点建立时间" class="headerlink" title="站点建立时间"></a>站点建立时间</h3><p>这个时间将在站点的底部显示，例如 <code>© 2013 - 2015</code>。 编辑 主题配置文件，新增字段 <code>since</code>。</p><p>配置示例</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">since: 2013<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="小东西"><a href="#小东西" class="headerlink" title="小东西"></a>小东西</h2><h3 id="自定义鼠标样式"><a href="#自定义鼠标样式" class="headerlink" title="自定义鼠标样式"></a>自定义鼠标样式</h3><ul><li><p>打开<code>themes/next/source/css/_custom/custom.styl</code>,在里面添加如下代码：</p><pre class="line-numbers language-stylus" data-language="stylus"><code class="language-stylus">&#x2F;&#x2F; 鼠标样式  * &#123;      cursor: url(&quot;https:&#x2F;&#x2F;blog-1251102893.cos.ap-shanghai.myqcloud.com&#x2F;blog&#x2F;pointer2.png&quot;),auto!important  &#125;  :active &#123;      cursor: url(&quot;https:&#x2F;&#x2F;blog-1251102893.cos.ap-shanghai.myqcloud.com&#x2F;blog&#x2F;pointer.png&quot;),auto!important  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中url里面必须是ico图片，ico图片可以上传到网上，然后获取外链，复制到url里就行了。</p><p>小技巧：二个ICO图标可以设置成一大一小。这样点击起来，就会有动画效果了。</p></li></ul><h3 id="各区域动态载入效果"><a href="#各区域动态载入效果" class="headerlink" title="各区域动态载入效果"></a>各区域动态载入效果</h3><ul><li><p>编辑<code>themes/netx/_config.yml</code>找到<code>motion</code>,将<code>enable</code>的值，改成<code>true</code></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># Use velocity to animate everything.motion:  enable: true  async: false  transition:    # Transition variants:    # fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut    post_block: fadeIn #主页载入效果    post_header: bounceRightIn #文章标题载入效果    post_body: slideDownIn    coll_header: bounceLeftIn    # Only for Pisces | Gemini.    sidebar: bounceLeftIn #侧边栏载入效果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>#</code>号里都是载入效果，可以自行尝试。</p></li></ul><h3 id="美化右侧滚动条"><a href="#美化右侧滚动条" class="headerlink" title="美化右侧滚动条"></a>美化右侧滚动条</h3><ul><li><p>打开<code>themes\next\source\css\_custom\custom.styl</code>文件，将下面的代码添加进去。</p><pre class="line-numbers language-stylus" data-language="stylus"><code class="language-stylus">&#x2F;&#x2F;设置滚动条的样式&#x2F;&#x2F;参考https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000003708894::-webkit-scrollbar &#123;      width: 5px;      height: 5px;&#125;&#x2F;&#x2F;滚动槽::-webkit-scrollbar-track &#123;      background: #eee;&#125;&#x2F;&#x2F;滚动条滑块::-webkit-scrollbar-thumb &#123;      border-radius: 5px;        background-color: #ccc;&#125;::-webkit-scrollbar-thumb:hover &#123;      background-color: rgb(247, 149, 51);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="优化选择的文字样式"><a href="#优化选择的文字样式" class="headerlink" title="优化选择的文字样式"></a>优化选择的文字样式</h3></li><li><p>打开<code>themes\next\source\css\_custom\custom.styl</code>文件，将下面的代码添加进去。</p><pre class="line-numbers language-stylus" data-language="stylus"><code class="language-stylus">::selection &#123;      background-color: rgb(255, 241, 89);        color: #555;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="点击出现桃心效果"><a href="#点击出现桃心效果" class="headerlink" title="点击出现桃心效果"></a>点击出现桃心效果</h3></li><li><p>打开<a href="https://blog-1251102893.cos.ap-shanghai.myqcloud.com/blog/love.js">love.js</a>网站，然后将里面的代码copy一下，新建<code>love.js</code>文件并且将代码粘贴进去，然后保存。</p></li><li><p>将<code>love.js</code>文件放到路径<code>themes/next/source/js/src</code>里面，然后打开<code>themes/next/layout/_layout.swig</code>文件,在末尾（在前面引用会出现找不到的bug）<br>添加以下代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 页面点击小红心 <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"/js/src/love.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h1></li></ul><h2 id="分类和标签显示-tags-categories"><a href="#分类和标签显示-tags-categories" class="headerlink" title="分类和标签显示(tags, categories)"></a>分类和标签显示(tags, categories)</h2><ol><li><p>新建一个页面，命名为<code>tags</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new page &quot;tags&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>编辑新建的<code>index.md</code>文档，这个<code>index.md</code>存在<strong>站点</strong>的<code>source\tags</code>目录下。</p><pre class="line-numbers language-none"><code class="language-none">---title: TagCloud #这个是tags页面的标题type: tagslayout: &quot;tags&quot;---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：如果启用评论功能，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false。</p></blockquote><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">---title: TagCloud #这个是tags页面的标题type: tagslayout: &quot;tags&quot;comments: false---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在<code>menu</code>中打开，编辑<strong>主题</strong>配置文件<code>_config.yml</code>，添加<code>tags</code>到<code>menu</code>下，说白了就是把注释删掉。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">menu:  home: &#x2F; || home  tags: &#x2F;tags&#x2F; || tags  archives: &#x2F;archives&#x2F; || archive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>categories</code>的设置类似，把对应的<code>tags</code>改成<code>categories</code>即可。</p><p><code>index.md</code>文档中的<code>title</code>后边的字段可以自定义。</p></blockquote></li></ol><h2 id="添加RSS订阅"><a href="#添加RSS订阅" class="headerlink" title="添加RSS订阅"></a>添加RSS订阅</h2><ul><li><p>安装RSS插件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo-generator-feed --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>编辑<strong>主题</strong>配置文件<code>_config.yml</code>，添加以下代码开启</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">#rss feedfeed:    type: atom    path: atom.xml    limit: 5    hub:    content: &#39;true&#39;    content_limit:    content_limit_delim: &#39; &#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数的含义：</p></li><li><p><code>type</code>: <code>RSS</code>的类型(<code>atom/rss2</code>)</p></li><li><p><code>path</code>: 文件路径,默认是<code>atom.xml/rss2.xml</code></p></li><li><p><code>limit</code>: 展示文章的数量,使用<strong>0</strong>或则<strong>false</strong>代表展示全部</p></li><li><p><code>hub</code>:</p></li><li><p><code>content</code>: 在<code>RSS</code>文件中是否包含内容 ,有3个值 <code>true/false</code>默认不填为<code>false</code></p></li><li><p><code>content_limit</code>: 指定内容的长度作为摘要,仅仅在上面<code>content</code>设置为<code>false</code>和<code>没有自定义的描述出现</code></p></li><li><p><code>content_limit_delim</code>: 上面截取描述的分隔符,截取内容是以指定的这个分隔符作为截取结束的标志.在达到规定的内容长度之前最后出现的这个分隔符之前的内容,，防止从中间截断.</p></li></ul><blockquote></blockquote><h2 id="友情链接Blog-rolls"><a href="#友情链接Blog-rolls" class="headerlink" title="友情链接Blog rolls"></a>友情链接Blog rolls</h2><ul><li><p>编辑文件<code>themes/next/_config.yml</code>，找到<code># Blog rolls</code>修改成下面的样子就OK了。(links里面写你想要的链接):</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># Blog rollslinks_icon: linklinks_title: Linkslinks_layout: block#links_layout: inlinelinks:  Title: http:&#x2F;&#x2F;example.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h2></li></ul><p>Sidebar Avatar</p><ul><li><p>修改文件<code>themes/next/_config.yml</code>，找到<code>avatar</code>，修改成如下格式即可，<code>url</code>可以是一个网络链接，也可以是本地图片，具体格式看注释。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># Sidebar Avataravatar:  # in theme directory(source&#x2F;images): &#x2F;images&#x2F;avatar.gif  # in site  directory(source&#x2F;uploads): &#x2F;uploads&#x2F;avatar.gif  # You can also use other linking images.  url: https:&#x2F;&#x2F;blog-1251102893.cos.ap-shanghai.myqcloud.com&#x2F;avatar.jpg  # If true, the avatar would be dispalyed in circle.  rounded: true  # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar.  opacity: 1  # If true, the avatar would be rotated with the cursor.  rotated: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="联系方式及社交链接"><a href="#联系方式及社交链接" class="headerlink" title="联系方式及社交链接"></a>联系方式及社交链接</h2></li><li><p>修改<code>themes/next/_config.yml</code>站点配置文件，找到<code># Social Links</code>,将<code>social:</code>下面对应的<code>#</code>号去掉。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># Social Links# find other icon : https:&#x2F;&#x2F;fontawesome.com&#x2F;cheatsheet?from&#x3D;iosocial:  GitHub: https:&#x2F;&#x2F;github.com&#x2F;yourname || github  E-Mail: mailto:yourname@gmail.com || envelope  Weibo: https:&#x2F;&#x2F;weibo.com&#x2F;yourname || weibo  #Google: https:&#x2F;&#x2F;plus.google.com&#x2F;yourname || google  #Twitter: https:&#x2F;&#x2F;twitter.com&#x2F;yourname || twittersocial_icons:  enable: true  icons_only: false  transition: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="侧边栏社交链接"><a href="#侧边栏社交链接" class="headerlink" title="侧边栏社交链接"></a>侧边栏社交链接</h2></li></ul><p>侧栏社交链接的修改包含两个部分，第一是链接，第二是链接图标。 两者配置均在 主题配置文件 中。</p><ol><li><p>链接放置在 <code>social</code> 字段下，一行一个链接。其键值格式是 <code>显示文本: 链接地址</code>。</p><p>配置示例</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># Social linkssocial:  GitHub: https:&#x2F;&#x2F;github.com&#x2F;your-user-name  Twitter: https:&#x2F;&#x2F;twitter.com&#x2F;your-user-name  微博: http:&#x2F;&#x2F;weibo.com&#x2F;your-user-name  豆瓣: http:&#x2F;&#x2F;douban.com&#x2F;people&#x2F;your-user-name  知乎: http:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;your-user-name  # 等等<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>设定链接的图标，对应的字段是 <code>social_icons</code>。其键值格式是 <code>匹配键: Font Awesome 图标名称</code>， <code>匹配键</code> 与上一步所配置的链接的 <code>显示文本</code> 相同（大小写严格匹配），<code>图标名称</code> 是 Font Awesome 图标的名字（不必带 <code>fa-</code> 前缀）。<code>enable</code> 选项用于控制是否显示图标，你可以设置成 <code>false</code> 来去掉图标。</p><p>配置示例</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># Social Iconssocial_icons:  enable: true  # Icon Mappings  GitHub: github  Twitter: twitter  微博: weibo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="腾讯公益404页面"><a href="#腾讯公益404页面" class="headerlink" title="腾讯公益404页面"></a>腾讯公益404页面</h2></li></ol><p>腾讯公益404页面，寻找丢失儿童，让大家一起关注此项公益事业！效果click <a href="https://5chenglin.github.io/404.html">here</a></p><p>使用方法，新建 404.html 页面，放到<strong>主题</strong>的 <code>source</code> 目录下，内容如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">HTML</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content-type<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/html;charset=utf-8;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge,chrome=1<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>robots<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>all<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>robots<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>index,follow<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://qzone.qq.com/gy/404/style/404style.css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/plain<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.qq.com/404/search_children.js<span class="token punctuation">"</span></span>          <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span> <span class="token attr-name">homePageUrl</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/<span class="token punctuation">"</span></span>          <span class="token attr-name">homePageName</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>回到我的主页<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://qzone.qq.com/gy/404/data.js<span class="token punctuation">"</span></span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://qzone.qq.com/gy/404/page.js<span class="token punctuation">"</span></span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="文章界面"><a href="#文章界面" class="headerlink" title="文章界面"></a>文章界面</h1><h2 id="设置代码高亮主题"><a href="#设置代码高亮主题" class="headerlink" title="设置代码高亮主题"></a>设置代码高亮主题</h2><p>NexT 使用 <a href="https://github.com/chriskempson/tomorrow-theme">Tomorrow Theme</a> 作为代码高亮，共有5款主题供你选择。 NexT 默认使用的是 白色的 <code>normal</code> 主题，可选的值有 <code>normal</code>，<code>night</code>， <code>night blue</code>， <code>night bright</code>， <code>night eighties</code>：</p><table><thead><tr><th><img src="https://theme-next.iissnan.com/assets/img/tomorrow.png" alt="img"></th><th><img src="https://theme-next.iissnan.com/assets/img/tomorrow-night.png" alt="img"></th><th><img src="https://theme-next.iissnan.com/assets/img/tomorrow-night-blue.png" alt="img"></th><th><img src="https://theme-next.iissnan.com/assets/img/tomorrow-night-bright.png" alt="img"></th><th><img src="https://theme-next.iissnan.com/assets/img/tomorrow-night-eighties.png" alt="img"></th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>更改 <code>highlight_theme</code> 字段，将其值设定成你所喜爱的高亮主题，例如：</p><p>高亮主题设置示例</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># Code Highlight theme# Available value: normal | night | night eighties | night blue | night bright# https:&#x2F;&#x2F;github.com&#x2F;chriskempson&#x2F;tomorrow-themehighlight_theme: normal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="图片放大预览Fancybox"><a href="#图片放大预览Fancybox" class="headerlink" title="图片放大预览Fancybox"></a>图片放大预览Fancybox</h2><p>参考fancybox文档即可</p><p>There is support for old version 2 and new version 3.</p><p>Choose only any one variant, do not need to install both.</p><ul><li><p>To install 2.x: <a href="https://github.com/theme-next/theme-next-fancybox">https://github.com/theme-next/theme-next-fancybox</a></p></li><li><p>To install 3.x: <a href="https://github.com/theme-next/theme-next-fancybox3">https://github.com/theme-next/theme-next-fancybox3</a></p></li></ul><h2 id="修改文章底部-标签"><a href="#修改文章底部-标签" class="headerlink" title="修改文章底部# 标签"></a>修改文章底部<code>#</code> 标签</h2><p>修改<strong>主题</strong>配置文件，位置：<code>/themes/next/layout/_macro/post.swig</code></p><ol><li><p>搜索 <code>rel=&quot;tag&quot;&gt;#</code>。</p></li><li><p>将 <code>#</code> 换成 <code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code>。</p></li><li><p>可以换成自己喜欢的图标，更改 <code>fa fa-tag</code> 中的<code>tag</code>即可，比如，可以改成<code>fa fa-heart</code>。</p><blockquote><p>更多icon图标：<a href="https://fontawesome.com/v4.7.0/icons/">Font Awesome</a>。</p></blockquote></li></ol><h2 id="结尾添加“本文结束”标记"><a href="#结尾添加“本文结束”标记" class="headerlink" title="结尾添加“本文结束”标记"></a>结尾添加“本文结束”标记</h2><ul><li><p>在路径<code>themes/next/layout/_macro</code>中新建<code>passage-end-tag.swig</code>文件,并添加以下内容：</p><pre class="line-numbers language-django" data-language="django"><code class="language-django">&lt;div&gt;    &#123;% if not is_index %&#125;        &lt;div style&#x3D;&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;            -------------本文结束            &lt;i class&#x3D;&quot;fa fa-paw&quot;&gt;&lt;&#x2F;i&gt;            感谢您的阅读-------------        &lt;&#x2F;div&gt;    &#123;% endif %&#125;&lt;&#x2F;div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>接着打开<code>themes/next/layout/_macro/post.swig</code>文件，在<code>post-body</code>之后，<code>post-footer</code>之前添加如下代码,(大概在350行左右的位置)：</p><pre class="line-numbers language-django" data-language="django"><code class="language-django">&lt;div&gt;  &#123;% if not is_index %&#125;    &#123;% include &#39;passage-end-tag.swig&#39; %&#125;  &#123;% endif %&#125;&lt;&#x2F;div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>然后打开主题配置文件<code>_config.yml</code>,在末尾添加</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 文章末尾添加“本文结束”标记passage_end_tag:  enabled: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="修改文章内链接文本样式"><a href="#修改文章内链接文本样式" class="headerlink" title="修改文章内链接文本样式"></a>修改文章内链接文本样式</h2></li><li><p>修改文件<code>themes/next/source/css/_common/components/post/post.styl</code>，在末尾添加如下<code>css</code>样式：</p><pre class="line-numbers language-stylus" data-language="stylus"><code class="language-stylus">&#x2F;&#x2F; 文章内链接文本样式.post-body p a&#123;  color: #0593d3;  border-bottom: none;  border-bottom: 1px solid #0593d3;  &amp;:hover &#123;    color: #fc6423;    border-bottom: none;    border-bottom: 1px solid #fc6423;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>其中选择<code>.post-body</code>是为了不影响标题，选择<code>p</code>是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。</p></blockquote></li></ul><h1 id="编辑、推送"><a href="#编辑、推送" class="headerlink" title="编辑、推送"></a>编辑、推送</h1><h2 id="不处理’source’目录的个别文件"><a href="#不处理’source’目录的个别文件" class="headerlink" title="不处理’source’目录的个别文件"></a>不处理’source’目录的个别文件</h2><blockquote><p>有时候我们对某些文件不需要进行 hexo 博客主题渲染，需要过滤。</p></blockquote><p>编辑<strong>站点</strong>配置文件 <code>_config.yml</code>，搜索 <code>skip_render</code> 字段，修改相关内容来设置忽略的目录，具体如下：(文件匹配是基于正则匹配的)</p><ol><li>单个文件夹下全部文件：skip_render: demo/*</li><li>单个文件夹下指定类型文件：skip_render: demo/*.html</li><li>单个文件夹下全部文件以及子目录:skip_render: demo/**</li><li>多个文件夹以及各种复杂情况：</li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">skip_render:   - &#39;demo&#x2F;*.html&#39;   - &#39;demo&#x2F;**&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="添加文章时，自动打开markdown编辑器"><a href="#添加文章时，自动打开markdown编辑器" class="headerlink" title="添加文章时，自动打开markdown编辑器"></a>添加文章时，自动打开markdown编辑器</h2><p>找到博客根目录，打开scripts活页夹(没有的话，自己创建一个)。</p><p>创建一个JavaScript文件，可任意命名。</p><p>打开所创建的JavaScript文件，输入以下内容</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> spawn <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'child_process'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>exec<span class="token punctuation">;</span><span class="token comment">//根据自己安装的hexo版本选择</span><span class="token comment">// Hexo 2.x 复制这段</span>hexo<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'new'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">spawn</span><span class="token punctuation">(</span><span class="token string">'start "" "markdown编辑器绝对路径" '</span> <span class="token operator">+</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Hexo 3 复制这段</span>hexo<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'new'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token string">'start "" "markdown编辑器绝对路径" '</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意: markdown编辑器绝对路径 格式为(例如打开Typora)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">C:\\Program Files\\Typora\\Typora.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>来源： <a href="https://www.jianshu.com/p/3a01cc514ce7">https://www.jianshu.com/p/3a01cc514ce7</a></p><p>参考：<a href="https://github.com/hexojs/hexo/issues/1007">hexo Github issue</a>  <a href="https://notes.doublemine.me/2015-06-29-Hexo%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E6%97%B6%E8%87%AA%E5%8A%A8%E6%89%93%E5%BC%80%E7%BC%96%E8%BE%91%E5%99%A8.html">Hexo添加文章时自动打开编辑器</a> </p></blockquote><h1 id="第三方服务"><a href="#第三方服务" class="headerlink" title="第三方服务"></a>第三方服务</h1><h2 id="百度统计"><a href="#百度统计" class="headerlink" title="百度统计"></a>百度统计</h2><p>注意： baidu_analytics 不是你的百度 id 或者 百度统计 id</p><ol><li>登录 <a href="http://tongji.baidu.com/#http">百度统计</a>， 定位到站点的代码获取页面</li><li>复制 <code>hm.js?</code> 后面那串统计脚本 id，如：<img src="http://theme-next.iissnan.com/uploads/five-minutes-setup/analytics-baidu-id.png" alt="img"></li><li>编辑 主题配置文件， 修改字段 <code>baidu_analytics</code> 字段，值设置成你的百度统计脚本 id。</li></ol><h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><h2 id="推荐工具："><a href="#推荐工具：" class="headerlink" title="推荐工具："></a>推荐工具：</h2><ul><li>Visual Studio Code，用于管理blog所有文件。</li><li>Typora，用于编辑Markdown文档。</li><li>腾讯云COS，内容存储服务，用于图床文件的存储，实现CDN加速。</li></ul><h2 id="npm访问速度慢问题："><a href="#npm访问速度慢问题：" class="headerlink" title="npm访问速度慢问题："></a>npm访问速度慢问题：</h2><p>只需要使用–registry参数指定镜像服务器地址，为了避免每次安装都需要–registry参数，可以使用如下命令进行永久设置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ npm config set registry http:&#x2F;&#x2F;registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>换了国内镜像，npm安装速度就很快了.</p><h2 id="npm离线安装："><a href="#npm离线安装：" class="headerlink" title="npm离线安装："></a>npm离线安装：</h2><ul><li>找到对应插件GitHub地址，download</li><li>解压，把文件夹放到安装目录下<code>C:\Users\zhuom\.atom\packages</code></li><li>win + R ，cmd，<code>cd .atom\packages\xxx</code> <code>xxx</code>为对应的插件文件夹名称。</li><li><code>npm install</code>即可。</li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/26625249">GitHub+Hexo 搭建个人网站详细教程</a> //强烈推荐！</li><li><a href="https://zealot.top/Hexo-Github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A22.html">Hexo-Github搭建自己的博客 — 心得汇总2018版（主题配置篇）</a></li><li><a href="http://theme-next.iissnan.com/third-party-services.html#algolia-search">第三方服务集成 - NexT 使用文档</a> //评论、统计、搜索等服务</li><li><a href="https://notes.doublemine.me/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud">为NexT主题添加文章阅读量统计功能 | Doublemine</a> //LeanCloud配置</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux 解决CentOS改DNS，重启失效问题</title>
      <link href="2019/01/25/Linux-CentOS-DNS/"/>
      <url>2019/01/25/Linux-CentOS-DNS/</url>
      
        <content type="html"><![CDATA[<p>解决在CentOS上改DNS，重启网络配置后又恢复原样的问题</p><p>直接修改<code>/etc/resolv.conf</code>不行，因为一重启network就会恢复原来状态。</p><p>必须要在<code>/etc/sysconfig/network-scripts/ifcfg-eth0</code>里面最后加上dns的设置。</p><p>要不然，重启后，肯定使用eth0设置中没有设dns的相关信息，使<code>/etc/resolv.conf</code>恢复到原来的状态。</p><p>具体操作如下：</p><pre class="line-numbers language-none"><code class="language-none">$ vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改成下面这个样子</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">DEVICE&#x3D;&quot;eth0&quot;TYPE&#x3D;&quot;Ethernet&quot;UUID&#x3D;&quot;3b5xxc-6xx9-4xx69-9xx6-xxc8xxe5xx52&quot;ONBOOT&#x3D;&quot;yes&quot;NM_CONTROLLED&#x3D;&quot;yes&quot;BOOTPROTO&#x3D;noneIPADDR&#x3D;xx.xx.xx.xxNETMASK&#x3D;&quot;255.255.255.0&quot;GATEWAY&#x3D;xx.xx.xx.xxBROADCAST&#x3D;&quot;xx.xx.xx.xx&quot;PREFIX&#x3D;24DEFROUTE&#x3D;yesIPV4_FAILURE_FATAL&#x3D;yesIPV6INIT&#x3D;noNAME&#x3D;&quot;System eth0&quot;DNS1&#x3D;x.x.x.x #114.114.114.114DNS2&#x3D;x.x.x.x #8.8.8.8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样设置后/etc/resolv.conf里面根本就不需要设置。</p><p>重启</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ service network restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以发现/etc/resolv.conf里面就有两个dns的解析ip了。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ cat &#x2F;etc&#x2F;resolv.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>解决CentOS 7更改DNS重启失效问题</title>
      <link href="2019/01/25/CentOS-7-DNS-resrart/"/>
      <url>2019/01/25/CentOS-7-DNS-resrart/</url>
      
        <content type="html"><![CDATA[<p>解决在CentOS上改DNS，重启网络配置后又恢复原样的问题</p><p>直接修改<code>/etc/resolv.conf</code>不行，因为一重启network就会恢复原来状态。</p><p>必须要在<code>/etc/sysconfig/network-scripts/ifcfg-eth0</code>里面最后加上dns的设置。</p><p>要不然，重启后，肯定使用eth0设置中没有设dns的相关信息，使<code>/etc/resolv.conf</code>恢复到原来的状态。</p><p>具体操作如下：</p><pre class="line-numbers language-none"><code class="language-none">$ vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改成下面这个样子</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">DEVICE&#x3D;&quot;eth0&quot;TYPE&#x3D;&quot;Ethernet&quot;UUID&#x3D;&quot;3b5xxc-6xx9-4xx69-9xx6-xxc8xxe5xx52&quot;ONBOOT&#x3D;&quot;yes&quot;NM_CONTROLLED&#x3D;&quot;yes&quot;BOOTPROTO&#x3D;noneIPADDR&#x3D;xx.xx.xx.xxNETMASK&#x3D;&quot;255.255.255.0&quot;GATEWAY&#x3D;xx.xx.xx.xxBROADCAST&#x3D;&quot;xx.xx.xx.xx&quot;PREFIX&#x3D;24DEFROUTE&#x3D;yesIPV4_FAILURE_FATAL&#x3D;yesIPV6INIT&#x3D;noNAME&#x3D;&quot;System eth0&quot;DNS1&#x3D;x.x.x.x #114.114.114.114DNS2&#x3D;x.x.x.x #8.8.8.8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样设置后/etc/resolv.conf里面根本就不需要设置。</p><p>重启</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ service network restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以发现/etc/resolv.conf里面就有两个dns的解析ip了。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ cat &#x2F;etc&#x2F;resolv.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HDU Magic Maze ZZULI09F</title>
      <link href="2019/01/23/HDU-Magic-Maze-ZZULI09F/"/>
      <url>2019/01/23/HDU-Magic-Maze-ZZULI09F/</url>
      
        <content type="html"><![CDATA[<p>郑州轻工业学院首届“瑞琪杯”大学生程序设计大赛 F 1006</p><p>HDU Virtual Contest 可以找到原题<br>迷宫bfs，求步数最少，多了一个跳跃的判断，题意有点模糊。</p><a id="more"></a><p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)<br>Total Submission(s): 1 Accepted Submission(s): 1</p><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>天外来客 likes playing computer game very much. Recently, he is playing a RPG game called “仙剑奇侠传4”. But when he was playing the game, he meets a very mad problem. There are so many mazes in the game and CHN was not good at passing the mazes. So he is very unhappy these days. Can you help him?<br>Here is a magic maze. When one person stands on a position(x0, y0), he can choose to jump to the other one position(x1, y1), which has a relation with the position(x0, y0). <strong>One position can have only one relation.（这里似乎有问题？？？）</strong> One person can move left, right, up or down. One move or one jump will take one minute.<br>There are only have ‘.’ or ‘#’, ’S’, ’E’ on the map of the magic maze. ’.’ indicates the blank which person can move on, ‘#’ indicates wall. Maybe a blank have relation of a wall. ’S’ indicates the entrance location. ‘E’ indicates the exit location . There is only one ‘S’ and one ‘E’.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line is an integer t, which means the number of test case in the data file. For each test case, the first line consist of two integer r (2&lt;=r&lt;=20) and c (2&lt;=c&lt;20), which mean the number of rows or columns. The next r line is the map’s description; each line consists of c letters. The next line is an integer k (0&lt;=k&lt;=(r*c)/2), which mean the relations of two position. The next k lines, each line consist of four integers x1, y1, x2, y2, which means (x1,y1) has a relation with (x2, y2) and (x2, y2) also has a relation with (x1, y1).<br>(0&lt;=x1,x2=&lt;r-1,0&lt;=y1,y2&lt;=c-1)<br>You can jump from one position to another.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, you only outputs the Minimum time that one person will take from the entrance location to the exit location. If he can’t find the exit position, you must output ‘-1’.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre class="line-numbers language-none"><code class="language-none">16 6S..#.....#.....#...#.#.....#.#.....E31 2 4 40 1 4 50 0 4 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre class="line-numbers language-none"><code class="language-none">5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>BFS水题，看错题了，gg。</p><h3 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h3><p>AC代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#pragma warning(disable:4996)#include &lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;&#x2F;&#x2F;#define LOCALusing namespace std;const int maxn &#x3D; 200 + 10;typedef long long ll;int k[maxn][4];char a[maxn][maxn];bool vis[maxn][maxn];int r, c;int sx, sy, ex, ey;int relation;int nexts[4][2] &#x3D; &#123; &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125; &#125;;struct Node &#123;    int x, y, step;&#125;;bool border(int x, int y)&#123;    if (x &lt; 0 || y &lt; 0 || x &gt;&#x3D; r || y &gt;&#x3D; c)        return false;    return true;&#125;int bfs()&#123;    queue&lt;Node&gt; que;    while (!que.empty())        que.pop();    Node d, t;    t.x &#x3D; sx;    t.y &#x3D; sy;    t.step &#x3D; 0;    que.push(t);    vis[sx][sy] &#x3D; true;    while (!que.empty())    &#123;        t &#x3D; que.front();        que.pop();        if (t.x &#x3D;&#x3D; ex &amp;&amp; t.y &#x3D;&#x3D; ey)            return t.step;        for (int i &#x3D; 0; i &lt; relation; i++)        &#123;            if (k[i][0] &#x3D;&#x3D; t.x &amp;&amp; k[i][1] &#x3D;&#x3D; t.y &amp;&amp; !vis[k[i][2]][k[i][3]] &amp;&amp; a[k[i][2]][k[i][3]] !&#x3D; &#39;#&#39;)            &#123;                d.x &#x3D; k[i][2], d.y &#x3D; k[i][3];                d.step &#x3D; t.step + 1;                que.push(d);                &#x2F;&#x2F;cout &lt;&lt; d.x &lt;&lt; &quot; &quot; &lt;&lt; d.y &lt;&lt; endl;                vis[d.x][d.y] &#x3D; true;            &#125;            if (k[i][2] &#x3D;&#x3D; t.x &amp;&amp; k[i][3] &#x3D;&#x3D; t.y &amp;&amp; !vis[k[i][0]][k[i][1]] &amp;&amp; a[k[i][0]][k[i][1]] !&#x3D; &#39;#&#39;)            &#123;                d.x &#x3D; k[i][0], d.y &#x3D; k[i][1];                d.step &#x3D; t.step + 1;                que.push(d);                &#x2F;&#x2F;cout &lt;&lt; d.x &lt;&lt; &quot; &quot; &lt;&lt; d.y &lt;&lt; endl;                vis[d.x][d.y] &#x3D; true;            &#125;        &#125;        for (int i &#x3D; 0; i &lt; 4; i++)        &#123;            d.x &#x3D; t.x + nexts[i][0];            d.y &#x3D; t.y + nexts[i][1];            if (border(d.x, d.y) &amp;&amp; !vis[d.x][d.y] &amp;&amp; a[d.x][d.y] !&#x3D; &#39;#&#39;)            &#123;                d.step &#x3D; t.step + 1;                que.push(d);                &#x2F;&#x2F;cout &lt;&lt; d.x &lt;&lt; &quot; &quot; &lt;&lt; d.y &lt;&lt; endl;                vis[d.x][d.y] &#x3D; true;            &#125;        &#125;    &#125;    return -1;&#125;void solve()&#123;    int t;    cin &gt;&gt; t;    while (t--)    &#123;        cin &gt;&gt; r &gt;&gt; c;        for (int i &#x3D; 0; i &lt; r; i++) &#123;            for (int j &#x3D; 0; j &lt; c; j++) &#123;                scanf(&quot; %c&quot;, &amp;a[i][j]);                char ch &#x3D; a[i][j];                if (ch &#x3D;&#x3D; &#39;S&#39;)                    sx &#x3D; i, sy &#x3D; j;                else if (ch &#x3D;&#x3D; &#39;E&#39;)                    ex &#x3D; i, ey &#x3D; j;            &#125;        &#125;        memset(vis, false, sizeof(vis));        cin &gt;&gt; relation;        for (int i &#x3D; 0; i &lt; relation; i++)        &#123;            int x1, y1, x2, y2;            scanf(&quot;%d%d%d%d&quot;, &amp;k[i][0], &amp;k[i][1], &amp;k[i][2], &amp;k[i][3]);        &#125;        cout &lt;&lt; bfs() &lt;&lt; endl;    &#125;&#125;int main()&#123;#ifdef LOCAL    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);#endif    solve();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>科学上网 CentOS下Shadowsocks一键安装脚本（四合一，秋水逸冰版）、GoogleBBR加速</title>
      <link href="2018/10/27/Shadowsocks-easy-to-go-and-BBR-speed-up/"/>
      <url>2018/10/27/Shadowsocks-easy-to-go-and-BBR-speed-up/</url>
      
        <content type="html"><![CDATA[<p>本文使用秋水逸冰一键安装脚本，包含Python、Go等版本，一键安装，简单设置端口，密码即可。</p><p>同时，提供YouTube加速解决方案，采用Google官方BBR加速方案，具体原理可自行百度。</p><p>本文保证可以快速安装，部署使用。</p><a id="more"></a><h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><h2 id="脚本安装"><a href="#脚本安装" class="headerlink" title="脚本安装"></a>脚本安装</h2><p>使用root用户登录，运行以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget --no-check-certificate -O shadowsocks-all.sh https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;teddysun&#x2F;shadowsocks_install&#x2F;master&#x2F;shadowsocks-all.shchmod +x shadowsocks-all.sh.&#x2F;shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h3><ul><li>版本选择，有Shadowsocks-Python、ShadowsocksR、Shadowsocks-Go、Shadowsocks-libev这四种版本，默认是<code>Python</code>版的。我们这里也选择这个版本。</li><li>password，设置一下你的ss登录密码，默认是<code>teddysun.com</code>。</li><li>选择一个合适的端口，默认是<code>13914</code>。</li><li>选择加密方式，这里我们选择第7种，<code>aes-256-cfb</code>加密。</li><li>等待安装。</li></ul><h2 id="安装完成后，脚本提示如下"><a href="#安装完成后，脚本提示如下" class="headerlink" title="安装完成后，脚本提示如下"></a>安装完成后，脚本提示如下</h2><pre class="line-numbers language-none"><code class="language-none">Congratulations, your_shadowsocks_version install completed!Your Server IP :your_server_ipYour Server Port :your_server_portYour Password :your_passwordYour Encryption Method:your_encryption_methodYour QR Code: (For Shadowsocks Windows, OSX, Android and iOS clients) ss:&#x2F;&#x2F;your_encryption_method:your_password@your_server_ip:your_server_portYour QR Code has been saved as a PNG file path: your_path.pngWelcome to visit:https:&#x2F;&#x2F;teddysun.com&#x2F;486.htmlEnjoy it!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就算安装成功了，下载Shadowsocks客户端，输入配置就可以使用了，这里提供Windows和Android的，其他的，可自行去<a href="https://github.com/shadowsocks">Github</a>上找一下。</p><ul><li><a href="https://github.com/shadowsocks/shadowsocks-windows">Shadowsocks for Windows</a><ul><li>Download the latest release from <a href="https://github.com/shadowsocks/shadowsocks-csharp/releases">release page</a>.</li></ul></li><li><a href="https://github.com/shadowsocks/shadowsocks-android">Shadowsocks for Android</a><ul><li>Download at <a href="https://play.google.com/store/apps/details?id=com.github.shadowsocks">Google Play</a></li></ul></li></ul><h1 id="重启脚本"><a href="#重启脚本" class="headerlink" title="重启脚本"></a>重启脚本</h1><p>Shadowsocks-Python 版：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;etc&#x2F;init.d&#x2F;shadowsocks-python start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动脚本后面的参数（<code>start</code>,<code>stop</code>,<code>restart</code>,<code>status</code>）含义，从左至右依次为：启动，停止，重启，查看状态。</p><p>使用其他操作，将<code>start</code>换成<code>stop</code>、<code>restart</code>、<code>status</code>即可。</p><h1 id="卸载方法"><a href="#卸载方法" class="headerlink" title="卸载方法"></a>卸载方法</h1><p>若已安装多个版本，则卸载时也需多次运行（每次卸载一种）</p><p>使用root用户登录，运行以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;shadowsocks-all.sh uninstall<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="各Python版本默认配置文件"><a href="#各Python版本默认配置文件" class="headerlink" title="各Python版本默认配置文件"></a>各Python版本默认配置文件</h1><p>Shadowsocks-Python 版：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;etc&#x2F;shadowsocks-python&#x2F;config.json<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>来自 <a href="https://teddysun.com/486.html">https://teddysun.com/486.html</a></p></blockquote><h1 id="多端口登录"><a href="#多端口登录" class="headerlink" title="多端口登录"></a>多端口登录</h1><p>Shadowsocks-Python</p><p>Shadowsocks-Python 版的配置文件路径 <code>/etc/shadowsocks-python/config.json</code>，下面以修改该配置文件来说明。</p><p>在 Linux 下建议使用 vim 或者 nano 来编辑此配置文件。具体如何使用这两种编辑器，这里不多说明，可自行去搜索相关用法。</p><p>Shadowsocks-Python 版多端口配置文件示例：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;&quot;server&quot;:&quot;0.0.0.0&quot;,&quot;local_address&quot;:&quot;127.0.0.1&quot;,&quot;local_port&quot;:1080,&quot;port_password&quot;:&#123;&quot;9000&quot;:&quot;password0&quot;,&quot;9001&quot;:&quot;password1&quot;,&quot;9002&quot;:&quot;password2&quot;,&quot;9003&quot;:&quot;password3&quot;,&quot;9004&quot;:&quot;password4&quot;&#125;,&quot;timeout&quot;:300,&quot;method&quot;:&quot;your_encryption_method&quot;,&quot;fast_open&quot;: false&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他地方不用管，重点在于 <code>port_password</code> 字段的修改。</p><p>你想要多少端口就添加多少端口，注意需要符合 json 格式，里面的最后一行后面是没有英文逗号的，整个大括号的最后需要有一个英文逗号。</p><p>修改完成后，保存配置文件，重启。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;etc&#x2F;init.d&#x2F;shadowsocks-python restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>来自 <a href="https://teddysun.com/532.html">https://teddysun.com/532.html</a></p></blockquote><h1 id="连接不上解决方案"><a href="#连接不上解决方案" class="headerlink" title="连接不上解决方案"></a>连接不上解决方案</h1><p>如果新添加的端口无效，多半是没有开放端口，参考下边设置端口开放（8000改成自己想要开放的端口就可以了）。</p><h2 id="CentOS7"><a href="#CentOS7" class="headerlink" title="CentOS7"></a>CentOS7</h2><p>centos7中的防火墙改成了firewall，使用iptables无作用。<br>启动防火墙</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl start firewalld.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>开放端口</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">firewall-cmd --zone&#x3D;public --add-port&#x3D;8000&#x2F;tcp --permanent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回<code>success</code>代表成功。</p><p>重启防火墙</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart firewalld.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="CentOS6"><a href="#CentOS6" class="headerlink" title="CentOS6"></a>CentOS6</h2><p>CentOS6 使用如下命令。</p><p>开放端口</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;sbin&#x2F;iptables -I INPUT -p tcp --dport 8000 -j ACCEPT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>保存</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;iptables save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重启防火墙</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;etc&#x2F;init.d&#x2F;iptables restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="GoogleBBR加速"><a href="#GoogleBBR加速" class="headerlink" title="GoogleBBR加速"></a>GoogleBBR加速</h1><p>最近，Google 开源了其 TCP BBR 拥塞控制算法，并提交到了 Linux 内核，从 4.9 开始，Linux 内核已经用上了该算法。根据以往的传统，Google 总是先在自家的生产环境上线运用后，才会将代码开源，此次也不例外。</p><p>根据实地测试，在部署了最新版内核并开启了 TCP BBR 的机器上，网速甚至可以提升好几个数量级。</p><p>于是我根据目前三大发行版的最新内核，开发了一键安装最新内核并开启 TCP BBR 脚本。</p><h2 id="本脚本适用环境"><a href="#本脚本适用环境" class="headerlink" title="本脚本适用环境"></a>本脚本适用环境</h2><ul><li>系统支持：CentOS 6+，Debian 7+，Ubuntu 12+</li><li>虚拟技术：<code>OpenVZ 以外</code>(<code>openVZ</code>的在下边)的，比如 KVM、Xen、VMware 等</li><li>内存要求：≥128M</li><li>日期　　：2018 年 06 月 09 日</li></ul><p>如何查看VPS采用的虚拟技术？<a href="https://5chenglin.github.io/2019/02/20/20190220-Linux-Speedtest/">click here</a></p><h2 id="关于本脚本"><a href="#关于本脚本" class="headerlink" title="关于本脚本"></a>关于本脚本</h2><ol><li>本脚本已在 <a href="https://teddysun.com/t/vultr"><strong>Vultr</strong></a> <strong>上的</strong> <strong>VPS</strong> <strong>全部测试通过。</strong> </li><li>当脚本检测到 VPS 的虚拟方式为 OpenVZ 时，会提示错误，并自动退出安装。</li><li>脚本运行完重启发现开不了机的，打开 VPS 后台控制面板的 VNC, 开机卡在 grub 引导, 手动选择内核即可。</li><li>由于是使用最新版系统内核，最好请勿在生产环境安装，以免产生不可预测之后果。</li></ol><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>使用root用户登录，运行以下命令：</p><pre class="line-numbers language-none"><code class="language-none">wget --no-check-certificate https:&#x2F;&#x2F;github.com&#x2F;teddysun&#x2F;across&#x2F;raw&#x2F;master&#x2F;bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; .&#x2F;bbr.sh <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成后，脚本会提示需要重启 VPS，输入 y 并回车后重启。</p><p>重启完成后，进入 VPS，验证一下是否成功安装最新内核并开启 TCP BBR，输入以下命令：</p><pre class="line-numbers language-none"><code class="language-none">uname -r<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看内核版本，显示为最新版就表示 OK 了</p><pre class="line-numbers language-none"><code class="language-none">sysctl net.ipv4.tcp_available_congestion_control<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回值一般为：<code>net.ipv4.tcp_available_congestion_control = bbr cubic reno</code></p><p>或者为：<code>net.ipv4.tcp_available_congestion_control = reno cubic bbr</code></p><pre class="line-numbers language-none"><code class="language-none">sysctl net.ipv4.tcp_congestion_control<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回值一般为：<code>net.ipv4.tcp_congestion_control = bbr</code></p><pre class="line-numbers language-none"><code class="language-none">sysctl net.core.default_qdisc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回值一般为：<code>net.core.default_qdisc = fq</code></p><pre class="line-numbers language-none"><code class="language-none">lsmod | grep bbr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回值有 tcp_bbr 模块即说明 bbr 已启动。注意：并不是所有的 VPS 都会有此返回值，若没有也属正常。</p><blockquote><p>参考资料：<a href="https://teddysun.com/489.html">https://teddysun.com/489.html</a></p></blockquote><h2 id="采用OpenVZ架构的BBR加速"><a href="#采用OpenVZ架构的BBR加速" class="headerlink" title="采用OpenVZ架构的BBR加速"></a>采用OpenVZ架构的BBR加速</h2><p>OpenVZ平台的通过使用Rinetd来进行BBR加速，如果本方案无法正常安装，请查找别的Rinetd一键安装脚本即可。</p><h3 id="Debian-or-Ubuntu系统"><a href="#Debian-or-Ubuntu系统" class="headerlink" title="Debian or Ubuntu系统"></a>Debian or Ubuntu系统</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#适用于单网卡（单IP）服务器：wget https:&#x2F;&#x2F;github.com&#x2F;tcp-nanqinlang&#x2F;lkl-rinetd&#x2F;releases&#x2F;download&#x2F;1.1.0&#x2F;tcp_nanqinlang-rinetd-debianorubuntu.shbash tcp_nanqinlang-rinetd-debianorubuntu.sh#如果提示only support OpenVZ !，则使用下面这个脚本wget https:&#x2F;&#x2F;github.com&#x2F;tcp-nanqinlang&#x2F;lkl-rinetd&#x2F;releases&#x2F;download&#x2F;1.1.0-nocheckvirt&#x2F;tcp_nanqinlang-rinetd-debianorubuntu-nocheckvirt.shbash tcp_nanqinlang-rinetd-debianorubuntu-nocheckvirt.sh#适用于多网卡（多IP）服务器，会为所有网卡（所有IP）提供加速：wget https:&#x2F;&#x2F;github.com&#x2F;tcp-nanqinlang&#x2F;lkl-rinetd&#x2F;releases&#x2F;download&#x2F;1.1.0&#x2F;tcp_nanqinlang-rinetd-debianorubuntu-multiNIC.shbash tcp_nanqinlang-rinetd-debianorubuntu-multiNIC.sh#如果提示only support OpenVZ !，则使用下面这个脚本wget https:&#x2F;&#x2F;github.com&#x2F;tcp-nanqinlang&#x2F;lkl-rinetd&#x2F;releases&#x2F;download&#x2F;1.1.0-nocheckvirt&#x2F;tcp_nanqinlang-rinetd-debianorubuntu-nocheckvirt-multiNIC.shbash tcp_nanqinlang-rinetd-debianorubuntu-nocheckvirt-multiNIC.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CentOS-7系统"><a href="#CentOS-7系统" class="headerlink" title="CentOS 7系统"></a>CentOS 7系统</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#和上面一样，也分单网卡和多网卡版本#单网卡wget https:&#x2F;&#x2F;github.com&#x2F;tcp-nanqinlang&#x2F;lkl-rinetd&#x2F;releases&#x2F;download&#x2F;1.1.0&#x2F;tcp_nanqinlang-rinetd-centos.shbash tcp_nanqinlang-rinetd-centos.sh#如果提示only support OpenVZ !，则使用下面这个脚本wget https:&#x2F;&#x2F;github.com&#x2F;tcp-nanqinlang&#x2F;lkl-rinetd&#x2F;releases&#x2F;download&#x2F;1.1.0-nocheckvirt&#x2F;tcp_nanqinlang-rinetd-centos-nocheckvirt.shbash tcp_nanqinlang-rinetd-centos-nocheckvirt.sh#多网卡wget https:&#x2F;&#x2F;github.com&#x2F;tcp-nanqinlang&#x2F;lkl-rinetd&#x2F;releases&#x2F;download&#x2F;1.1.0&#x2F;tcp_nanqinlang-rinetd-centos.shbash tcp_nanqinlang-rinetd-centos.sh#如果提示only support OpenVZ !，则使用下面这个脚本wget https:&#x2F;&#x2F;github.com&#x2F;tcp-nanqinlang&#x2F;lkl-rinetd&#x2F;releases&#x2F;download&#x2F;1.1.0-nocheckvirt&#x2F;tcp_nanqinlang-rinetd-debianorubuntu-nocheckvirt-multiNIC.shbash tcp_nanqinlang-rinetd-debianorubuntu-nocheckvirt-multiNIC.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p>在<code>/home/tcp_nanqinlang</code>进行安装，所以安装完成后不要动这个文件夹了（除非你想修改端口）。</p><p>安装过程中，会提示输入端口号。多个端口号用空格隔开。不支持端口段。</p><p>安装完成后，会开启<code>rinetd-bbr</code>。以后重启机器也会随开机自启。</p><p>使用前请注意自己的<code>iptables</code>相关设置。</p><p>由于脚本刚写，所以对部分系统可能存在点问题，有疑问的欢迎去联系大佬。方式通过：<a href="https://github.com/nanqinlang">Github issue</a>、<a href="https://t.me/SometimesNaiveReporter">Telegram</a>、原文地址(不好意思，在我编辑这篇博客的时候，原文已经404了，就没贴出地址(#滑稽) )。</p><blockquote><p>OpenVZ平台BBR加速参考:<a href="https://www.moerats.com/archives/504/">https://www.moerats.com/archives/504/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术博文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shadowsocks </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
